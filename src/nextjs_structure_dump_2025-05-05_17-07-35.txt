🔎 Dump de Estrutura – Projeto Next.js
Raiz do projeto : ./src
Gerado em       : Mon May  5 17:07:35 -03 2025
------------------------------------------------------------

📄 Arquivo : OfflineMapButton.jsx
📂 Pasta   : components
🧭 Caminho : components/OfflineMapButton.jsx
--------------------------------------
📜 Conteúdo:

import React, { useState } from "react";
import MapLeafletNoSSR from "@/components/map/MapLeafletNoSSR";
import Button from "@/components/ui/Button";
import { useLoading } from "@/context/LoadingContext";

export default function OfflineMapButton({ onLocationSelect }) {
  const [showMap, setShowMap] = useState(false);
  const { setIsLoading } = useLoading();

  function openMap() {
    setShowMap(true);
  }

  function closeMap() {
    setShowMap(false);
  }

  async function handleSaveLocation(coords) {
    const { lat, lng } = coords;

    try {
      setIsLoading("Coletando dados da localização...");
      const locationRes = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}`
      );
      const locationData = await locationRes.json();
      setIsLoading("Obtendo dados do clima...");
      const weatherRes = await fetch(
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true`
      );
      const weatherData = await weatherRes.json();
      const result = {
        lat,
        lng,
        location: locationData.display_name || "Localização não identificada",
        weather_celsius: weatherData.current_weather?.temperature ?? null,
        weather_fahrenheit:
          weatherData.current_weather?.temperature !== undefined
            ? (weatherData.current_weather.temperature * 9) / 5 + 32
            : null,
      };

      onLocationSelect?.(result);
    } catch (err) {
      console.error("Erro ao buscar dados:", err);
      alert("Erro ao buscar informações da localização.");
    } finally {
      setIsLoading(false);
      setShowMap(false);
    }
  }

  return (
    <div>
      {!showMap && (
        <Button
          type="submit"
          variant="dark"
          className="w-md text-sm py-3 active:scale-95"
          onClick={openMap}
        >
          Abrir mapa
        </Button>
      )}

      {showMap && (
        <MapLeafletNoSSR
          lat={-23.5505}
          lng={-46.6333}
          zoom={13}
          onClose={closeMap}
          onSaveLocation={handleSaveLocation}
        />
      )}
    </div>
  );
}


============================================================


📄 Arquivo : index.jsx
📂 Pasta   : components/chart
🧭 Caminho : components/chart/index.jsx
--------------------------------------
📜 Conteúdo:

"use client"

import { Bar, BarChart, CartesianGrid, XAxis } from "recharts"


import { ChartConfig, ChartContainer, ChartTooltip, ChartTooltipContent, ChartLegend, ChartLegendContent } from "@/components/ui/chart"

const chartData = [
  { month: "January", desktop: 186, mobile: 80 },
  { month: "February", desktop: 305, mobile: 200 },
  { month: "March", desktop: 237, mobile: 120 },
  { month: "April", desktop: 73, mobile: 190 },
  { month: "May", desktop: 209, mobile: 130 },
  { month: "June", desktop: 214, mobile: 140 },
]

const chartConfig = {
  desktop: {
    label: "Desktop",
    color: "#2563eb",
  },
  mobile: {
    label: "Mobile",
    color: "#60a5fa",
  },
}

export default function ChartOverview() {
  return (
<ChartContainer config={chartConfig} className="h-[200px] w-full">
  <BarChart accessibilityLayer data={chartData}>
    <CartesianGrid vertical={false} />
    <XAxis
      dataKey="month"
      tickLine={false}
      tickMargin={10}
      axisLine={false}
      tickFormatter={(value) => value.slice(0, 3)}
    />
    <ChartTooltip content={<ChartTooltipContent />} />
    <ChartLegend content={<ChartLegendContent />} />
    <Bar dataKey="desktop" fill="var(--color-desktop)" radius={4} />
    <Bar dataKey="mobile" fill="var(--color-mobile)" radius={4} />
  </BarChart>
</ChartContainer>
  )
}


============================================================


📄 Arquivo : FieldActionButtons.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FieldActionButtons.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FieldActionButtons.jsx
import { ArrowUp, ArrowDown, Edit, Trash2 } from "lucide-react";

export default function FieldActionButtons({
  index,
  total,
  onMoveUp,
  onMoveDown,
  onEdit,
  onRemove,
}) {
  return (
    <div className="flex sm:flex-row flex-col justify-end gap-4 sm:items-center w-full sm:w-auto">
      <div className="flex flex-row sm:flex-col justify-center items-center gap-2">
        <button
          onClick={() => onEdit(index)}
          aria-label="Editar pergunta"
          className="p-1 bg-blue-100 hover:bg-blue-200 text-blue-600 rounded-lg transition"
        >
          <Edit size={15} />
        </button>
        <button
          onClick={() => onRemove(index)}
          aria-label="Remover pergunta"
          className="p-1 bg-red-100 hover:bg-red-200 text-red-600 rounded-lg transition"
        >
          <Trash2 size={15} />
        </button>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : FieldMoveButtons.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FieldMoveButtons.jsx
--------------------------------------
📜 Conteúdo:


import { ArrowUp, ArrowDown } from "lucide-react";

export default function FieldMoveButtons({
  index,
  total,
  onMoveUp,
  onMoveDown,
}) {
  return (
    <div className="h-full flex sm:flex-col flex-col justify-between gap-4 sm:items-center w-full sm:w-auto">
      <div className="h-full flex flex-col sm:flex-col justify-between items-center gap-2">
        <button
          onClick={() => index > 0 && onMoveUp(index)}
          aria-label="Mover para cima"
          className="p-1 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg transition"
        >
          <ArrowUp size={15} />
        </button>
        <button
          onClick={() => index < total - 1 && onMoveDown(index)}
          aria-label="Mover para baixo"
          className="p-1 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg transition"
        >
          <ArrowDown size={15} />
        </button>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : FormBuilder.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormBuilder.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import Button from "@/components/ui/Button";
import FormField from "@/components/forms/FormField";
import { motion, AnimatePresence } from "framer-motion";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import SelectedFormFields from "@/components/forms/SelectedFormFields";
import MultipleChoiceEditor from "@/components/forms/MultipleChoiceEditor";
import Switch from "@/components/ui/Switch";
import { useInputTypes } from "@/hooks/useInputTypes";
import { useFields } from "@/hooks/useFields";
import { useFieldOptions } from "@/hooks/useFieldOptions";

export default function FormBuilder({ survey_id, survey_type, onSubmit }) {
  const { types: inputTypes, loading } = useInputTypes();
  const { fields, addField, updateField, deleteField } = useFields(survey_id, survey_type);
  const [formFields, setFormFields] = useState([]);
  const [newOptions, setNewOptions] = useState([]);
  const [editingIndex, setEditingIndex] = useState(null);
  const [showFormBuilder, setShowFormBuilder] = useState(false);
  const [newQuestion, setNewQuestion] = useState({ title: "", inputType: null });

  const [currentFieldId, setCurrentFieldId] = useState(null);
  const fieldOptionsHook = useFieldOptions(currentFieldId);

  useEffect(() => {
    const enriched = fields.map((field) => {
      const inputType = inputTypes.find((t) => t.id === field.input_type_id);
      return inputType ? { ...field, input_type_name: inputType.name, stored_as: inputType.stored_as } : field;
    });
    setFormFields(enriched);
  }, [fields, inputTypes]);

  const handleSaveQuestion = async () => {
    if (!newQuestion.title || !newQuestion.inputType) return;

    const fieldPayload = {
      title: newQuestion.title,
      description: newQuestion.title,
      input_type_id: newQuestion.inputType.value,
      input_type: newQuestion.inputType.value,
      survey_id,
    };

    try {
      if (editingIndex === null) {
        const created = await addField(fieldPayload);
        setCurrentFieldId(created.id);

        if (newQuestion.inputType.stored_as === "array") {
          const createdOptions = await Promise.all(
            newOptions.map((opt) =>
              fieldOptionsHook.addOption({
                field_id: created.id,
                option_text: opt.option_text || "-",
                option_value: opt.option_df_value,
              })
            )
          );
          created.options = createdOptions;
        }

        setFormFields((prev) => [...prev, created]);
      } else {
        const updated = {
          ...formFields[editingIndex],
          ...fieldPayload,
          input_type_id: newQuestion.inputType?.value ?? formFields[editingIndex].input_type_id,
        };
        await updateField(updated.id, updated);
        setCurrentFieldId(updated.id);

        if (newQuestion.inputType.stored_as === "array") {
          const field_id = updated.id;
          const oldOptions = formFields[editingIndex].options || [];

          const updatedOptions = await Promise.all(
            newOptions.map(async (opt) => {
              if (opt.id) {
                await fieldOptionsHook.updateOption(opt.id, {
                  option_text: opt.option_text,
                  option_value: opt.option_df_value,
                });
                return opt;
              } else {
                return await fieldOptionsHook.addOption({
                  field_id,
                  option_text: opt.option_text,
                  option_value: opt.option_df_value,
                });
              }
            })
          );

          const removed = oldOptions.filter((o) => !newOptions.find((n) => n.id === o.id));
          await Promise.all(
            removed.map((opt) => fieldOptionsHook.deleteOption(opt.id))
          );

          updated.options = updatedOptions;
        }

        const clone = [...formFields];
        clone[editingIndex] = updated;
        setFormFields(clone);
      }

      setNewQuestion({ title: "", inputType: null });
      setNewOptions([]);
      setEditingIndex(null);
    } catch (err) {
      console.error("Erro ao salvar a pergunta:", err);
    }
  };

  const handleRemoveQuestion = async (index) => {
    const toDelete = formFields[index];
    await deleteField(toDelete.id);
    const updated = [...formFields];
    updated.splice(index, 1);
    setFormFields(updated);
    if (editingIndex === index) {
      setEditingIndex(null);
      setNewQuestion({ title: "", inputType: null });
    }
  };

  const handleEditQuestion = (index) => {
    const item = formFields[index];
    if (!item) return;

    const foundInputType = inputTypes.find((t) => t.id === item.input_type_id);
    setCurrentFieldId(item.id);

    setEditingIndex(index);
    setNewQuestion({
      title: item.title,
      inputType: foundInputType
        ? {
            value: foundInputType.id,
            label: foundInputType.name,
            stored_as: foundInputType.stored_as,
          }
        : {
            value: item.input_type_id,
            label: item.input_type_name,
            stored_as: item.stored_as,
          },
    });
    setNewOptions(item.options || []);
  };

  const handleSaveForm = () => {
    const payload = { survey_id, fields: formFields };
    if (onSubmit) onSubmit(payload);
  };

  return (
    <div className="space-y-8 max-w-4xl mx-auto p-6 rounded-xl">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-bold text-gray-800">Formulário</h2>
          <p className="text-sm text-gray-600">Adicione perguntas e selecione os tipos de resposta.</p>
        </div>
        <div className="flex items-center gap-2">
          <Switch checked={showFormBuilder} onChange={setShowFormBuilder} type="arrow" />
        </div>
      </div>

      {showFormBuilder && (
        <div className="space-y-4">
          <div className="bg-gray-100 p-5 rounded-lg border space-y-4">
            <h3 className="text-md font-semibold text-gray-700">
              {editingIndex === null ? "Adicionar Pergunta" : "Editar Pergunta"}
            </h3>

            <FormField
              legend="Enunciado da Pergunta"
              type="text"
              value={newQuestion.title}
              onChange={(e) =>
                setNewQuestion((prev) => ({ ...prev, title: e.target.value }))
              }
            />

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Tipo de Resposta
              </label>
              <MultiSelect
                options={inputTypes.map((t) => ({
                  value: t.id,
                  label: t.name,
                  stored_as: t.stored_as,
                }))}
                value={newQuestion.inputType}
                onChange={(selected) =>
                  setNewQuestion((prev) => ({ ...prev, inputType: selected || null }))
                }
                placeholder="Selecione o tipo de resposta"
                isMulti={false}
                closeMenuOnSelect={true}
                isDisabled={loading}
              />
            </div>

            {newQuestion.inputType?.stored_as === "array" && (
              <MultipleChoiceEditor options={newOptions} setOptions={setNewOptions} />
            )}

            <div className="flex justify-center">
              <Button variant="verde" onClick={handleSaveQuestion}>
                {editingIndex === null ? "Criar Pergunta" : "Salvar Edição"}
              </Button>
            </div>
          </div>

          <AnimatePresence>
            {formFields.length > 0 && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 10 }}
                transition={{ duration: 0.3 }}
              >
                <SelectedFormFields
                  fields={formFields}
                  setFields={setFormFields}
                  onEditQuestion={handleEditQuestion}
                  onRemoveQuestion={handleRemoveQuestion}
                />
              </motion.div>
            )}
          </AnimatePresence>

          <div className="flex justify-center pt-4 pb-2">
            <Button variant="secondary" onClick={handleSaveForm} className="text-base px-6 py-2">
              Salvar Estrutura do Formulário
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : FormField.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormField.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion } from "framer-motion";
import FormFieldDate from "@/components/forms/FormFieldDate";
import FormFieldText from "@/components/forms/FormFieldText";
import FormFieldNumber from "@/components/forms/FormFieldNumber";
import FormFieldTextarea from "@/components/forms/FormFieldTextarea";

export default function FormField({
  legend,
  type = "text",
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(!!value);
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      {type === "date" && (
        <FormFieldDate
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type === "number" && (
        <FormFieldNumber
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type === "textarea" && (
        <FormFieldTextarea
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type !== "date" && type !== "number" && type !== "textarea" && (
        <FormFieldText
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldDate.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldDate.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Calendar from "react-calendar";
import "react-calendar/dist/Calendar.css";

// Converte um objeto Date para uma string no formato YYYY-MM-DD (usando valores locais)
function formatDateToLocalYYYYMMDD(date) {
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  return `${year}-${month}-${day}`;
}

// Formata uma string no formato YYYY-MM-DD para DD/MM/YYYY, sem criar novo objeto Date
function formatDateToDDMMYY(dateString) {
  if (!dateString) return "";
  const [year, month, day] = dateString.split("-");
  return `${day}/${month}/${year}`;
}

// Converte a string "YYYY-MM-DD" em um objeto Date usando os componentes locais
function parseDateString(dateString) {
  if (!dateString) return new Date();
  const [year, month, day] = dateString.split("-").map(Number);
  return new Date(year, month - 1, day);
}

export default function FormFieldDate({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [calendarOpen, setCalendarOpen] = useState(false);
  const ref = useRef(null);

  // Fecha o calendário ao clicar fora do componente
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (ref.current && !ref.current.contains(e.target)) {
        setCalendarOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Exibe a data no formato DD/MM/YYYY
  const displayValue = value ? formatDateToDDMMYY(value) : "__/__/__";

  return (
    <motion.div
      className="relative w-fit"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative" ref={ref}>
        {/* Label */}
        <div className="flex items-center gap-1 mb-1">
          <label className="text-sm font-medium text-gray-700">{legend}</label>
          {tooltip && (
            <span className="text-gray-400 text-xs cursor-help" title={tooltip}>
              ⓘ
            </span>
          )}
        </div>

        {/* Botão que exibe a data e abre o calendário */}
        <button
          type="button"
          onClick={() => setCalendarOpen((prev) => !prev)}
          disabled={disabled}
          className={`w-40 px-4 py-2 border ${
            error
              ? "border-red-500"
              : disabled
              ? "border-gray-200"
              : "border-gray-400"
          } rounded-md text-sm flex justify-between items-center ${bgColor} ${
            disabled ? "cursor-not-allowed text-gray-400" : "hover:border-black"
          }`}
        >
          <span className="text-left">{displayValue}</span>
          <span className="material-symbols-outlined text-base text-gray-500 ml-2">
            calendar_month
          </span>
        </button>

        {/* Popover do calendário */}
        <AnimatePresence>
          {calendarOpen && !disabled && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              transition={{ duration: 0.2 }}
              className="absolute z-50 mt-2 rounded-lg shadow-xl bg-white border border-gray-200"
            >
              <Calendar
                onChange={(date) => {
                  // Cria um objeto Date a partir dos valores locais (ano, mês e dia)
                  const localDate = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    date.getDate()
                  );
                  const formatted = formatDateToLocalYYYYMMDD(localDate);
                  onChange({ target: { value: formatted } });
                  setCalendarOpen(false);
                }}
                // Converte a string de valor para um objeto Date com a função parseDateString
                value={value ? parseDateString(value) : new Date()}
                className="rounded-lg p-2 [&_.react-calendar__tile--active]:!bg-black [&_.react-calendar__tile--active]:text-white"
              />
            </motion.div>
          )}
        </AnimatePresence>

        {/* Exibe mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldNumber.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldNumber.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FormFieldNumber.jsx
import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldNumber({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(value !== null && value !== "");
  }, [value]);

  return (
    <motion.div
      className="relative w-full max-w-xs" // <-- menor largura
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        {/* Label flutuante */}
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {/* Tooltip opcional */}
        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        {/* Input */}
        <input
          type="number"
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />

        {/* Mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldText.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldText.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldText({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(!!value);
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        {/* Label flutuante */}
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {/* Tooltip opcional */}
        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        {/* Input */}
        <input
          type="text"
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />
        {/* Mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldTextarea.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldTextarea.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FormFieldTextarea.jsx
import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldTextarea({
  legend,
  value,
  onChange,
  disabled = false,
  rows = 4,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(value !== null && value !== "");
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        <textarea
          rows={rows}
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all resize-y ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />

        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : MultipleChoiceEditor.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/MultipleChoiceEditor.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/MultipleChoiceEditor.jsx
import { useState } from "react";
import { Trash2, Plus } from "lucide-react";
import Button from "@/components/ui/Button";
import FormField from "@/components/forms/FormField";
import { motion, AnimatePresence } from "framer-motion";

export default function MultipleChoiceEditor({ options = [], setOptions }) {
  const [draft, setDraft] = useState({ option_text: "-", option_df_value: "" });

  const handleAdd = () => {
    if (!draft.option_text.trim() || !draft.option_df_value.trim()) return;
    setOptions((prev) => [...prev, draft]);
    setDraft({ option_text: "-", option_df_value: "" });
  };

  const handleRemove = (index) => {
    setOptions((prev) => prev.filter((_, i) => i !== index));
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      className="space-y-4 p-5 rounded-xl bg-gray-100"
    >
      <h4 className="text-base font-semibold text-gray-800">
        Opções da pergunta:
      </h4>

      {/* Campos de entrada */}
      <div className="flex flex-col sm:flex-row gap-3">
        {/* <div className="w-full sm:w-1/5">
          <FormField
            legend="Letra da opção"
            type="text"
            value={draft.option_text}
            onChange={(e) =>
              setDraft((prev) => ({ ...prev, option_text: e.target.value }))
            }
            placeholder="a."
          />
        </div> */}
        <div className="flex-1">
          <FormField
            legend="Valor da opção"
            type="text"
            value={draft.option_df_value}
            onChange={(e) =>
              setDraft((prev) => ({ ...prev, option_df_value: e.target.value }))
            }
            placeholder="Ex: Casa, Apartamento, etc."
          />
        </div>

        <div className="flex items-end">
          <Button
            variant="azul_escuro"
            onClick={handleAdd}
            className="flex items-center gap-2 h-[42px]"
          >
            <Plus size={18} /> Adicionar
          </Button>
        </div>
      </div>

      {/* Lista de opções adicionadas */}
      <div className="space-y-2">
        <AnimatePresence>
          {options.map((opt, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 5 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -5 }}
              transition={{ duration: 0.2 }}
              className="flex items-center justify-between bg-white border rounded-lg p-3 shadow-sm"
            >
              <div className="text-sm text-gray-700 font-medium">
                <span className="text-gray-500 mr-1">{opt.option_text}</span>
                {opt.option_df_value}
              </div>
              <button
                onClick={() => handleRemove(idx)}
                className="text-red-500 hover:text-red-600 text-xs flex items-center gap-1"
              >
                <Trash2 size={16} /> Remover
              </button>
            </motion.div>
          ))}
        </AnimatePresence>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : SelectedFormFieldCard.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/SelectedFormFieldCard.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";
import FieldActionButtons from "./FieldActionButtons";

export default function SelectedFormFieldCard({
  field,
  index,
  total,
  onEdit,
  onRemove
}) {
  return (
    <motion.div
      layout
      className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4"
    >
      <div className="flex-1 min-w-0 space-y-1">
        <span>
          <span className="text-sm text-gray-500">Pergunta {index + 1} </span>
        </span>
        <p className="font-semibold text-gray-900 text-base sm:text-md break-words">
          {field.title}
        </p>
        <p className="text-sm text-gray-500">
          Respostas do tipo:{" "}
          <span className="font-medium text-gray-700">
            {field.input_type_name}
          </span>
        </p>
      </div>

      <div className="flex sm:flex-col gap-2 justify-end">
        <FieldActionButtons
          index={index}
          total={total}
          onEdit={onEdit}
          onRemove={onRemove}
        />
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : SelectedFormFields.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/SelectedFormFields.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import SelectedFormFieldCard from "./SelectedFormFieldCard";
import FieldMoveButtons from "./FieldMoveButtons";
import { useEffect } from "react";

export default function SelectedFormFields({
  fields = [],
  setFields,
  onEditQuestion,
  onRemoveQuestion,
}) {
  const moveItem = (fromIndex, toIndex) => {
    if (toIndex < 0 || toIndex >= fields.length) return;
    const newArr = [...fields];
    [newArr[toIndex], newArr[fromIndex]] = [newArr[fromIndex], newArr[toIndex]];
    setFields(newArr);
  };


  return (
    <div className="mt-8 max-w-4xl mx-auto space-y-6 px-4">
      <h3 className="text-lg font-semibold text-gray-800">Perguntas:</h3>
      <AnimatePresence>
        {fields.map((field, index) => (
          <motion.div
            key={field.id}
            layout
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0.3 }}
            className="flex gap-3 items-center justify-between"
          >
            <div className="flex-1 rounded-xl bg-white border shadow-sm p-5 flex flex-col justify-between">
              <SelectedFormFieldCard
                field={field}
                index={index}
                total={fields.length}
                onEdit={onEditQuestion}
                onRemove={onRemoveQuestion}
                onMoveUp={() => moveItem(index, index - 1)}
                onMoveDown={() => moveItem(index, index + 1)}
              />
            </div>

            <div className="flex flex-col sm:flex-col gap-2 justify-between h-full sm:h-auto sm:justify-between">
              <FieldMoveButtons
                index={index}
                total={fields.length}
                onMoveUp={() => moveItem(index, index - 1)}
                onMoveDown={() => moveItem(index, index + 1)}
              />
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : PrivateLayout.jsx
📂 Pasta   : components/layouts
🧭 Caminho : components/layouts/PrivateLayout.jsx
--------------------------------------
📜 Conteúdo:

// src/components/PrivateLayout.jsx
import { useState } from "react";
import Head from "next/head";
import SidebarDesktop from "./nav/SidebarDesktop";
import SidebarMobile from "./nav/SidebarMobile";
import TopBar from "./nav/TopBar";
import { useAuth } from "@/context/AuthContext";

export default function PrivateLayout({ children, pageName}) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const { userData } = useAuth();

  return (
    <>
      <Head>
        <title>{pageName || "Área Logada"}</title>
      </Head>
      <div className="flex h-screen overflow-hidden">
        {/* Sidebar para desktop */}
        <SidebarDesktop userRole={userData?.role} />
        {/* Sidebar para mobile */}
        <SidebarMobile userRole={userData?.role} sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
        {/* Conteúdo principal */}
        <div className="flex flex-col flex-1 overflow-hidden">
          <TopBar setSidebarOpen={setSidebarOpen} pageName={pageName} />
          <main className="flex-1 overflow-y-auto bg-gradient-to-br from-white to-gray-200">
            {children}
          </main>
        </div>
      </div>
    </>
  );
}


============================================================


📄 Arquivo : PublicLayout.jsx
📂 Pasta   : components/layouts
🧭 Caminho : components/layouts/PublicLayout.jsx
--------------------------------------
📜 Conteúdo:

import Head from "next/head";

export default function PublicLayout({ children, pageName }) {
  return (
    <>
      <Head>
        <title>{pageName ? `${pageName}` : "Minha Aplicação"}</title>
      </Head>
      <main className="min-h-screen bg-white">
        {children}
      </main>
    </>
  );
}


============================================================


📄 Arquivo : SidebarDesktop.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/SidebarDesktop.jsx
--------------------------------------
📜 Conteúdo:

import Link from "next/link";
import Image from "next/image";
import { TABS, PERMISSION_TABS, TABSTYLES } from "@/config/tabs";
import { useRouter } from "next/router";
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Button from "@/components/ui/Button";
import { initAuthDB } from "@/lib/db";
import FullscreenButton from "@/components/ui/FullscreenButton";

function getAllowedTabs(userRole) {
  const isAllowed = (name) => {
    let restrictedRoles = [];
    for (const role in PERMISSION_TABS) {
      if (PERMISSION_TABS[role].includes(name)) {
        restrictedRoles.push(role);
      }
    }
    return restrictedRoles.length === 0 || restrictedRoles.includes(userRole);
  };

  return Object.entries(TABS)
    .map(([tabName, tabData]) => {
      if (tabData.subTabs) {
        const allowedSubTabs = Object.entries(tabData.subTabs).filter(
          ([subTabName]) => isAllowed(subTabName)
        );
        if (allowedSubTabs.length > 0) {
          return [tabName, { ...tabData, allowedSubTabs }];
        }
        return null;
      } else {
        return isAllowed(tabName) ? [tabName, tabData] : null;
      }
    })
    .filter(Boolean);
}

export default function SidebarDesktop({ userRole }) {
  const [expanded, setExpanded] = useState(true);
  const [hoveredTab, setHoveredTab] = useState(null);
  const [openDropdown, setOpenDropdown] = useState(null);
  const router = useRouter();
  const allowedTabs = getAllowedTabs(userRole);

  useEffect(() => {
    if (expanded) {
      setHoveredTab(null);
    }
  }, [expanded]);

  const handleLogout = async () => {
    await fetch("/api/auth/logout", { method: "POST" });
    try {
      const db = await initAuthDB();
      await db.clear("user-data");
      await db.clear("user-creds");
    } catch (err) {
      console.error("Erro ao limpar IndexedDB:", err);
    }
    window.location.href = "/login";
  };

  const handleTabClick = (name, link, hasSubTabs) => {
    if (hasSubTabs) {
      setOpenDropdown(openDropdown === name ? null : name);
    } else {
      router.push(link);
    }
  };

  return (
    <motion.div
      initial={{ width: 256 }}
      animate={{ width: expanded ? 256 : 72 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
      className="hidden md:flex md:flex-shrink-0 bg-white border-r border-gray-200 p-4"
    >
      <div className="flex flex-col h-full w-full justify-between">
        {/* Header */}
        <div className="flex items-center justify-between px-4 h-16 border-b">
          {expanded && (
            <Link href="/" onClick={(e) => e.stopPropagation()}>
              <Image
                src="/img/placemaking.png"
                alt="Logo"
                width={150}
                height={60}
                className="object-contain transition-all duration-300"
                priority
              />
            </Link>
          )}
          <button
            onClick={(e) => {
              e.stopPropagation();
              setExpanded((prev) => !prev);
            }}
            className="text-gray-500 hover:text-gray-800"
          >
            <span className="material-symbols-outlined text-xl">
              {expanded ? "chevron_left" : "chevron_right"}
            </span>
          </button>
        </div>

        {/* Navegação (tabs) */}
        <nav className="flex-1 overflow-y-auto py-4 space-y-1">
          {allowedTabs.map(([name, data]) => {
            const hasSubTabs = data.allowedSubTabs;
            const isActive =
              router.pathname === data.link ||
              (hasSubTabs &&
                data.allowedSubTabs.some(
                  ([, subData]) => subData.link === router.pathname
                ));
            return (
              <div key={name} className="relative">
                <div
                  onMouseEnter={() => {
                    if (!expanded) setHoveredTab(name);
                  }}
                  onMouseLeave={() => {
                    if (!expanded) setHoveredTab(null);
                  }}
                >
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleTabClick(name, data.link, hasSubTabs);
                    }}
                    className={`group flex items-center gap-3 px-4 py-2 rounded-md transition-all w-full ${
                      isActive ? TABSTYLES.active : TABSTYLES.inactive
                    } ${!expanded ? "justify-center" : ""}`}
                  >
                    <span className="material-symbols-outlined text-xl">
                      {data.icon}
                    </span>
                    {expanded && (
                      <span className="text-sm font-medium whitespace-nowrap">
                        {name}
                      </span>
                    )}
                    {hasSubTabs && expanded && (
                      <span className="ml-auto material-symbols-outlined">
                        {openDropdown === name ? "expand_less" : "expand_more"}
                      </span>
                    )}
                  </button>
                  {!expanded && hoveredTab === name && (
                    <AnimatePresence>
                      <motion.div
                        initial={{ opacity: 0, x: 10 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 10 }}
                        transition={{ duration: 0.2 }}
                        className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
                      >
                        {name}
                      </motion.div>
                    </AnimatePresence>
                  )}
                </div>
                {hasSubTabs && openDropdown === name && expanded && (
                  <motion.div
                    initial={{ opacity: 0, height: 0, y: -10 }}
                    animate={{ opacity: 1, height: "auto", y: 0 }}
                    exit={{ opacity: 0, height: 0, y: -10 }}
                    transition={{ duration: 0.3 }}
                    className="ml-3 mt-1 space-y-1 bg-white rounded-md"
                  >
                    {data.allowedSubTabs.map(([subName, subData]) => {
                      const isSubActive = router.pathname === subData.link;
                      return (
                        <Link
                          key={subName}
                          href={subData.link}
                          onClick={(e) => e.stopPropagation()}
                          className={`flex items-center gap-2 px-4 py-2 transition-all rounded-md ${
                            isSubActive
                              ? "bg-black text-white"
                              : "bg-white text-gray-700 hover:bg-gray-50"
                          }`}
                        >
                          <span className="material-symbols-outlined text-sm">
                            {subData.icon}
                          </span>
                          <span className="text-sm font-medium">{subName}</span>
                        </Link>
                      );
                    })}
                  </motion.div>
                )}
              </div>
            );
          })}
        </nav>

        {/* Footer (Logout) */}
        {/* Footer (Fullscreen + Logout) */}
        <div className="space-y-1">
          <FullscreenButton
            expanded={expanded}
            hovered={hoveredTab}
            setHovered={setHoveredTab}
          />

          <div
            className="relative"
            onMouseEnter={() => {
              if (!expanded) setHoveredTab("Logout");
            }}
            onMouseLeave={() => {
              if (!expanded) setHoveredTab(null);
            }}
          >
            <Button
              onClick={handleLogout}
              variant="transparent_vermelho"
              className={`w-full flex items-center gap-2 px-4 py-2 rounded transition ${
                !expanded ? "justify-center" : ""
              }`}
            >
              <span className="material-symbols-outlined text-xl">logout</span>
              {expanded && (
                <span className="text-sm font-medium whitespace-nowrap">
                  Logout
                </span>
              )}
            </Button>

            {!expanded && hoveredTab === "Logout" && (
              <AnimatePresence>
                <motion.div
                  initial={{ opacity: 0, x: 10 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 10 }}
                  transition={{ duration: 0.2 }}
                  className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
                >
                  Logout
                </motion.div>
              </AnimatePresence>
            )}
          </div>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : SidebarMobile.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/SidebarMobile.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";
import Link from "next/link";
import Image from "next/image";
import { TABS, PERMISSION_TABS, TABSTYLES } from "@/config/tabs";
import { useRouter } from "next/router";
import { useState } from "react";
import { initAuthDB } from "@/lib/db";
import Button from "@/components/ui/Button";

function getAllowedTabs(userRole) {
  const isAllowed = (name) => {
    let restrictedRoles = [];
    for (const role in PERMISSION_TABS) {
      if (PERMISSION_TABS[role].includes(name)) {
        restrictedRoles.push(role);
      }
    }
    return restrictedRoles.length === 0 || restrictedRoles.includes(userRole);
  };

  return Object.entries(TABS)
    .map(([tabName, tabData]) => {
      if (tabData.subTabs) {
        const allowedSubTabs = Object.entries(tabData.subTabs).filter(
          ([subTabName]) => isAllowed(subTabName)
        );
        if (allowedSubTabs.length > 0) {
          return [tabName, { ...tabData, allowedSubTabs }];
        }
        return null;
      } else {
        return isAllowed(tabName) ? [tabName, tabData] : null;
      }
    })
    .filter(Boolean);
}

export default function SidebarMobile({
  userRole,
  sidebarOpen,
  setSidebarOpen,
}) {
  const allowedTabs = getAllowedTabs(userRole);
  const router = useRouter();
  const [openDropdown, setOpenDropdown] = useState(null);

  const sidebarVariants = {
    hidden: { x: "-100%" },
    visible: { x: 0 },
  };

  const handleLogout = async () => {
    await fetch("/api/auth/logout", { method: "POST" });
    try {
      const db = await initAuthDB();
      await db.clear("user-data");
      await db.clear("user-creds");
    } catch (err) {
      console.error("Erro ao limpar IndexedDB:", err);
    }
    window.location.href = "/login";
  };

  const handleTabClick = (name, link, hasSubTabs) => {
    if (hasSubTabs) {
      setOpenDropdown(openDropdown === name ? null : name);
    } else {
      router.push(link);
      setSidebarOpen(false);
    }
  };

  return (
    <>
      {sidebarOpen && (
        <div className="fixed inset-0 z-40 flex md:hidden">
          {/* Overlay */}
          <motion.div
            className="fixed inset-0 bg-gray-600 bg-opacity-75"
            onClick={() => setSidebarOpen(false)}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />

          {/* Sidebar principal */}
          <motion.div
            className="relative flex flex-col max-w-xs w-full bg-white"
            initial="hidden"
            animate="visible"
            exit="hidden"
            variants={sidebarVariants}
            drag="x"
            dragConstraints={{ left: 0, right: 300 }}
            onDragEnd={(event, info) => {
              if (info.point.x < 50) {
                setSidebarOpen(false);
              }
            }}
          >
            {/* Botão de fechar */}
            <div className="absolute top-0 right-0 -mr-12 pt-2">
              <button
                type="button"
                className="ml-1 flex items-center justify-center h-10 w-10 rounded-full focus:outline-none focus:bg-gray-600"
                onClick={() => setSidebarOpen(false)}
              >
                <span className="sr-only">Fechar menu</span>
                <svg
                  className="h-6 w-6 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            {/* Logo */}
            <div className="flex items-center h-16 px-4 bg-white border-b">
              <Link href="/" onClick={() => setSidebarOpen(false)}>
                <Image
                  src="/img/placemaking.png"
                  alt="Logo"
                  width={100}
                  height={40}
                  className="object-contain"
                  priority
                />
              </Link>
            </div>

            {/* Tabs */}
            <nav className="flex-1 px-2 py-4 space-y-2 overflow-y-auto">
              {allowedTabs.map(([name, data]) => {
                const hasSubTabs = data.allowedSubTabs;
                const isActive =
                  router.pathname === data.link ||
                  (hasSubTabs &&
                    data.allowedSubTabs.some(
                      ([, subData]) => subData.link === router.pathname
                    ));
                return (
                  <div key={name} className="space-y-1">
                    <button
                      onClick={() =>
                        handleTabClick(name, data.link, hasSubTabs)
                      }
                      className={`flex items-center gap-2 px-4 py-2 rounded w-full transition-all ${
                        isActive ? TABSTYLES.active : TABSTYLES.inactive
                      }`}
                    >
                      <span className="material-symbols-outlined text-base">
                        {data.icon}
                      </span>
                      <span className="text-sm font-medium">{name}</span>
                      {hasSubTabs && (
                        <span className="ml-auto material-symbols-outlined">
                          {openDropdown === name
                            ? "expand_less"
                            : "expand_more"}
                        </span>
                      )}
                    </button>
                    {hasSubTabs && openDropdown === name && (
                      <motion.div
                        initial={{ opacity: 0, height: 0, y: -10 }}
                        animate={{ opacity: 1, height: "auto", y: 0 }}
                        exit={{ opacity: 0, height: 0, y: -10 }}
                        transition={{ duration: 0.3 }}
                        className="ml-4 mt-1 space-y-1 bg-white rounded-md"
                      >
                        {data.allowedSubTabs.map(([subName, subData]) => {
                          const isSubActive = router.pathname === subData.link;
                          return (
                            <Link
                              key={subName}
                              href={subData.link}
                              onClick={() => setSidebarOpen(false)}
                              className={`flex items-center gap-2 px-4 py-2 transition-all rounded-md ${
                                isSubActive
                                  ? "bg-black text-white"
                                  : "bg-white text-gray-700 hover:bg-gray-50"
                              }`}
                            >
                              <span className="material-symbols-outlined text-sm">
                                {subData.icon}
                              </span>
                              <span className="text-sm font-medium">
                                {subName}
                              </span>
                            </Link>
                          );
                        })}
                      </motion.div>
                    )}
                  </div>
                );
              })}
            </nav>

            <div className="border-t px-4 py-3">
              <Button
                onClick={async () => {
                  await handleLogout();
                  setSidebarOpen(false);
                }}
                variant="transparent_vermelho"
                className="w-full flex items-center gap-2"
              >
                <span className="material-symbols-outlined text-base">
                  logout
                </span>
                <span className="text-sm font-medium">Logout</span>
              </Button>
            </div>
          </motion.div>

          {/* Spacer para evitar scroll no fundo */}
          <div className="flex-shrink-0 w-14" aria-hidden="true" />
        </div>
      )}
    </>
  );
}


============================================================


📄 Arquivo : TopBar.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/TopBar.jsx
--------------------------------------
📜 Conteúdo:

// src/components/TopBar.jsx
import { motion } from "framer-motion";
import Link from "next/link";
import { useAuth } from "@/context/AuthContext";
import { useNetworkStatus } from "@/lib/network";

export default function TopBar({ setSidebarOpen, pageName }) {
  const { userData } = useAuth();
  const isOnline = useNetworkStatus();
  return (
    <header className="flex items-center justify-between px-4 py-2 bg-white border-b border-gray-100">
      <div className="flex items-center">
        <button
          type="button"
          className="md:hidden p-2 rounded-md text-gray-500 hover:text-gray-900 hover:bg-gray-100 focus:outline-none"
          onClick={() => setSidebarOpen(true)}
        >
          <span className="sr-only">Abrir menu</span>
          <motion.svg
            className="h-6 w-6"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            whileHover={{ scale: 1.1 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 6h16M4 12h16M4 18h16"
            />
          </motion.svg>
        </button>
        <h2 className="text-xl font-semibold ml-2">
          {pageName || "Área Logada"}
        </h2>
        <p
          className={`text-xs flex items-center justify-center gap-2 rounded-md px-3 py-2 ml-2 font-medium transition-all
    ${isOnline ? "bg-emerald-50 text-emerald-700" : "bg-rose-50 text-rose-700"}
  `}
        >
          <span
            className={`w-2 h-2 rounded-full inline-block 
      ${isOnline ? "bg-emerald-500" : "bg-rose-500"}
    `}
          />
          {isOnline ? "Conectado" : "Sem conexão"}
        </p>
      </div>
      <div>
        <Link
          href={`/users/${userData?.id}`}
          className="text-gray-600 hover:text-gray-800"
        >
          <span className="sr-only">Perfil</span>
          <motion.svg
            className="h-8 w-8 rounded-full border border-gray-300"
            fill="currentColor"
            viewBox="0 0 24 24"
            whileHover={{ scale: 1.05 }}
          >
            <path d="M12 12c2.7 0 4-1.3 4-4s-1.3-4-4-4-4 1.3-4 4 1.3 4 4 4zm0 2c-2.7 0-8 1.3-8 4v2h16v-2c0-2.7-5.3-4-8-4z" />
          </motion.svg>
        </Link>
      </div>
    </header>
  );
}


============================================================


📄 Arquivo : LocationMarker.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/LocationMarker.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect } from 'react';
import { Marker, Popup, useMapEvents } from 'react-leaflet';

export default function LocationMarker({ location, setLocation }) {
  const map = useMapEvents({
    click(e) {
      setLocation(e.latlng);
    },
  });

  useEffect(() => {
    if (location) {
      setTimeout(() => {
        map.flyTo([location.lat, location.lng], 16);
      }, 100);
    }
  }, [location, map]);

  return location ? (
    <Marker position={location}>
      <Popup>
        Latitude: {location.lat.toFixed(4)}, Longitude: {location.lng.toFixed(4)}
      </Popup>
    </Marker>
  ) : null;
}


============================================================


📄 Arquivo : MapLeafletComponent.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapLeafletComponent.jsx
--------------------------------------
📜 Conteúdo:

// /components/map/MapLeafletComponent.js
import React, { useState, useRef } from "react";
import {
  MapContainer,
  TileLayer,
  LayersControl,
  ZoomControl,
} from "react-leaflet";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import Button from "@/components/ui/Button";
import SearchControl from "@/components/map/SearchControl";
import LocationMarker from "@/components/map/LocationMarker";

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: "/maps/marker-icon.png",
  iconUrl: "/maps/marker-icon.png",
  shadowUrl: "/maps/marker-shadow.png",
});

const { BaseLayer } = LayersControl;

export default function MapLeafletComponent({
  lat = -23.5505,
  lng = -46.6333,
  zoom = 13,
  onClose,
  onSaveLocation,
}) {
  const [location, setLocation] = useState(null);
  const mapRef = useRef();

  const handleSaveLocation = () => {
    if (location) {
      onSaveLocation?.(location); // Envia a posição exata do pin para o pai
    } else {
      alert("Nenhuma localização selecionada.");
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
      <div className="relative w-full max-w-5xl mx-4 bg-transparent rounded-lg shadow-lg overflow-hidden">
        <SearchControl
          onNavigate={(coords) => {
            setLocation({ lat: coords[0], lng: coords[1] });
          }}
        />

        <div className="w-full h-[70vh] md:h-[80vh] rounded-lg overflow-hidden">
          <MapContainer
            center={[lat, lng]}
            zoom={zoom}
            scrollWheelZoom={true}
            className="w-full h-full"
            zoomControl={false}
            whenCreated={(mapInstance) => {
              mapRef.current = mapInstance;
            }}
          >
            <ZoomControl position="bottomleft" />
            <LayersControl position="bottomright">
              <BaseLayer name="Default">
                <TileLayer
                  attribution='&copy; <a href="https://www.openstreetmap.org/copyright">
                    OpenStreetMap</a> contributors'
                  url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                />
              </BaseLayer>
              <BaseLayer checked name="Carto Voyager">
                <TileLayer
                  attribution='&copy; <a href="https://carto.com/attributions">CARTO</a> &copy; 
                    <a href="https://www.openstreetmap.org/copyright">
                    OpenStreetMap</a> contributors'
                  url="https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
                />
              </BaseLayer>
            </LayersControl>

            <LocationMarker location={location} setLocation={setLocation} />
          </MapContainer>
        </div>

        <div className="bg-transparent p-4 flex justify-center gap-4">
          <Button
            onClick={handleSaveLocation}
            className="px-4 py-2 transition flex justify-evenly items-center gap-2"
            variant="azul_escuro"
          >
            <span className="material-symbols-outlined text-xl">place</span>
            <span>Salvar</span>
          </Button>

          <Button
            onClick={onClose}
            className="px-4 py-2 transition flex justify-evenly items-center gap-2"
            variant="vermelho"
          >
            <span className="material-symbols-outlined text-xl">close</span>
            <span>Fechar</span>
          </Button>
        </div>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : MapLeafletNoSSR.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapLeafletNoSSR.jsx
--------------------------------------
📜 Conteúdo:

// /components/map/MapLeafletNoSSR.tsx

import dynamic from 'next/dynamic';
import React from 'react';

// Faz import dinâmico do seu componente real de mapa
const MapLeafletComponent = dynamic(() => import('@/components/map/MapLeafletComponent'), {
  ssr: false, // Desativa SSR para o Leaflet não quebrar
});

export default function MapLeafletNoSSR(props) {
  return <MapLeafletComponent {...props} />;
}


============================================================


📄 Arquivo : MapPreview.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapPreview.jsx
--------------------------------------
📜 Conteúdo:

// components/map/MapPreview.jsx
import { MapContainer, TileLayer, Marker, Popup } from "react-leaflet";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import React from "react";

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: "/maps/marker-icon.png",
  iconUrl: "/maps/marker-icon.png",
  shadowUrl: "/maps/marker-shadow.png",
});

export default function MapPreview({
  lat,
  lng,
  width = "100%",
  height = "200px",
  zoom = 16,
}) {
  if (!lat || !lng) return null;

  return (
    <div
      style={{ width, height }}
      className="rounded-md overflow-hidden shadow-sm"
    >
      <MapContainer
        center={[lat, lng]}
        zoom={zoom}
        scrollWheelZoom={false}
        dragging={false}
        doubleClickZoom={false}
        zoomControl={false}
        attributionControl={false}
        className="w-full h-full z-0"
      >
        <TileLayer
          attribution='&copy; <a href="https://carto.com/attributions">CARTO</a> &copy; 
                           <a href="https://www.openstreetmap.org/copyright">
                           OpenStreetMap</a> contributors'
          url="https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
        />
        <Marker position={[lat, lng]}>
          <Popup>Localização selecionada</Popup>
        </Marker>
      </MapContainer>
    </div>
  );
}


============================================================


📄 Arquivo : MapPreviewNoSSR.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapPreviewNoSSR.jsx
--------------------------------------
📜 Conteúdo:


import dynamic from "next/dynamic";

const MapPreview = dynamic(() => import("./MapPreview"), {
  ssr: false,
});

export default MapPreview;


============================================================


📄 Arquivo : SearchControl.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/SearchControl.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import { useEffect, useRef, useState } from "react";
import Button from "@/components/ui/Button";

let debounceTimer;

export default function SearchControl({ onNavigate }) {
  const [query, setQuery] = useState("");
  const [loading, setLoading] = useState(false);
  const [expanded, setExpanded] = useState(false);
  const [results, setResults] = useState([]);
  const [hasSearched, setHasSearched] = useState(false);
  const inputRef = useRef(null);

  const fetchResults = async (searchQuery) => {
    if (!searchQuery) {
      setResults([]);
      setHasSearched(false);
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(
          searchQuery
        )}`
      );
      const data = await response.json();
      setResults(data);
    } catch (error) {
      console.error("Erro na busca:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectResult = (place) => {
    setQuery("");
    setResults([]);
    setExpanded(false);
    setHasSearched(false);
    onNavigate([parseFloat(place.lat), parseFloat(place.lon)]);
  };

  // Busca com debounce enquanto digita
  useEffect(() => {
    if (!expanded) return;

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      fetchResults(query);
    }, 500);

    return () => clearTimeout(debounceTimer);
  }, [query]);

  useEffect(() => {
    if (expanded && inputRef.current) {
      setTimeout(() => {
        inputRef.current.focus();
      }, 300);
    }
  }, [expanded]);

  const closeSearch = () => {
    setExpanded(false);
    setQuery("");
    setResults([]);
    setHasSearched(false);
  };

  return (
    <div className="absolute z-[999] top-4 w-full max-w-md px-4">
      <AnimatePresence mode="wait">
        {!expanded ? (
          <motion.div
            key="icon"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.8, opacity: 0 }}
            transition={{ duration: 0.3, ease: "easeInOut" }}
          >
            <Button
              onClick={() => setExpanded(true)}
              className="px-3.5 shadow-md rounded-full bg-white"
              variant="transparent_cinza"
            >
              <span className="material-symbols-outlined text-2xl">search</span>
            </Button>
          </motion.div>
        ) : (
          <motion.div
            key="form"
            initial={{ opacity: 0, y: -10, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -10, scale: 0.95 }}
            transition={{ duration: 0.25, ease: "easeInOut" }}
            className="bg-white shadow-lg rounded-lg overflow-hidden"
          >
            <div className="flex gap-2 p-3 items-center">
              <button
                type="button"
                onClick={closeSearch}
                className="text-gray-600 hover:text-gray-800 transition"
              >
                <span className="material-symbols-outlined text-2xl">
                  arrow_back
                </span>
              </button>
              <input
                ref={inputRef}
                type="text"
                placeholder="Buscar local..."
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none"
              />
              {loading && (
                <span className="material-symbols-outlined animate-spin text-gray-500">
                  refresh
                </span>
              )}
            </div>

            <AnimatePresence>
              {(results.length > 0 || hasSearched) && (
                <motion.div
                  initial={{ opacity: 0, y: -6 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -6 }}
                  transition={{ duration: 0.2 }}
                >
                  {results.length > 0 ? (
                    <>
                      <p className="text-xs text-gray-500 px-4 pt-2 pb-1">
                        Resultados para busca:{" "}
                        <span className="font-medium italic">"{query}"</span>
                      </p>
                      <ul className="max-h-64 overflow-y-auto border-t border-gray-200">
                        {results.map((place, index) => (
                          <li
                            key={`${place.place_id}-${index}`}
                            onClick={() => handleSelectResult(place)}
                            className="px-4 py-3 text-sm text-gray-800 cursor-pointer hover:bg-blue-50 hover:text-blue-700 transition-all border-b border-gray-100"
                          >
                            {place.display_name}
                          </li>
                        ))}
                      </ul>
                    </>
                  ) : (
                    <div className="flex flex-col items-center justify-center py-6 px-4 text-gray-400 text-sm">
                      <span className="material-symbols-outlined text-5xl mb-2">
                        search_off
                      </span>
                      Nenhum resultado encontrado para "{query}"
                    </div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : Contributors.jsx
📂 Pasta   : components/research
🧭 Caminho : components/research/Contributors.jsx
--------------------------------------
📜 Conteúdo:

"use client";

import { useResearchContributors } from "@/hooks/useResearchContributors";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import UserCardCompact from "@/components/ui/UserCardCompact";
import Switch from "@/components/ui/Switch";
import { useState, useMemo } from "react";

export default function Contributors({ researchId, allUsers = [] }) {
  const {
    contributors,
    addResearchContributor,
    removeResearchContributor,
    loading: loadingContributors,
  } = useResearchContributors(researchId);

  const [showCollaborators, setShowCollaborators] = useState(false);

  const selected = useMemo(() => {
    return contributors.map((c) => ({
      value: c.user_id,
      label: allUsers.find((u) => u.value === c.user_id)?.label || "Usuário",
    }));
  }, [contributors, allUsers]);

  const handleSelectChange = async (newSelected) => {
    const newIds = new Set(newSelected.map((u) => u.value));
    const currentIds = new Set(contributors.map((c) => c.user_id));

    const toAdd = [...newIds].filter((id) => !currentIds.has(id));
    const toRemove = [...currentIds].filter((id) => !newIds.has(id));

    await Promise.all([
      ...toAdd.map((userId) =>
        addResearchContributor({
          id: "",
          research_id: researchId,
          user_id: userId,
          instruction: "Pesquisador",
        })
      ),
      ...toRemove.map((userId) => {
        const contributor = contributors.find((c) => c.user_id === userId);
        if (contributor) {
          return removeResearchContributor({
            research_id: contributor.research_id,
            user_id: contributor.user_id,
            contributor_id: contributor.id,
          });
        }
      }),
    ]);
  };

  const handleRemove = async (userId) => {
    const contributor = contributors.find((c) => c.user_id === userId);
    console.log("contributor", contributor);
    if (contributor) {
      await removeResearchContributor({
        research_id: contributor.research_id,
        user_id: contributor.user_id,
        contributor_id: contributor.id,
      });
    }
  };

  return (
    <div className="space-y-6">
      <div className="flex justify-between items-center">
        <h2 className="text-lg font-semibold text-gray-800">Colaboradores</h2>
        <Switch
          type="arrow"
          checked={showCollaborators}
          onChange={setShowCollaborators}
        />
      </div>

      {showCollaborators && (
        <>
          <MultiSelect
            options={allUsers}
            value={selected}
            onChange={handleSelectChange}
            placeholder="Selecione colaboradores"
            isLoading={loadingContributors}
          />
          <p className="text-xs text-gray-500">
            Você pode escolher múltiplos colaboradores para participar.
          </p>

          <div className="mt-6 border-t pt-4 space-y-2">
            <h3 className="text-sm font-semibold text-gray-700 mb-2">
              Colaboradores Atuais
            </h3>
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-[14rem] overflow-y-auto">
              {contributors.map((contributor) => {
                const user = allUsers.find(
                  (u) => u.value === contributor.user_id
                );
                return (
                  <UserCardCompact
                    key={`${contributor.research_id}-${contributor.user_id}`}
                    user={{
                      id: user?.value || "",
                      name: user?.label || "Usuário",
                      email: user?.email || "",
                      role: user?.role || "",
                      status: user?.status || "",
                    }}
                    showRemoveButton={true}
                    borderColor="border-blue-500"
                    onRemove={() => handleRemove(contributor.user_id)}
                  />
                );
              })}
            </div>
          </div>
        </>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : ResearchForm.jsx
📂 Pasta   : components/research
🧭 Caminho : components/research/ResearchForm.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { motion } from "framer-motion";
import dynamic from "next/dynamic";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";
import MapPreview from "@/components/map/MapPreviewNoSSR";
import Switch from "@/components/ui/Switch";
import Contributors from "@/components/research/Contributors"; 
import { useRouter } from "next/router";

const OfflineMapButton = dynamic(
  () => import("@/components/OfflineMapButton"),
  { ssr: false }
);

export default function ResearchForm({
  initialData = {},
  onSubmit,
  isEdit = false,
  users = [],
}) {
  const [form, setForm] = useState({
    id: "",
    title: "",
    description: "",
    release_date: "",
    end_date: "",
    lat: "",
    long: "",
    location_title: "",
    status: undefined,
    created_by: "",
    ...initialData,
  });

  const [showBasicInfo, setShowBasicInfo] = useState(false);
  const [showDates, setShowDates] = useState(false);
  const [showLocation, setShowLocation] = useState(false);
  const [imageUrl, setImageUrl] = useState("");
  const router = useRouter();

  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleLocationSelect = (data) => {
    setForm((prev) => ({
      ...prev,
      lat: data.lat,
      long: data.lng,
      location_title: data.location || ""
    }));
  };

  const handleChangeStatus = () => {
    const action = form.status ? "desativar" : "ativar";
    if (window.confirm(`Tem certeza que deseja ${action} a pesquisa?`)) {
      const newStatus = !form.status;
      setForm((prev) => ({
        ...prev,
        status: newStatus,
      }));
      const payload = { ...form, status: newStatus };
      onSubmit?.(payload);
      router.push(`/researches`);
    }
  };

  const handleSubmit = () => {
    if (window.confirm("Tem certeza que deseja salvar as alterações?")) {
      const payload = { ...form };
      onSubmit?.(payload);
    }
  };

  useEffect(() => {
    const idx = Math.floor(Math.random() * 5);
    setImageUrl(`/img/cards/img-${idx}.jpg`);
  }, []);

  return (
    <div className="max-w-4xl mx-auto mt-6 bg-white rounded-2xl shadow-md">
      <motion.div
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="rounded-t-lg"
        style={{
          backgroundImage: `url('${imageUrl}')`,
          backgroundSize: "cover",
          backgroundPosition: "center",
        }}
      >
        <div className="bg-black/50 px-6 py-8 sm:px-8 sm:py-10 rounded-t-lg">
          <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
            <div>
              <h1 className="text-2xl font-bold text-white drop-shadow">
                {isEdit ? "Editar Pesquisa" : "Criar Pesquisa"}
              </h1>
              <p className="text-sm text-gray-200 mt-1">
                {isEdit
                  ? "Atualize os campos abaixo para editar a pesquisa."
                  : "Preencha os campos abaixo para iniciar uma nova pesquisa."}
              </p>
            </div>

            {isEdit && (
              <Button
                variant={form.status ? "warning" : "verde"}
                onClick={handleChangeStatus}
                className="active:scale-95 mt-2 sm:mt-0"
              >
                {form.status ? "Desativar Pesquisa" : "Ativar Pesquisa"}
              </Button>
            )}
          </div>
        </div>
      </motion.div>

      <div className="p-6 space-y-6">
        <SectionToggle title="Informações Básicas" isChecked={showBasicInfo} onChange={setShowBasicInfo} />
        {showBasicInfo && (
          <div className="space-y-4">
            <FormField legend="Título" type="text" value={form.title} onChange={handleChange("title")} />
            <FormField legend="Descrição" type="textarea" value={form.description} onChange={handleChange("description")} />
          </div>
        )}

        <hr className="my-6 border-gray-200" />

        <SectionToggle title="Período da Pesquisa" isChecked={showDates} onChange={setShowDates} />
        {showDates && (
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <FormField legend="Data de Início" type="date" value={form.release_date || ""} onChange={handleChange("release_date")} />
            <FormField legend="Data de Fim" type="date" value={form.end_date || ""} onChange={handleChange("end_date")} />
          </div>
        )}

        <hr className="my-6 border-gray-200" />

        <SectionToggle title="Localização" isChecked={showLocation} onChange={setShowLocation} />
        {showLocation && (
          <>
            <div className="p-4 rounded-lg space-y-4 bg-gray-50 border">
              <p className="text-sm text-gray-600">Defina manualmente ou pelo mapa interativo.</p>
              <div className="grid grid-cols-2 gap-4">
                <FormField legend="Latitude" type="text" value={form.lat} onChange={handleChange("lat")} disabled />
                <FormField legend="Longitude" type="text" value={form.long} onChange={handleChange("long")} disabled />
              </div>
              <FormField legend="Localização (Título)" type="text" value={form.location_title} onChange={handleChange("location_title")} />
              <div className="flex flex-col items-center border-t pt-4 gap-2">
                <OfflineMapButton onLocationSelect={handleLocationSelect} />
                <p className="text-xs text-gray-500 text-center">
                  Para obter a localização automaticamente, clique em{" "}
                  <strong>“Abrir mapa”</strong>.
                </p>
              </div>
              <div className="flex justify-center">
                <MapPreview
                  key={`${form.lat}-${form.long}`}
                  lat={form.lat}
                  lng={form.long}
                  className="w-full h-48 sm:h-64 rounded-lg shadow-md"
                />
                </div>  
            </div>
          </>
        )}

        {isEdit && (
          <>
            <hr className="my-6 border-gray-200" />
            <Contributors researchId={form.id} allUsers={users} />
          </>
        )}
        <div className="flex justify-center pt-4 gap-6">
          <Button type="submit" variant="dark" className="text-lg py-3 active:scale-95" onClick={handleSubmit}>
            {isEdit ? "Salvar Alterações" : "Criar Pesquisa"}
          </Button>
        </div>
      </div>
    </div>
  );
}

function SectionToggle({ title, isChecked, onChange }) {
  return (
    <div className="flex justify-between items-center">
      <h2 className="text-lg font-semibold text-gray-800">{title}</h2>
      <Switch type="arrow" checked={isChecked} onChange={onChange} />
    </div>
  );
}


============================================================


📄 Arquivo : ResearchLoadingSkeleton.jsx
📂 Pasta   : components/research
🧭 Caminho : components/research/ResearchLoadingSkeleton.jsx
--------------------------------------
📜 Conteúdo:

export default function ResearchLoadingSkeleton() {
  return (
    <div className="max-w-4xl mx-auto mt-6 bg-white rounded-lg shadow-md overflow-hidden animate-pulse">
      {/* Cabeçalho (imagem / título) */}
      <div className="rounded-t-lg bg-gray-200 h-28" />

      {/* Conteúdo */}
      <div className="p-6 space-y-8">
        {/* Seção: Informações Básicas */}
        <div className="space-y-2">
          {/* Título da Seção e Switch */}
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/3" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          {/* Campos */}
          <div className="space-y-3">
            <div className="h-4 bg-gray-200 rounded w-2/3" />
            <div className="h-4 bg-gray-200 rounded w-1/2" />
          </div>
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Datas */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
            <div className="h-4 bg-gray-200 rounded w-full" />
            <div className="h-4 bg-gray-200 rounded w-full" />
          </div>
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Localização */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="space-y-3 mt-2">
            <div className="h-4 bg-gray-200 rounded w-1/2" />
            <div className="h-4 bg-gray-200 rounded w-3/4" />
          </div>
          <div className="h-4 bg-gray-200 rounded w-1/3" />
          <div className="h-4 bg-gray-200 rounded w-2/3" />
          {/* Mapa preview placeholder */}
          <div className="w-full h-32 bg-gray-200 rounded" />
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Colaboradores */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="space-y-2 mt-2">
            {/* Linha do MultiSelect */}
            <div className="h-4 bg-gray-200 rounded w-2/3" />
            {/* Cards placeholder */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              <div className="h-16 bg-gray-200 rounded" />
              <div className="h-16 bg-gray-200 rounded" />
              <div className="h-16 bg-gray-200 rounded" />
            </div>
          </div>
        </div>

        {/* Botões de ação final */}
        <div className="flex justify-center gap-6 pt-4">
          <div className="h-10 bg-gray-200 rounded w-1/3" />
          <div className="h-10 bg-gray-200 rounded w-1/3" />
        </div>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : AddSurveyPrompt.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/AddSurveyPrompt.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Button from "@/components/ui/Button";
import DropdownSelect from "@/components/ui/Multiselect/DropdownSelect";
import Switch from "@/components/ui/Switch"; 
import { set } from "zod";

export default function AddSurveyPrompt({ onContinue }) {
  const surveyOptions = [
    { value: "estatica", label: "Coleta Estática" },
    { value: "dinamica", label: "Coleta Dinâmica" },
    { value: "formulario", label: "Coleta de Entrevistas" },
  ];

  const [showSelect, setShowSelect] = useState(false);
  const [selectedSurvey, setSelectedSurvey] = useState(null);

  const handleSubmit = () => {
    if (!selectedSurvey) return;
    setShowSelect(false);
    setSelectedSurvey(null);
    onContinue(selectedSurvey);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 40 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="max-w-4xl mx-auto bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 p-6 sm:p-8 rounded-2xl space-y-8 shadow-md"
    >
      <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
        <h3 className="text-xl sm:text-2xl font-bold text-zinc-800 dark:text-zinc-100 text-center sm:text-left">
          Deseja adicionar uma coleta para esta pesquisa?
        </h3>

        <Switch checked={showSelect} onChange={setShowSelect} />
      </div>

      <AnimatePresence>
        {showSelect && (
          <motion.div
            key="select-area"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            transition={{ duration: 0.3 }}
            className="flex flex-col md:flex-row md:items-end gap-4 justify-center"
          >
            <div className="w-full md:w-2/3">
              <DropdownSelect
                label="Tipo de Coleta"
                options={surveyOptions}
                selected={selectedSurvey}
                onChange={setSelectedSurvey}
                placeholder="Selecione o tipo"
              />
            </div>

            <div className="w-full md:w-auto">
              <Button
                className="w-full md:w-fit px-6 py-2"
                variant="dark"
                onClick={handleSubmit}
                disabled={!selectedSurvey}
              >
                Continuar
              </Button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}


============================================================


📄 Arquivo : BasicInformation.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/BasicInformation.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import FormField from "@/components/forms/FormField";
import Switch from "@/components/ui/Switch";
import { Info } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";



export default function BasicInformation({
  form,
  setForm,
  showSurveyInformation,
  setShowSurveyInformation,
}) {
  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  return (
    <div className="rounded-lg space-y-4">
      <div className="flex items-center justify-between px-4 py-3 bg-transparent">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Informações da Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <Info
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Adicione um título e descrição para identificar esta coleta.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Informações como título e descrição para identificar essa coleta.
          </p>
        </div>
        <Switch
          checked={showSurveyInformation}
          onChange={setShowSurveyInformation}
          type="arrow"
        />
      </div>

      {showSurveyInformation && (
        <div className="bg-transparent px-4 py-5 mt-2 space-y-5">
          <div className="flex flex-col gap-4">
            <FormField
              legend="Título do Formulário"
              type="text"
              value={form.title}
              onChange={handleChange("title")}
              placeholder="Ex: Coleta de Entrevistas - Praça Roosevelt"
            />
            <FormField
              legend="Descrição"
              type="textarea"
              value={form.description}
              onChange={handleChange("description")}
              placeholder="Breve descrição sobre o objetivo da coleta..."
            />
          </div>

          <p className="text-xs text-gray-500 text-right">
            * Essas informações serão exibidas aos pesquisadores durante a coleta.
          </p>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : CollaboratorSelector.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollaboratorSelector.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useMemo } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import UserCardCompact from "@/components/ui/UserCardCompact";
import { HelpCircle } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";
import { useSurveyContributors } from "@/hooks/useSurveyContributors";

export default function CollaboratorSelector({
  availableCollaborators = [],
  survey_id,
  survey_type,
}) {
  if (!Array.isArray(availableCollaborators) || !survey_id || !survey_type) return null;

  const {
    contributors,
    addSurveyContributor,
    removeSurveyContributor,
    loading,
  } = useSurveyContributors(survey_id);

  // Inicializa como true apenas se não houver colaboradores
  const [useAllFromResearch, setUseAllFromResearch] = useState(() => contributors.length === 0);
  const [processingIds, setProcessingIds] = useState(new Set());

  // Atualiza o estado inicial do switch se surgirem colaboradores
  useEffect(() => {
    if (contributors.length > 0 && useAllFromResearch) {
      setUseAllFromResearch(false);
    }
  }, [contributors]);

  const selectedCollaborators = useMemo(() => {
    return contributors.map((c) => {
      const user = availableCollaborators.find((u) => u.value === c.user_id);
      return {
        value: c.user_id,
        label: user?.label || c.user_id,
        email: user?.email || "—",
        role: user?.role || "—",
        status: user?.status || "—",
      };
    });
  }, [contributors, availableCollaborators]);

  const handleToggleAll = async (checked) => {
    if (checked && contributors.length > 0) {
      const idsToRemove = contributors.map((c) => c.user_id);
      setProcessingIds(new Set(idsToRemove));
      await Promise.all(
        idsToRemove.map((id) =>
          removeSurveyContributor({ survey_id, contributor_id: id })
        )
      );
      setProcessingIds(new Set());
    }
    setUseAllFromResearch(checked);
  };

  const handleSelectChange = async (newSelected) => {
    const newIds = new Set(newSelected.map((c) => c.value));
    const currentIds = new Set(contributors.map((c) => c.user_id));

    const toAdd = [...newIds].filter((id) => !currentIds.has(id));
    const toRemove = [...currentIds].filter((id) => !newIds.has(id));

    setProcessingIds(new Set([...toAdd, ...toRemove]));

    await Promise.all([
      ...toAdd.map((userId) =>
        addSurveyContributor({
          user_id: userId,
          survey_id,
          survey_type,
          instruction: "Pesquisador",
        })
      ),
      ...toRemove.map((userId) =>
        removeSurveyContributor({ survey_id, contributor_id: userId })
      ),
    ]);

    setProcessingIds(new Set());
  };

  const handleRemove = async (userId) => {
    if (processingIds.has(userId)) return;
    setProcessingIds((prev) => new Set(prev).add(userId));
    await removeSurveyContributor({ survey_id, contributor_id: userId });
    setProcessingIds((prev) => {
      const newSet = new Set(prev);
      newSet.delete(userId);
      return newSet;
    });
  };

  return (
    <div className="rounded-lg space-y-4">
      <div className="flex items-center justify-between px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Colaboradores da Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <HelpCircle
                      className="text-gray-400 hover:text-gray-600 transition"
                      size={16}
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Defina manualmente os colaboradores ou use todos os que já
                    fazem parte da pesquisa.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Escolha entre todos da pesquisa ou selecione manualmente.
          </p>
        </div>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-700 whitespace-nowrap">Todos da Pesquisa</span>
          <Switch
            checked={useAllFromResearch}
            onChange={handleToggleAll}
            type="checkbox"
            disabled={processingIds.size > 0}
          />
        </div>
      </div>

      <AnimatePresence>
        {!useAllFromResearch && (
          <motion.div
            key="manual-selection"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.2 }}
            className="space-y-6 px-4 py-5"
          >
            <MultiSelect
              options={availableCollaborators}
              value={selectedCollaborators}
              onChange={handleSelectChange}
              placeholder="Selecione colaboradores"
              closeMenuOnSelect
            />

            {loading && (
              <p className="text-sm text-gray-500">Carregando colaboradores...</p>
            )}

            {selectedCollaborators.length > 0 && (
              <div className="mt-6 border-t pt-4 space-y-2">
                <h3 className="text-sm font-semibold text-gray-700 mb-2">
                  Colaboradores Selecionados
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-[14rem] overflow-y-auto">
                  {selectedCollaborators.map((user) => (
                    <UserCardCompact
                      key={`${survey_id}-${user.value}`}
                      user={{
                        id: user.value,
                        name: user.label,
                        email: user.email,
                        role: user.role,
                        status: user.status,
                      }}
                      showRemoveButton
                      borderColor="border-blue-500"
                      onRemove={() => handleRemove(user.value)}
                      disabled={processingIds.has(user.value)}
                    />
                  ))}
                </div>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}

============================================================


📄 Arquivo : CollectionDynamicSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollectionDynamicSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";
import Switch from "@/components/ui/Switch";

/**
 * DynamicCollectionSection
 * Componente reutilizável para criar ou editar uma coleta dinâmica.
 * Props:
 * - initialData: dados iniciais da coleta (em edição)
 * - onSubmit: função chamada ao salvar
 * - isEdit: booleano, se é modo de edição
 */
export default function CollectionDynamicSection({
  initialData = {},
  onSubmit,
  isEdit = false,
}) {
  const [enabled, setEnabled] = useState(false);
  const [form, setForm] = useState({
    title: "",
    description: "",
    logic_enabled: false,
    conditions: "",
    ...initialData,
  });

  const initialDataRef = useRef(JSON.stringify(initialData));

  useEffect(() => {
    if (!isEdit) return;

    const newInitial = JSON.stringify(initialData);

    // Só atualiza se o conteúdo for diferente
    if (initialDataRef.current !== newInitial) {
      initialDataRef.current = newInitial;
      setForm((prev) => ({ ...prev, ...initialData }));
    }
  }, [initialData, isEdit]);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({
      ...prev,
      [field]: e.target.value,
    }));
  };

  const handleSubmit = () => {
    const payload = {
      ...form,
      type: "dynamic",
    };
    onSubmit?.(payload);
  };

  const handleDiscard = () => {
    setForm({ ...initialData });
  };

  return (
    <div className="border rounded-xl p-6 bg-white shadow max-w-4xl mx-auto w-full space-y-6">
      {/* Header com toggle */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 className="text-lg font-semibold text-gray-800">
          {isEdit ? "Editar Coleta Dinâmica" : "Nova Coleta Dinâmica"}
        </h2>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-600">Ativar coleta</span>
          <Switch checked={enabled} onChange={setEnabled} />
        </div>
      </div>

      {enabled && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              legend="Título da Coleta"
              type="text"
              value={form.title}
              onChange={handleChange("title")}
              placeholder="Ex: Preferências de transporte"
            />

            <FormField
              legend="Descrição"
              type="text"
              value={form.description}
              onChange={handleChange("description")}
              placeholder="Explique o objetivo da coleta dinâmica"
            />
          </div>

          <div className="flex items-center justify-between border-t pt-4">
            <span className="text-sm font-medium text-gray-700">
              Habilitar lógica condicional
            </span>
            <Switch
              checked={form.logic_enabled}
              onChange={(checked) =>
                setForm((prev) => ({ ...prev, logic_enabled: checked }))
              }
            />
          </div>

          {form.logic_enabled && (
            <FormField
              legend="Condições Lógicas"
              type="text"
              value={form.conditions}
              onChange={handleChange("conditions")}
              placeholder="Ex: mostrar campo X se idade > 18"
            />
          )}

          <div className="flex justify-end gap-4 pt-6">
            {isEdit && (
              <Button
                variant="transparent_vermelho"
                onClick={handleDiscard}
                className="active:scale-95"
              >
                Descartar Alterações
              </Button>
            )}
            <Button
              variant="secondary"
              onClick={handleSubmit}
              className="active:scale-95"
            >
              {isEdit ? "Salvar Coleta" : "Criar Coleta"}
            </Button>
          </div>
        </>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : CollectionFormSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollectionFormSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { motion, AnimatePresence } from "framer-motion";
import { ClipboardList } from "lucide-react";

import Switch from "@/components/ui/Switch";
import Button from "@/components/ui/Button";
import FormBuilder from "@/components/forms/FormBuilder";
import MicroRegionEditor from "@/components/surveys/MicroRegionEditor";
import LocationForm from "@/components/surveys/LocationForm";
import BasicInformation from "@/components/surveys/BasicInformation";
import CollaboratorSelector from "@/components/surveys/CollaboratorSelector";
import TimeRanges from "@/components/surveys/TimeRanges";
import SurveyCollectionSkeleton from "@/components/surveys/SurveyCollectionSkeleton"; // <-- importado

import { useFormSurveys } from "@/hooks";
import { formatDataByModel } from "@/lib/types/models";

export default function CollectionFormSection({
  survey_type = "Formulário",
  research_id,
  handleCancelCreateSurvey,
  users,
}) {
  if (!survey_type || !research_id || !users) {
    return <SurveyCollectionSkeleton />;
  }

  const [showAdditionalInfo, setShowAdditionalInfo] = useState(false);
  const [form, setForm] = useState({
    id: "",
    title: "",
    description: "",
    lat: "",
    long: "",
    location_title: "",
    research_id,
    survey_type,
  });
  const [isEdit, setIsEdit] = useState(false);
  const [showLocationForm, setShowLocationForm] = useState(false);
  const [showSurveyInformation, setShowSurveyInformation] = useState(false);
  const [showInitialInfo, setShowInitialInfo] = useState(true);
  const [showCollaborators, setShowCollaborators] = useState(false);
  const [showFormBuilder, setShowFormBuilder] = useState(false);
  const router = useRouter();
  const { formSurvey, addFormSurvey, updateFormSurvey, deleteFormSurvey } =
    useFormSurveys(research_id, true, "Formulário");

  useEffect(() => {
    if (formSurvey) {
      setForm((prev) => ({ ...prev, ...formSurvey }));
      setIsEdit(true);
      setShowInitialInfo(false);
    } 
  }, [formSurvey]);

  const handleCreate = async () => {
    const formattedForm = formatDataByModel(form, "form_surveys");
    await addFormSurvey(formattedForm);
    router.reload();
  };

  const handleUpdate = async () => {
    if (form.id) {
      const formattedForm = formatDataByModel(form, "form_surveys");
      await updateFormSurvey(form.id, { ...formattedForm });
      router.reload();
    }
  };

  const handleDelete = async () => {
    if (form.id) {
      const formattedForm = formatDataByModel(form, "form_surveys");
      await deleteFormSurvey(formattedForm);
      handleCancel();
    }
  };

  const handleCancel = () => {
    handleCancelCreateSurvey();
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 6 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="bg-gray-50 border border-gray-200 rounded-2xl shadow-md p-6 sm:p-8 max-w-4xl mx-auto w-full space-y-6"
    >
      <div className="flex items-center justify-between flex-wrap gap-4">
        <div className="flex items-center gap-2 text-gray-800">
          <ClipboardList size={20} className="text-green-500" />
          <h2 className="text-xl font-bold">
            {isEdit ? `Entrevista: ${form.title}` : "Nova - Entrevista"}
          </h2>
        </div>
      </div>

      <div className="text-sm text-gray-500 space-y-1">
        <p>
          <strong>ID da Pesquisa:</strong> {research_id || "—"}
        </p>
        <p>
          <strong>Tipo de Coleta:</strong> {survey_type || "—"}
        </p>
      </div>

      <AnimatePresence>
        <motion.div
          key="form-content"
          initial={{ opacity: 0, y: 6 }}
          animate={{ opacity: 1, y: 0 }}
          exit={{ opacity: 0, y: -6 }}
          transition={{ duration: 0.25 }}
          className="space-y-6"
        >
          <div className="space-y-4">
            <div className="flex justify-between items-center my-4">
              <h3 className="text-lg font-semibold text-gray-700">
                Informações Iniciais
              </h3>
              <Switch checked={showInitialInfo} onChange={setShowInitialInfo} />
            </div>

            <AnimatePresence>
              {showInitialInfo && (
                <motion.div
                  key="initial-info"
                  initial={{ opacity: 0, y: 6 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -6 }}
                  transition={{ duration: 0.25 }}
                  className="flex flex-col gap-4"
                >
                  <BasicInformation
                    form={form}
                    setForm={setForm}
                    showSurveyInformation={showSurveyInformation}
                    setShowSurveyInformation={setShowSurveyInformation}
                  />
                  <LocationForm
                    form={form}
                    setForm={setForm}
                    showLocationForm={showLocationForm}
                    setShowLocationForm={setShowLocationForm}
                  />
                  <div className="flex justify-center gap-4 pt-6">
                    <Button
                      variant="verde"
                      onClick={isEdit ? handleUpdate : handleCreate}
                      className="transition-all"
                    >
                      {isEdit ? "Salvar Alterações" : "Criar Coleta"}
                    </Button>
                    <Button
                      variant="vermelho"
                      onClick={isEdit ? handleDelete : handleCancel}
                      className="transition-all"
                    >
                      {isEdit ? "Excluir" : "Cancelar"}
                    </Button>
                  </div>
                </motion.div>
              )}
            </AnimatePresence>
          </div>

          {isEdit && (
            <div className="flex justify-between items-center my-4">
              <h3 className="text-lg font-semibold text-gray-700">
                Informações Complementares
              </h3>
              <Switch
                checked={showAdditionalInfo}
                onChange={setShowAdditionalInfo}
              />
            </div>
          )}

          <AnimatePresence>
            {showAdditionalInfo && form.id && (
              <motion.div
                initial={{ opacity: 0, y: 6 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: -6 }}
                transition={{ duration: 0.3 }}
                className="space-y-6"
              >
                <MicroRegionEditor
                  location={{
                    location_title: form.location_title,
                    lat: form.lat,
                    long: form.long,
                  }}
                  survey_id={form.id}
                  survey_type={form.survey_type}
                />
                <TimeRanges
                  survey_id={form.id}
                  survey_type={form.survey_type}
                />
              </motion.div>
            )}
          </AnimatePresence>

          {isEdit && (
            <>
              <div className="flex justify-between items-center my-4">
                <h3 className="text-lg font-semibold text-gray-700">
                  Colaboradores
                </h3>
                <Switch
                  checked={showCollaborators}
                  onChange={setShowCollaborators}
                />
              </div>
              <AnimatePresence>
                {showCollaborators && (
                  <motion.div
                    initial={{ opacity: 0, y: 6 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -6 }}
                    transition={{ duration: 0.3 }}
                  >
                    <CollaboratorSelector
                      availableCollaborators={users || []}
                      survey_id={form.id}
                      survey_type={form.survey_type}
                    />
                  </motion.div>
                )}
              </AnimatePresence>

              <div className="flex justify-between items-center my-4">
                <h3 className="text-lg font-semibold text-gray-700">
                  Formulário de perguntas
                </h3>
                <Switch
                  checked={showFormBuilder}
                  onChange={setShowFormBuilder}
                />
              </div>
              <AnimatePresence>
                {showFormBuilder && (
                  <motion.div
                    initial={{ opacity: 0, y: 6 }}
                    animate={{ opacity: 1, y: 0 }}
                    exit={{ opacity: 0, y: -6 }}
                    transition={{ duration: 0.3 }}
                  >
                    <FormBuilder
                      survey_id={form.id}
                      survey_type={form.survey_type}
                    />
                  </motion.div>
                )}
              </AnimatePresence>
            </>
          )}
        </motion.div>
      </AnimatePresence>
    </motion.div>
  );
}


============================================================


📄 Arquivo : CollectionStaticSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollectionStaticSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import Switch from "@/components/ui/Switch";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";

/**
 * StaticCollectionSection
 * Usado para criação ou edição de coleta via arquivos estáticos (PDFs, Imagens etc).
 *
 * Props:
 *  - initialData: dados iniciais da coleta (se for edição)
 *  - onSubmit: função chamada ao enviar
 *  - isEdit: booleano para distinguir entre criação e edição
 */
export default function CollectionStaticSection({
  initialData = {},
  onSubmit,
  isEdit = false,
}) {
  const [enabled, setEnabled] = useState(false);
  const [form, setForm] = useState({
    title: "",
    description: "",
    fileUrl: "",
    ...initialData,
  });

  const initialDataRef = useRef(JSON.stringify(initialData));

  useEffect(() => {
    if (!isEdit) return;

    const newInitial = JSON.stringify(initialData);

    if (initialDataRef.current !== newInitial) {
      initialDataRef.current = newInitial;
      setForm((prev) => ({ ...prev, ...initialData }));
    }
  }, [initialData, isEdit]);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleSubmit = () => {
    const payload = {
      title: form.title,
      description: form.description,
      fileUrl: form.fileUrl,
      type: "static",
    };
    onSubmit?.(payload);
  };

  return (
    <div className="border rounded-xl p-6 bg-white shadow max-w-4xl mx-auto w-full space-y-6">
      {/* Header com toggle */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 className="text-lg font-semibold text-gray-800">
          {isEdit ? "Editar Coleta Estática" : "Nova Coleta Estática"}
        </h2>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-600">Ativar coleta</span>
          <Switch checked={enabled} onChange={setEnabled} />
        </div>
      </div>

      {enabled && (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            legend="Título do Arquivo"
            type="text"
            value={form.title}
            onChange={handleChange("title")}
          />

          <FormField
            legend="Descrição"
            type="text"
            value={form.description}
            onChange={handleChange("description")}
          />

          <FormField
            className="md:col-span-2"
            legend="Link para Download ou Visualização"
            type="text"
            value={form.fileUrl}
            onChange={handleChange("fileUrl")}
            placeholder="https://..."
          />
        </div>
      )}

      {enabled && (
        <div className="pt-4 flex justify-end">
          <Button variant="secondary" onClick={handleSubmit}>
            {isEdit ? "Salvar Alterações" : "Adicionar Coleta Estática"}
          </Button>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : LocationForm.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/LocationForm.jsx
--------------------------------------
📜 Conteúdo:

"use client";

import { useState } from "react";
import dynamic from "next/dynamic";
import { MapPin } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";
import FormField from "@/components/forms/FormField";
import Switch from "@/components/ui/Switch";
import MapPreview from "@/components/map/MapPreviewNoSSR";

const OfflineMapButton = dynamic(
  () => import("@/components/OfflineMapButton"),
  { ssr: false }
);

export default function LocationForm({
  form,
  setForm,
  showLocationForm,
  setShowLocationForm,
}) {
  const [showFormInputLocation, setShowFormInputLocation] = useState(false);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleLocationSelect = (data) => {
    setForm((prev) => ({
      ...prev,
      lat: data.lat,
      long: data.lng,
      location_title: data.location || "",
      weather_celsius: data.weather_celsius ?? null,
      weather_fahrenheit: data.weather_fahrenheit ?? null,
    }));
    setShowFormInputLocation(true);
  };

  return (
    <div className="rounded-lg space-y-4">
      {/* Header com tooltip */}
      <div className="flex items-center justify-between bg-transparent transition-all px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Informações de Localização
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <MapPin
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Use o mapa para capturar a latitude, longitude e o clima da localização.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Defina a posição geográfica exata e visualize o local no mapa.
          </p>
        </div>
        <Switch
          type="arrow"
          checked={showLocationForm}
          onChange={setShowLocationForm}
        />
      </div>

      {showLocationForm && (
        <div className="bg-transparent px-4 py-5 mt-2 space-y-5">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <FormField
              legend="Latitude"
              type="text"
              value={form.lat}
              onChange={handleChange("lat")}
              disabled
            />
            <FormField
              legend="Longitude"
              type="text"
              value={form.long}
              onChange={handleChange("long")}
              disabled
            />
          </div>

          <FormField
            legend="Localização (Título)"
            type="text"
            value={form.location_title}
            onChange={handleChange("location_title")}
            placeholder="Ex: Praça Roosevelt, SP"
          />

          {!!form.lat && !!form.long && (
            <div className="border rounded-md p-4 bg-gray-50 space-y-4">
              <div className="text-sm text-gray-700">
                <strong className="block mb-1">Resumo da Localização:</strong>
                <p>{form.location_title}</p>
                <p>Lat: {Number(form.lat).toFixed(6)}</p>
                <p>Long: {Number(form.long).toFixed(6)}</p>
                {form.weather_celsius && form.weather_fahrenheit && (
                  <p>
                    Clima: {form.weather_celsius}°C /{" "}
                    {Number(form.weather_fahrenheit).toFixed(1)}°F
                  </p>
                )}
              </div>
              <MapPreview
                lat={Number(form.lat)}
                lng={Number(form.long)}
                height="200px"
                width="100%"
              />
            </div>
          )}

          <div className="flex flex-col items-center pt-2 gap-2">
            <OfflineMapButton onLocationSelect={handleLocationSelect} />
            <p className="text-xs text-gray-500 text-center">
              Para obter a localização automaticamente, clique em{" "}
              <strong>“Abrir mapa”</strong>.
            </p>
          </div>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : MicroRegionEditor.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/MicroRegionEditor.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { Trash2, Plus, MapPin } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import FormField from "@/components/forms/FormField";
import { useSurveyRegions } from "@/hooks/useSurveyRegions";
import * as Tooltip from "@radix-ui/react-tooltip";

export default function MicroRegionEditor({ location, survey_id, survey_type }) {
  const { location_title, lat, long } = location || {};

  const [showMicroRegions, setShowMicroRegions] = useState(false);
  const [newRegion, setNewRegion] = useState("");
  const { surveyRegions, addSurveyRegion, deleteSurveyRegion, loading } = useSurveyRegions(survey_id);

  const handleAdd = async () => {
    if (!newRegion.trim()) return;

    await addSurveyRegion({
      name: newRegion.trim(),
      lat: lat,
      long: long,
      location_title: location_title,
      survey_id: survey_id,
      survey_type: survey_type,
    });

    setNewRegion("");
  };

  const handleDelete = async (id) => {
    await deleteSurveyRegion(id);
  };

  useEffect(() => {
    // console.log("Survey Regions:", surveyRegions);
  }, [surveyRegions]);

  return (
    <div className="rounded-lg space-y-4">
      {/* Cabeçalho com tooltip e switch */}
      <div className="flex items-center justify-between px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Micro-regiões
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <MapPin size={16} className="text-gray-400 hover:text-gray-600 transition" />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content side="top" className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs" sideOffset={6}>
                    Divida a coleta em regiões como “Entrada Leste”, “Praça Central”, etc.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          {location_title && (
           <p className="text-sm text-gray-600">
           Localização:{" "}
           <strong>
             {location_title.length > 20
               ? `${location_title.slice(0, 20)}...`
               : location_title}
           </strong>
         </p>
         
          )}
        </div>
        <Switch checked={showMicroRegions} onChange={setShowMicroRegions} type="arrow" />
      </div>

      <AnimatePresence>
        {showMicroRegions && (
          <motion.div
            key="microregion-toggle"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.25 }}
            className="space-y-5 bg-white border border-gray-100 rounded-lg shadow-sm px-4 py-5"
          >
            <div className="flex justify-auto flex-col sm:flex-row gap-8 sm:items-end">
              <FormField
                legend="Nome da Região"
                type="text"
                value={newRegion}
                onChange={(e) => setNewRegion(e.target.value)}
                placeholder="Ex: Entrada Sul, Ponto 3..."
              />
              <motion.button
                onClick={handleAdd}
                disabled={!newRegion.trim()}
                whileTap={{ scale: 0.95 }}
                className="flex flex-row gap-4 justify-center items-center h-10 px-4 rounded-md bg-green-600 text-white text-sm font-medium shadow hover:bg-green-700 transition disabled:opacity-60 disabled:cursor-not-allowed"
              >
                <Plus size={16} className="inline" />
                Adicionar
              </motion.button>
            </div>

            {loading ? (
              <p className="text-center text-sm text-gray-500 mt-4">Carregando regiões...</p>
            ) : surveyRegions.length > 0 ? (
              <ul className="flex flex-wrap gap-2">
                {surveyRegions.map((region) => (
                  <motion.li
                    key={region.id}
                    initial={{ opacity: 0, scale: 0.95 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.95 }}
                    transition={{ duration: 0.2 }}
                    className="flex items-center gap-2 px-3 py-1 bg-gray-100 border border-gray-300 rounded-full text-sm text-gray-800 shadow-sm"
                  >
                    {region.name}
                    <button
                      onClick={() => handleDelete(region.id)}
                      className="text-red-500 hover:text-red-600 transition"
                      aria-label={`Remover ${region.name}`}
                    >
                      <Trash2 size={14} />
                    </button>
                  </motion.li>
                ))}
              </ul>
            ) : (
              <p className="text-sm text-gray-500 text-center mt-4">
                Nenhuma micro-região criada ainda.
              </p>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : SurveyCollectionSkeleton.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/SurveyCollectionSkeleton.jsx
--------------------------------------
📜 Conteúdo:

export default function SurveyCollectionSkeleton() {
  return (
    <div className="bg-gray-50 border border-gray-200 rounded-2xl shadow-md p-6 sm:p-8 max-w-4xl mx-auto w-full space-y-6 animate-pulse">
      <div className="flex items-center justify-between gap-4">
        <div className="flex items-center gap-3">
          <div className="w-5 h-5 bg-gray-300 rounded-full" />
          <div className="w-48 h-6 bg-gray-300 rounded" />
        </div>
        <div className="w-12 h-6 bg-gray-300 rounded-full" />
      </div>

      <div className="space-y-2">
        <div className="w-40 h-4 bg-gray-300 rounded" />
        <div className="w-60 h-4 bg-gray-300 rounded" />
      </div>

      <div className="space-y-4">
        <div className="flex justify-between items-center">
          <div className="w-40 h-5 bg-gray-300 rounded" />
          <div className="w-10 h-5 bg-gray-300 rounded-full" />
        </div>

        <div className="space-y-4">
          <div className="w-full h-10 bg-gray-300 rounded" />
          <div className="w-full h-10 bg-gray-300 rounded" />
          <div className="flex gap-4 justify-center pt-4">
            <div className="w-24 h-10 bg-gray-300 rounded" />
            <div className="w-24 h-10 bg-gray-300 rounded" />
          </div>
        </div>
      </div>

      {[...Array(3)].map((_, i) => (
        <div key={i} className="space-y-4">
          <div className="flex justify-between items-center">
            <div className="w-40 h-5 bg-gray-300 rounded" />
            <div className="w-10 h-5 bg-gray-300 rounded-full" />
          </div>
          <div className="w-full h-36 bg-gray-300 rounded" />
        </div>
      ))}
    </div>
  );
}


============================================================


📄 Arquivo : SurveyLoader.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/SurveyLoader.jsx
--------------------------------------
📜 Conteúdo:

import { Skeleton } from '@/components/ui/skeleton';
import { Card, CardContent } from '@/components/ui/card';

console.log('Skeleton', Skeleton);
console.log('Card', Card);
console.log('CardContent', CardContent);

export default function SurveyLoader() {
  return (
    <div className="flex flex-col gap-4 p-4 max-w-3xl mx-auto">
      <div className="mb-6">
        <Skeleton className="h-8 w-3/4" />
        <Skeleton className="h-4 w-1/2 mt-2" />
      </div>

      {/* Simula 3 perguntas carregando */}
      {[1, 2, 3].map((index) => (
        <Card key={index}>
          <CardContent className="p-4">
            <Skeleton className="h-5 w-4/5 mb-2" />
            <Skeleton className="h-10 w-full" />
          </CardContent>
        </Card>
      ))}

      <div className="flex justify-end mt-6">
        <Skeleton className="h-10 w-32" />
      </div>
    </div>
  );
}

============================================================


📄 Arquivo : TimeRanges.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/TimeRanges.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import { Clock, Plus, Trash2 } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";
import TimeSelectorModal from "@/components/surveys/TimeSelectorModal";
import { useSurveyTimeRanges } from "@/hooks/useSurveyTimeRanges";

export default function TimeRanges({ survey_id, survey_type }) {
  const {
    ranges,
    unSyncedRanges,
    loading,
    addSurveyTimeRange,
    deleteSurveyTimeRange,
  } = useSurveyTimeRanges(survey_id);

  const [showTimeRanges, setShowTimeRanges] = useState(false);
  const [showModal, setShowModal] = useState(false);

  const handleAddTime = async ({ start_time, end_time }) => {
    await addSurveyTimeRange({
      start_time,
      end_time,
      survey_id,
      survey_type,
    });
  };

  const handleDelete = async (id) => {
    await deleteSurveyTimeRange(id);
  };

  return (
    <div className="rounded-lg space-y-4">
      <div className="flex items-center justify-between px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Horas de Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <Clock
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Defina os horários exatos de atuação dos pesquisadores em
                    campo.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Registre os horários em que a coleta será realizada.
          </p>
        </div>
        <Switch
          checked={showTimeRanges}
          onChange={setShowTimeRanges}
          type="arrow"
        />
      </div>

      <AnimatePresence>
        {showTimeRanges && (
          <motion.div
            key="timerange-toggle"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.25 }}
            className="space-y-5 bg-white border border-gray-100 rounded-lg shadow-sm px-4 py-5"
          >
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold text-gray-800">
                  Registrar horários
                </h3>
                <p className="text-xs text-gray-600">
                  Exemplos: 09h00, 09h30, 10h00...
                </p>
              </div>
              <button
                onClick={() => setShowModal(true)}
                className="inline-flex items-center gap-2 px-3 py-2 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 active:scale-95 transition shadow"
              >
                <Plus size={16} />
                Adicionar hora
              </button>
            </div>

            {loading ? (
              <p className="text-sm text-gray-400 text-center">
                Carregando horários...
              </p>
            ) : ranges.length > 0 ? (
              <ul className="flex flex-wrap gap-2">
                {ranges.map((r) => (
                  <motion.li
                    key={r.id}
                    initial={{ opacity: 0, scale: 0.95 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.95 }}
                    transition={{ duration: 0.2 }}
                    className="flex items-center gap-2 px-3 py-1 bg-gray-100 border border-gray-300 rounded-full text-sm text-gray-800 shadow-sm"
                  >
                    {r.start_time} → {r.end_time}
                    <button
                      onClick={() => handleDelete(r.id)}
                      className="text-red-500 hover:text-red-600 transition"
                    >
                      <Trash2 size={14} />
                    </button>
                  </motion.li>
                ))}
              </ul>
            ) : (
              <p className="text-sm text-gray-500 text-center">
                Nenhum horário registrado.
              </p>
            )}

            <TimeSelectorModal
              isOpen={showModal}
              onClose={() => setShowModal(false)}
              onSelectTime={handleAddTime}
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : TimeSelectorModal.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/TimeSelectorModal.jsx
--------------------------------------
📜 Conteúdo:

import { Dialog } from "@headlessui/react";
import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { X } from "lucide-react";

export default function TimeSelectorModal({ isOpen, onClose, onSelectTime }) {
  const [startHour, setStartHour] = useState("09");
  const [startMinute, setStartMinute] = useState("00");
  const [endHour, setEndHour] = useState("10");
  const [endMinute, setEndMinute] = useState("00");

  const handleConfirm = () => {
    const start = `${startHour}:${startMinute}`;
    const end = `${endHour}:${endMinute}`;
    onSelectTime({ start_time: start, end_time: end });
    onClose();
  };

  const hours = Array.from({ length: 17 }, (_, i) => String(i + 6).padStart(2, "0"));
  const minutes = ["00", "15", "30", "45"];

  return (
    <AnimatePresence>
      {isOpen && (
        <Dialog as="div" open={isOpen} onClose={onClose} className="relative z-50">
          {/* Fundo escurecido */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/40 backdrop-blur-sm"
            aria-hidden="true"
          />

          {/* Painel modal */}
          <div className="fixed inset-0 flex items-center justify-center p-4">
            <motion.div
              initial={{ opacity: 0, y: 24 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 24 }}
              transition={{ duration: 0.25 }}
              className="relative w-full max-w-sm bg-white rounded-2xl shadow-xl p-6 space-y-6"
            >
              <Dialog.Panel className="w-full space-y-6">
                <button
                  onClick={onClose}
                  className="absolute top-3 right-3 bg-red-600 hover:bg-red-700 p-1.5 rounded-full shadow text-white transition"
                  aria-label="Fechar"
                >
                  <X size={16} />
                </button>

                <Dialog.Title className="text-lg font-semibold text-gray-800 text-center">
                  Selecione um intervalo de horário
                </Dialog.Title>

                {/* Selects */}
                <div className="flex flex-col gap-4">
                  <div className="flex justify-center gap-3 items-center">
                    <label className="text-sm font-medium text-gray-600">Início:</label>
                    <select
                      value={startHour}
                      onChange={(e) => setStartHour(e.target.value)}
                      className="w-20 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                    >
                      {hours.map((h) => (
                        <option key={h} value={h}>{h}</option>
                      ))}
                    </select>
                    <span className="text-lg font-medium text-gray-600">:</span>
                    <select
                      value={startMinute}
                      onChange={(e) => setStartMinute(e.target.value)}
                      className="w-20 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                    >
                      {minutes.map((m) => (
                        <option key={m} value={m}>{m}</option>
                      ))}
                    </select>
                  </div>

                  <div className="flex justify-center gap-3 items-center">
                    <label className="text-sm font-medium text-gray-600">Fim:</label>
                    <select
                      value={endHour}
                      onChange={(e) => setEndHour(e.target.value)}
                      className="w-20 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                    >
                      {hours.map((h) => (
                        <option key={h} value={h}>{h}</option>
                      ))}
                    </select>
                    <span className="text-lg font-medium text-gray-600">:</span>
                    <select
                      value={endMinute}
                      onChange={(e) => setEndMinute(e.target.value)}
                      className="w-20 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                    >
                      {minutes.map((m) => (
                        <option key={m} value={m}>{m}</option>
                      ))}
                    </select>
                  </div>
                </div>

                {/* Botão de Adicionar */}
                <div className="flex justify-center pt-2">
                  <motion.button
                    whileTap={{ scale: 0.95 }}
                    onClick={handleConfirm}
                    className="px-5 py-2 text-sm rounded-md bg-green-600 text-white hover:bg-green-700 active:scale-95 transition"
                  >
                    Adicionar
                  </motion.button>
                </div>
              </Dialog.Panel>
            </motion.div>
          </div>
        </Dialog>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : Button.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Button.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import clsx from "clsx";
import { VARIANTS } from "@/config/colors";

export default function Button({
  children,
  className = "",
  variant = "primary",
  ...props
}) {
  const baseStyle = "py-2 px-2 rounded font-medium transition";


  return (
    <button
      className={clsx(baseStyle, VARIANTS[variant], className)}
      {...props}
    >
      {children}
    </button>
  );
}


============================================================


📄 Arquivo : FiltersComponent.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/FiltersComponent.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import clsx from "clsx";
import Button from "@/components/ui/Button";
import Switch from "@/components/ui/Switch";

export default function FiltersComponent({
  showFilters,
  setShowFilters,
  filters,
  onChange,
  onClear,
  variants = {},
  mobilePosition = "right", // default: "right"
}) {
  const [mobileOpen, setMobileOpen] = useState(false);

  const renderFilterContent = () => (
    <section className="space-y-5">
      {filters.map((filter) => {
        if (filter.type === "text") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-1">
                <span className="material-symbols-outlined text-base">
                  {filter.icon}
                </span>
                {filter.label}
              </label>
              <input
                type="text"
                value={filter.value}
                onChange={(e) => onChange(filter.key, e.target.value)}
                placeholder={filter.placeholder || ""}
                className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400"
              />
            </div>
          );
        }

        if (filter.type === "button-group") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-1">
                <span className="material-symbols-outlined text-base">
                  {filter.icon}
                </span>
                {filter.label}
              </label>
              <div className="flex gap-2 flex-wrap">
                {filter.options.map((opt) => (
                  <button
                    key={opt.value}
                    onClick={() => onChange(filter.key, opt.value)}
                    className={clsx(
                      "px-4 py-1 rounded-full text-sm border",
                      filter.value === opt.value
                        ? variants.secondary || "bg-gray-400 text-white"
                        : variants.light || "bg-gray-100"
                    )}
                  >
                    {opt.label}
                  </button>
                ))}
              </div>
            </div>
          );
        }

        if (filter.type === "switch-group") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-2">
                <span className="material-symbols-outlined text-base">
                  visibility
                </span>
                {filter.label}
              </label>
              <div className="space-y-2">
                {filter.options.map((opt) => (
                  <div
                    key={opt.value}
                    className="flex items-center justify-between border border-gray-200 p-3 rounded-lg"
                  >
                    <span className="text-sm text-gray-700">{opt.label}</span>
                    <Switch
                      checked={opt.checked}
                      onChange={(checked) => {
                        onChange(filter.key, { [opt.value]: checked });
                      }}
                    />
                  </div>
                ))}
              </div>
            </div>
          );
        }

        return null;
      })}

      {filters.some((f) => f.value !== "" && f.value !== f.defaultValue) && (
        <div className="pt-1">
          <Button
            onClick={onClear}
            variant="transparent_cinza"
            className="text-sm"
          >
            Limpar Filtros
          </Button>
        </div>
      )}
    </section>
  );

  return (
    <div>
      {/* DESKTOP: botão de expandir/recolher */}
      <div className="hidden lg:flex justify-end mb-2">
        <Button
          variant="light"
          onClick={() => setShowFilters((prev) => !prev)}
          className="text-sm flex items-center gap-1"
        >
          <span className="material-symbols-outlined text-base">
            {showFilters ? "expand_less" : "tune"}
          </span>
          {showFilters ? "Esconder filtros" : "Mostrar filtros"}
        </Button>
      </div>

      {/* DESKTOP: filtros inline */}
      <div
        className={clsx(
          "transition-all overflow-hidden hidden lg:block",
          showFilters ? "max-h-[1000px] opacity-100" : "max-h-0 opacity-0"
        )}
      >
        <section className="mb-6 border border-gray-200 rounded-xl shadow-sm p-4 bg-white fixed right-10">
          {renderFilterContent()}
        </section>
      </div>

      {/* MOBILE: botão flutuante */}
      {!mobileOpen && (
        <div className="fixed bottom-4 right-4 z-50 lg:hidden">
          <button
            onClick={() => setMobileOpen(true)}
            className="w-14 h-14 rounded-full bg-gray-400 text-white flex items-center justify-center shadow-lg hover:scale-105 transition"
          >
            <span className="material-symbols-outlined text-3xl">tune</span>
          </button>
        </div>
      )}

      {/* MOBILE: painel lateral */}
      {mobileOpen && (
        <div
          className={clsx(
            "fixed top-0 bottom-0 z-50 w-72 max-w-full bg-white shadow-2xl border border-gray-200 p-4 transition-transform duration-300 lg:hidden",
            mobilePosition === "right"
              ? "right-0 animate-slide-in-right"
              : "left-0 animate-slide-in-left"
          )}
        >
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-bold text-gray-800">Filtros</h2>
            <button
              onClick={() => setMobileOpen(false)}
              className="text-gray-600 hover:text-gray-900 transition"
            >
              <span className="material-symbols-outlined text-2xl">close</span>
            </button>
          </div>

          <div className="overflow-y-auto h-full pr-1">
            {renderFilterContent()}
          </div>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : FullscreenButton.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/FullscreenButton.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";

const isDesktop = () => {
  if (typeof window === "undefined") return false;
  return window.innerWidth >= 1024;
};

export default function FullscreenButton({ expanded, hovered, setHovered }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (isDesktop()) setVisible(true);

    const handleResize = () => {
      setVisible(window.innerWidth >= 1024);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  const enterFullscreen = async () => {
    try {
      await document.documentElement.requestFullscreen();
      setVisible(false);
    } catch (err) {
      console.error("Erro ao tentar entrar em fullscreen:", err);
    }
  };

  if (!visible) return null;

  return (
    <div
      className="relative"
      onMouseEnter={() => {
        if (!expanded) setHovered("Fullscreen");
      }}
      onMouseLeave={() => {
        if (!expanded) setHovered(null);
      }}
    >
      <button
        onClick={enterFullscreen}
        className={`group flex items-center gap-2 px-4 py-2 rounded-md transition-all w-full hover:bg-gray-100 ${
          !expanded ? "justify-center" : ""
        } text-black`}
      >
        <span className="material-symbols-outlined text-xl">fullscreen</span>
        {expanded && (
          <span className="text-sm font-medium whitespace-nowrap">
            Tela cheia
          </span>
        )}
      </button>

      {!expanded && hovered === "Fullscreen" && (
        <AnimatePresence>
          <motion.div
            initial={{ opacity: 0, x: 10 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 10 }}
            transition={{ duration: 0.2 }}
            className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
          >
            Tela cheia
          </motion.div>
        </AnimatePresence>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : Loading.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Loading.jsx
--------------------------------------
📜 Conteúdo:

"use client";

import { motion } from "framer-motion";

export default function Loading({ message = "Carregando..." }) {
  return (
    <motion.div
      className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-white/80"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
    >
      {/* Mensagem acima do spinner */}
      {message && (
        <motion.p
          className="mb-4 text-gray-700 text-sm font-medium"
          initial={{ opacity: 0, y: -6 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.2, ease: "easeOut" }}
        >
          {message}
        </motion.p>
      )}

      <motion.div
        className="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"
        initial={{ scale: 0.8 }}
        animate={{ scale: 1 }}
        transition={{ duration: 0.3, ease: "easeOut" }}
      />
    </motion.div>
  );
}


============================================================


📄 Arquivo : Message.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Message.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";

const variantStyles = {
  verde: "text-black bg-[rgb(114,227,173)] border-[rgb(80,180,130)] hover:brightness-95",
  vermelho: "text-white bg-red-600 border-transparent hover:bg-red-700",
  vermelho_claro: "text-red-700 bg-red-100 border-red-400 hover:bg-red-200",
  azul_claro: "text-black bg-blue-200 border-blue-600 hover:bg-blue-300",
  cinza: "text-black bg-gray-300 border-gray-800 hover:bg-gray-400",
  azul_escuro: "text-white bg-blue-600 border-transparent hover:bg-blue-700"
};

export default function Message({ message, variant = "info", show }) {
  return (
    <AnimatePresence>
      {show && (
        <motion.div
          initial={{ y: -60, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: -60, opacity: 0 }}
          transition={{ duration: 0.4, ease: "easeOut" }}
          className={`
            fixed top-4 inset-x-0 z-50
            w-fit max-w-[90%] mx-auto
            px-4 py-3 rounded-xl shadow-lg text-center
            text-sm font-medium
            ${variantStyles[variant] || variantStyles.info}
          `}
        >
          {message}
        </motion.div>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : ModalRegisterUser.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/ModalRegisterUser.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { AnimatePresence, motion } from "framer-motion";
import Button from "@/components/ui/Button";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";

export default function ModalRegisterUser({
  isOpen,
  onClose,
  onUserCreated,
  showMessage,
}) {
  const [form, setForm] = useState({
    name: "",
    email: "",
    confirmation_email: "",
    role: "",
    status: "",
  });
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setForm({
        name: "",
        email: "",
        confirmation_email: "",
        role: "",
        status: "",
      });
    }
  }, [isOpen]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (form.email !== form.confirmation_email) {
      showMessage("E-mails não coincidem", "vermelho_claro", 5000);
      return;
    }
    setIsProcessing(true);

    try {
      // Cria objeto sem confirmation_email
      const userToCreate = {
        name: form.name,
        email: form.email,
        role: form.role,
        status: form.status,
      };

      // Aqui usamos o onUserCreated passado pelo componente pai (Users.jsx)
      if (onUserCreated) {
        await onUserCreated(userToCreate);
      }

      showMessage("Usuário cadastrado com sucesso!", "verde");
      onClose();
    } catch (err) {
      console.error("Erro ao criar usuário:", err);
      showMessage("Erro ao cadastrar usuário. Tente novamente.", "vermelho_claro", 5000);
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className="absolute inset-0 bg-black bg-opacity-40"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className="relative bg-white rounded-lg shadow-lg w-full max-w-md mx-2"
          >
            <div className="bg-gray-600 rounded-t-lg p-4">
              <h2 className="text-xl font-semibold text-white">
                Cadastrar Novo Usuário
              </h2>
              <button
                onClick={onClose}
                className="absolute top-3 right-3 text-white hover:text-gray-200"
              >
                <span className="material-symbols-outlined text-xl">close</span>
              </button>
            </div>

            <div className="p-6">
              <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Nome
                  </label>
                  <input
                    type="text"
                    name="name"
                    value={form.name}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    E-mail
                  </label>
                  <input
                    type="email"
                    name="email"
                    value={form.email}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Confirmar E-mail
                  </label>
                  <input
                    type="email"
                    name="confirmation_email"
                    value={form.confirmation_email}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Papel
                  </label>
                  <select
                    name="role"
                    value={form.role}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    <option value="">Selecione um papel</option>
                    {USER_ROLES.map((role) => (
                      <option key={role} value={role}>
                        {role}
                      </option>
                    ))}
                  </select>
                </div>

                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Status
                  </label>
                  <select
                    name="status"
                    value={form.status}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    <option value="">Selecione um status</option>
                    {USER_STATUS.map((status) => (
                      <option key={status} value={status}>
                        {status}
                      </option>
                    ))}
                  </select>
                </div>

                <div className="flex justify-center">
                  <Button
                    type="submit"
                    variant="dark"
                    disabled={isProcessing}
                    className="w-full max-w-xs text-md"
                  >
                    {isProcessing ? (
                      "Cadastrando..."
                    ) : (
                      <span className="flex items-center justify-center">
                        <span className="material-symbols-outlined mr-2">
                          person_add
                        </span>
                        Cadastrar
                      </span>
                    )}
                  </Button>
                </div>
              </form>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : ModalUser.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/ModalUser.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { AnimatePresence, motion } from "framer-motion";
import Button from "@/components/ui/Button";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";
import Link from "next/link";

export default function ModalUser({
  isOpen,
  user,
  onClose,
  onUserUpdated,
  showMessage,
}) {
  const [form, setForm] = useState({
    id: "",
    name: "",
    email: "",
    role: "",
    status: "",
  });
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    if (user) {
      setForm({
        id: user.id || "",
        name: user.name || "",
        email: user.email || "",
        role: user.role || "",
        status: user.status || "",
      });
    }
  }, [user]);

  if (!isOpen || !user) {
    return null;
  }

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const cleanStatus = (status) => status.replace(/^["']|["']$/g, "");

  const handleUpdate = async () => {
    setIsProcessing(true);
    const updateData = { ...form, status: cleanStatus(form.status) };

    try {
      await onUserUpdated(updateData);  // chama o handler do componente pai
      showMessage("Usuário atualizado com sucesso!", "verde");
      onClose();
    } catch (err) {
      console.error("Erro ao atualizar usuário:", err);
      showMessage("Erro ao atualizar usuário. Tente novamente.", "vermelho_claro", 5000);
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && user && (
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className="absolute inset-0 bg-black bg-opacity-40"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />

          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className="relative bg-white rounded-lg shadow-lg w-full max-w-md mx-2"
          >
            <div className="bg-gray-600 rounded-t-lg p-4">
              <h2 className="text-xl font-semibold text-white">
                Detalhes do Usuário
              </h2>
              <button
                className="absolute top-3 right-3 text-white hover:text-gray-200"
                onClick={onClose}
              >
                <span className="material-symbols-outlined text-xl">close</span>
              </button>
            </div>

            <div className="p-6 space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Nome
                </label>
                <input
                  type="text"
                  name="name"
                  value={form.name}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700">
                  E-mail
                </label>
                <input
                  type="email"
                  name="email"
                  value={form.email}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Papel
                </label>
                <select
                  name="role"
                  value={form.role}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="">Selecione um papel</option>
                  {USER_ROLES.map((role) => (
                    <option key={role} value={role}>
                      {role}
                    </option>
                  ))}
                </select>
              </div>

              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Status
                </label>
                <select
                  name="status"
                  value={form.status}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="">Selecione um status</option>
                  {USER_STATUS.map((status) => (
                    <option key={status} value={status}>
                      {status}
                    </option>
                  ))}
                </select>
              </div>

              <div className="flex flex-row justify-center items-center">
                <Link href={`/users/${form.id}`} passHref>
                  <Button variant="dark" className="w-full">
                    Ver Perfil
                  </Button>
                </Link>
              </div>
            </div>

            <div className="flex justify-end items-center space-x-2 p-4 border-t">
              <Button
                onClick={handleUpdate}
                variant="transparent_verde"
                disabled={isProcessing}
              >
                {isProcessing ? (
                  "Salvando..."
                ) : (
                  <div className="flex items-center space-x-2">
                    <span>Salvar</span>
                    <span className="material-symbols-outlined text-base">
                      save
                    </span>
                  </div>
                )}
              </Button>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : DropdownSelect.jsx
📂 Pasta   : components/ui/Multiselect
🧭 Caminho : components/ui/Multiselect/DropdownSelect.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ChevronDown, Check } from "lucide-react";

export default function DropdownSelect({
  options = [],
  selected = null,
  onChange,
  placeholder = "Selecionar...",
  label,
}) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  const handleToggle = () => setIsOpen(!isOpen);

  const handleSelect = (value) => {
    onChange(value);
    setIsOpen(false);
  };

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const selectedLabel = options.find((opt) => opt.value === selected)?.label;

  return (
    <div className="relative w-full max-w-md" ref={dropdownRef}>
      {label && (
        <label className="block mb-1 text-sm font-medium text-zinc-700 dark:text-zinc-300">
          {label}
        </label>
      )}
      <button
        type="button"
        onClick={handleToggle}
        className="w-full bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-700 rounded-lg px-4 py-2 flex justify-between items-center text-sm text-zinc-700 dark:text-zinc-200 shadow-sm hover:border-zinc-400"
      >
        <span>
          {selectedLabel || placeholder}
        </span>
        <ChevronDown className="w-4 h-4 ml-2" />
      </button>

      <AnimatePresence>
        {isOpen && (
          <motion.ul
            initial={{ opacity: 0, y: -5 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -5 }}
            transition={{ duration: 0.2 }}
            className="absolute z-10 mt-2 w-full bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-700 rounded-lg shadow-lg max-h-60 overflow-y-auto text-sm"
          >
            {options.map((option) => (
              <li
                key={option.value}
                className="px-4 py-2 hover:bg-zinc-100 dark:hover:bg-zinc-800 cursor-pointer flex items-center justify-between"
                onClick={() => handleSelect(option.value)}
              >
                <span className="text-zinc-700 dark:text-zinc-200">{option.label}</span>
                {selected === option.value && (
                  <Check className="w-4 h-4 text-green-500" />
                )}
              </li>
            ))}
          </motion.ul>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : Multiselect.jsx
📂 Pasta   : components/ui/Multiselect
🧭 Caminho : components/ui/Multiselect/Multiselect.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import Select from "react-select";

export default function MultiSelect({
  options = [],
  value = [],
  onChange,
  placeholder = "Selecione...",
  isDisabled = false,
  isMulti = true,
  closeMenuOnSelect = false,
}) {
  const customStyles = {
    control: (base, state) => ({
      ...base,
      backgroundColor: isDisabled ? "#f3f4f6" : "#fff",
      borderColor: state.isFocused ? "#22c55e" : "#d1d5db",
      boxShadow: state.isFocused ? "0 0 0 2px rgba(34, 197, 94, 0.3)" : "none",
      borderWidth: "1px",
      borderRadius: "0.5rem",
      padding: "2px 4px",
      transition: "all 0.2s ease",
      cursor: isDisabled ? "not-allowed" : "default",
      minHeight: "42px",
    }),
    option: (base, { isSelected, isFocused }) => ({
      ...base,
      backgroundColor: isSelected
        ? "#22c55e"
        : isFocused
        ? "#e5f9ed"
        : "#fff",
      color: isSelected ? "white" : "#111827",
      padding: "10px 12px",
      fontSize: "0.875rem",
      zIndex: 9999,
    }),
    multiValue: (base) => ({
      ...base,
      backgroundColor: "#d1fae5",
      borderRadius: "6px",
      padding: "2px 4px",
    }),
    multiValueLabel: (base) => ({
      ...base,
      color: "#065f46",
      fontWeight: 500,
    }),
    multiValueRemove: (base) => ({
      ...base,
      color: "#047857",
      ":hover": {
        backgroundColor: "#a7f3d0",
        color: "#064e3b",
      },
    }),
    menu: (base) => ({
      ...base,
      zIndex: 9999,
    }),
    menuPortal: (base) => ({
      ...base,
      zIndex: 9999,
    }),
  };

  return (
    <Select
      isMulti={isMulti}
      isDisabled={isDisabled}
      options={options}
      value={value}
      onChange={onChange}
      styles={customStyles}
      placeholder={placeholder}
      className="text-sm"
      closeMenuOnSelect={closeMenuOnSelect}
      menuPortalTarget={typeof window !== "undefined" ? document.body : null}
    />
  );
}


============================================================


📄 Arquivo : ResearchCard.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCard.jsx
--------------------------------------
📜 Conteúdo:

import { useRouter } from "next/router";
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";
import { motion } from "framer-motion";

export default function ResearchCard({ research }) {
  const router = useRouter();
  const imageIndex = Math.floor(Math.random() * 5); // 0 a 4
  const imageUrl = `/img/cards/img-${imageIndex}.jpg`;

  return (
    <motion.div
      whileHover={{ scale: 1.03 }}
      transition={{ duration: 0.2 }}
      className="rounded-2xl shadow-md bg-white overflow-hidden flex flex-col justify-between border hover:shadow-xl"
    >
      {/* Header com imagem de fundo */}
      <div
        className="relative h-14 bg-cover bg-center"
        style={{ backgroundImage: `url('${imageUrl}')` }}
      >
        <div className="absolute inset-0 bg-black/30 rounded-t-2xl" />
        <div className="absolute inset-0 flex items-center px-4">
          <h3 className="text-white text-md font-semibold truncate drop-shadow-md z-10">
            {research.title}
          </h3>
        </div>
      </div>

      {/* Conteúdo textual abaixo da imagem */}
      <div className="p-4 space-y-2 text-sm">
        <p className="text-gray-600 truncate">
          Descrição: {research.description || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Local: {research.location_title || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Início: {research.release_date || "—"}
        </p>
      </div>

      {/* Rodapé com botões */}
      <div className="flex items-center justify-between gap-2 px-4 pb-4">
        {research._syncStatus && (
          <span
            className={`flex-shrink-0 truncate max-w-[100px] px-2 py-1 text-xs font-semibold rounded ${
              VARIANTS[research._syncStatus] || VARIANTS.verde
            }`}
          >
            {research._syncStatus}
          </span>
        )}
        <div className="flex items-center gap-2 ml-auto">
          <Button
            variant="transparent_cinza"
            className="p-2"
            title="Ver Detalhes"
            onClick={() => router.push(`/researches/${research.id}`)}
          >
            <span className="material-symbols-outlined text-base">
              visibility
            </span>
          </Button>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : ResearchCardCompact.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCardCompact.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";

export default function ResearchCardCompact({ research }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className="bg-white border border-gray-200 rounded-lg p-3 shadow-sm text-sm space-y-1 hover:shadow-md transition-all"
    >
      <div className="flex items-center gap-2">
        <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center text-gray-600 text-xs font-bold uppercase">
          {research.title?.charAt(0)}
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-medium text-gray-800 truncate">{research.title}</h4>
          <p className="text-xs text-gray-500 truncate">ID: {research.id}</p>
          <p className="text-xs text-gray-500 truncate">Local: {research.location_title || "—"}</p>
          <p className="text-xs text-gray-500 truncate">Início: {research.release_date || "—"}</p>
          {/* Adicione mais campos aqui se quiser */}
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : ResearchCardDashboard.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCardDashboard.jsx
--------------------------------------
📜 Conteúdo:

import { useRouter } from "next/router";
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";
import { motion } from "framer-motion";

export default function ResearchCard({ research, showButton = true }) {
  const router = useRouter();
  const imageIndex = Math.floor(Math.random() * 5); // 0 a 4
  const imageUrl = `/img/cards/img-${imageIndex}.jpg`;

  return (
    <motion.div
      whileHover={{ scale: 1.03 }}
      transition={{ duration: 0.2 }}
      className="rounded-2xl shadow-md bg-white overflow-hidden flex flex-col justify-between border hover:shadow-xl"
    >
      {/* Header com imagem de fundo */}
      <div
        className="relative h-14 bg-cover bg-center"
        style={{ backgroundImage: `url('${imageUrl}')` }}
      >
        <div className="absolute inset-0 bg-black/30 rounded-t-2xl" />
        <div className="absolute inset-0 flex items-center px-4">
          <h3 className="text-white text-md font-semibold truncate drop-shadow-md z-10">
            {research.title}
          </h3>
        </div>
      </div>

      {/* Conteúdo textual abaixo da imagem */}
      <div className="p-4 space-y-2 text-sm">
        <p className="text-gray-600 truncate">
          Descrição: {research.description || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Local: {research.location_title || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Início: {research.release_date || "—"}
        </p>
      </div>

      {/* Rodapé com botões */}
      <div className="flex items-center justify-between gap-2 px-4 pb-4">
        {research._syncStatus && (
          <span
            className={`flex-shrink-0 truncate max-w-[100px] px-2 py-1 text-xs font-semibold rounded ${
              VARIANTS[research._syncStatus] || VARIANTS.verde
            }`}
          >
            {research._syncStatus}
          </span>
        )}
        <div className="flex items-center gap-2 ml-auto">
          {showButton && (
            <Button
            variant="transparent_cinza"
            className="p-2"
            title="Ver Detalhes"
            onClick={() => router.push(`/researches/${research.id}/view`)}
          >
            <span className="material-symbols-outlined text-base">
              visibility
            </span>
          </Button>
          )}
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : ResearchCardSkeleton.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCardSkeleton.jsx
--------------------------------------
📜 Conteúdo:

export default function ResearchCardSkeleton() {
    return (
      <div className="animate-pulse bg-white rounded-lg shadow p-4 space-y-3">
        <div className="h-4 bg-gray-300 rounded w-3/4" />
        <div className="h-3 bg-gray-200 rounded w-full" />
        <div className="h-3 bg-gray-200 rounded w-5/6" />
        <div className="h-3 bg-gray-200 rounded w-1/2" />
      </div>
    );
  }
  

============================================================


📄 Arquivo : SideBarSectionsFilter.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/SideBarSectionsFilter.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { AnimatePresence, motion } from "framer-motion";

/**
 * SideBarSectionsFilter
 * Componente de navegação entre seções via ícones e labels.
 * - Aparece como um botão flutuante (bolinha) para abrir/fechar
 * - Exibe menu fixo à direita ao abrir, com animação
 *
 * Props:
 *  - sections: [{ id: string, label: string, icon: string }]
 */
export default function SideBarSectionsFilter({ sections }) {
  const [visible, setVisible] = useState(false);

  const handleScrollTo = (id) => {
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior: "smooth" });
    setVisible(false); // fecha o menu após clique
  };

  return (
    <>
      {/* Botão flutuante para abrir/fechar */}
      <button
        onClick={() => setVisible((prev) => !prev)}
        className="fixed bottom-4 right-4 bg-gray-400 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-xl z-50 hover:scale-105 transition"
      >
        <span className="material-symbols-outlined">
          {visible ? "close" : "menu"}
        </span>
      </button>

      {/* Navbar lateral direita animada */}
      <AnimatePresence>
        {visible && (
          <motion.nav
            initial={{ x: 200, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 200, opacity: 0 }}
            transition={{ duration: 0.25 }}
            className="fixed right-0 top-1/3 -translate-y-1/2 bg-white border-l border-gray-200 rounded-l-xl shadow-2xl p-4 flex flex-col gap-5 z-40"
          >
            {sections.map((section) => (
              <button
                key={section.id}
                onClick={() => handleScrollTo(section.id)}
                className="flex flex-col items-center text-xs text-gray-700 hover:text-indigo-600 transition"
              >
                <span className="material-symbols-outlined text-xl">
                  {section.icon}
                </span>
                <span className="text-[10px] mt-1">{section.label}</span>
              </button>
            ))}
          </motion.nav>
        )}
      </AnimatePresence>
    </>
  );
}


============================================================


📄 Arquivo : Switch.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Switch.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import {
  ChevronDown,
  ChevronUp,
  Check,
  Eye,
  EyeOff,
} from "lucide-react";
import React from "react";

export default function Switch({
  checked = false,
  onChange,
  disabled = false,
  type = "toggle", // "toggle", "arrow", "checkbox", "eye"
}) {
  const baseBtn =
    "flex items-center gap-2 px-3 py-1 text-sm rounded-md border transition-all duration-200 shadow-sm " +
    "bg-white dark:bg-zinc-800 text-gray-700 dark:text-gray-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500";

  const interactive = !disabled
    ? "hover:bg-gray-100 dark:hover:bg-zinc-700 cursor-pointer"
    : "opacity-50 cursor-not-allowed";

  if (type === "arrow") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 bg-transparent shadow-sm hover:bg-gray-100 transition-all focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
          disabled ? "opacity-50 cursor-not-allowed" : ""
        }`}
      >
        <AnimatePresence mode="wait" initial={false}>
          {checked ? (
            <motion.div
              key="up"
              initial={{ opacity: 0, y: 4 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -4 }}
              transition={{ duration: 0.2 }}
            >
              <ChevronUp className="w-4 h-4 text-green-600" />
            </motion.div>
          ) : (
            <motion.div
              key="down"
              initial={{ opacity: 0, y: -4 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 4 }}
              transition={{ duration: 0.2 }}
            >
              <ChevronDown className="w-4 h-4 text-green-600" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  if (type === "eye") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`${baseBtn} ${interactive}`}
      >
        <AnimatePresence mode="wait" initial={false}>
          {checked ? (
            <motion.div
              key="eye"
              className="flex items-center gap-1"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
            >
              Exibir <Eye className="w-4 h-4 text-green-600" />
            </motion.div>
          ) : (
            <motion.div
              key="eyeoff"
              className="flex items-center gap-1"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
            >
              Ocultar <EyeOff className="w-4 h-4 text-gray-500" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  if (type === "checkbox") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`flex items-center justify-center w-5 h-5 rounded border transition-all duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
          checked
            ? "bg-green-600 border-green-700"
            : "bg-white border-gray-300"
        } ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}`}
      >
        <AnimatePresence>
          {checked && (
            <motion.div
              key="check"
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.2 }}
            >
              <Check className="w-4 h-4 text-white" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  // toggle switch padrão
  return (
    <button
      type="button"
      aria-pressed={checked}
      onClick={() => !disabled && onChange(!checked)}
      disabled={disabled}
      className={`relative inline-flex h-6 w-11 items-center rounded-full border transition-all duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
        checked
          ? "bg-green-600 border-green-700"
          : "bg-gray-300 border-gray-300"
      } ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}`}
    >
      <motion.div
        className="absolute left-1 flex items-center justify-center h-4 w-4 rounded-full bg-white shadow-md"
        animate={{ x: checked ? 20 : 0 }}
        transition={{ type: "spring", stiffness: 300, damping: 20 }}
      />
    </button>
  );
}


============================================================


📄 Arquivo : UserCard.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCard.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";

export default function UserCard({ user, onViewDetails }) {
  const getBadgeVariant = (syncStatus) => {
    switch (syncStatus) {
      case "pendingCreate":
        return VARIANTS.azul_escuro;
      case "pendingUpdate":
        return VARIANTS.warning;
      case "pendingDelete":
        return VARIANTS.vermelho;
      default:
        return VARIANTS.verde;
    }
  };

  const getStatusDotColor = (status) => {
    switch (status?.toLowerCase()) {
      case "active":
      case "ativo":
        return "bg-green-500";
      case "inactive":
      case "inativo":
        return "bg-yellow-400";
      case "pending":
      case "pendente":
        return "bg-orange-400";
      case "banned":
      case "banido":
        return "bg-red-500";
      default:
        return "bg-gray-400";
    }
  };

  const getStatusBackground = (status) => {
    switch (status?.toLowerCase()) {
      case "active":
      case "ativo":
        return "bg-green-100 text-green-800"; // fundo verde claro
      case "inactive":
      case "inativo":
        return "bg-yellow-100 text-yellow-800"; // fundo amarelo claro
      case "pending":
      case "pendente":
        return "bg-orange-100 text-orange-800"; // fundo laranja claro
      case "banned":
      case "banido":
        return "bg-red-100 text-red-800"; // fundo vermelho claro
      default:
        return "bg-gray-100 text-gray-800";
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className="relative bg-white border rounded-lg p-4 shadow-sm hover:shadow-md transition-all flex flex-col justify-between space-y-3"
    >
      {/* Topo: Avatar + Nome e Papel */}
      <div className="flex items-center gap-3">
        <div className="w-10 h-10 bg-gray-100 rounded-full flex items-center justify-center text-gray-600 text-sm font-bold uppercase">
          {user.name?.charAt(0)}
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-semibold text-gray-800 truncate">{user.name}</h4>
          <p className="text-xs text-gray-500 truncate">
            Papel: {user.role || "N/A"}
          </p>
        </div>
      </div>

      {/* Meio: Email e Status */}
      <div className="text-xs text-gray-600 space-y-1">
        <p className="truncate">Email: {user.email || "N/A"}</p>
      </div>

      {/* Rodapé: Badge de Sync + Botão Ver Detalhes */}
      <div className="flex items-center justify-between mt-2">
        <div
          className={`inline-flex items-center gap-2 px-2 py-1 rounded-md text-xs font-medium max-w-fit ${getStatusBackground(
            user.status
          )}`}
        >
          <span
            className={`w-3 h-3 rounded-full ${getStatusDotColor(user.status)}`}
          />
          <p className="truncate">{user.status || "N/A"}</p>
        </div>
        {user._syncStatus && (
          <span
            className={`flex-shrink-0 truncate max-w-[100px] px-2 py-1 text-[10px] font-semibold rounded ${getBadgeVariant(
              user._syncStatus
            )}`}
          >
            {user._syncStatus}
          </span>
        )}
        <Button
          variant="transparent_cinza"
          className="p-1 flex-shrink-0"
          onClick={onViewDetails}
          title="Ver Detalhes"
        >
          <span className="material-symbols-outlined text-base">info</span>
        </Button>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : UserCardCompact.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCardCompact.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";

/**
 * UserCardCompact
 * ---------------
 * Exibe as informações de um usuário em formato de card.
 * - `user`: objeto com {id, name, role, status, email}.
 * - `borderColor`: string opcional para personalizar a cor da borda (ex: "border-green-500").
 * - `showRemoveButton`: boolean opcional (default false). Se true, exibe um botão "x" no canto superior.
 * - `onRemove`: função opcional para ser chamada ao clicar no botão "x".
 */
export default function UserCardCompact({
  user,
  borderColor = "border-gray-200",
  showRemoveButton = false,
  onRemove,
}) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className={`relative bg-white border rounded-lg p-3 shadow-sm text-sm space-y-1 hover:shadow-md transition-all ${borderColor}`}
    >
      {/* Se estiver habilitado para remoção, exibe o botão "x" */}
      {showRemoveButton && (
        <button
          type="button"
          onClick={onRemove}
          className="absolute top-1 right-1 text-gray-500 hover:text-red-500 text-base"
          title="Remover"
        >
          ✕
        </button>
      )}

      <div className="flex items-center gap-2">
        {/* Inicial do Nome */}
        <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center text-gray-600 text-xs font-bold uppercase">
          {user.name?.charAt(0)}
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-medium text-gray-800 truncate">{user.name}</h4>
          <p className="text-xs text-gray-500 truncate">ID: {user.id}</p>
          <p className="text-xs text-gray-500 truncate">
            Papel: {user.role || "N/A"}
          </p>
          <p className="text-xs text-gray-500 truncate">
            Status: {user.status || "N/A"}
          </p>
          <p className="text-xs text-gray-500 truncate">
            Email: {user.email || "N/A"}
          </p>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : UserCardSkeleton.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCardSkeleton.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";

export default function UserCardSkeleton() {
  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className="relative bg-white border rounded-lg p-4 shadow-sm flex flex-col justify-between space-y-3 animate-pulse"
    >
      {/* Topo: Avatar + Nome/Papel */}
      <div className="flex items-center gap-3">
        <div className="w-10 h-10 bg-gray-200 rounded-full" />
        <div className="flex-1 space-y-2">
          <div className="h-4 bg-gray-200 rounded w-3/4" />
          <div className="h-3 bg-gray-200 rounded w-1/2" />
        </div>
      </div>

      {/* Meio: Email e Status */}
      <div className="space-y-2">
        <div className="h-3 bg-gray-200 rounded w-full" />
        <div className="h-3 bg-gray-200 rounded w-5/6" />
      </div>

      {/* Rodapé: Badge + Botão */}
      <div className="flex items-center justify-between mt-2">
        <div className="h-4 bg-gray-200 rounded w-16" />
        <div className="h-8 w-8 bg-gray-200 rounded-full" />
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : card.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/card.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"

import { cn } from "@/lib/utils"

const Card = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("rounded-lg border bg-card text-card-foreground shadow-sm", className)}
    {...props} />
))
Card.displayName = "Card"

const CardHeader = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex flex-col space-y-1.5 p-6", className)}
    {...props} />
))
CardHeader.displayName = "CardHeader"

const CardTitle = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-2xl font-semibold leading-none tracking-tight", className)}
    {...props} />
))
CardTitle.displayName = "CardTitle"

const CardDescription = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("text-sm text-muted-foreground", className)}
    {...props} />
))
CardDescription.displayName = "CardDescription"

const CardContent = React.forwardRef(({ className, ...props }, ref) => (
  <div ref={ref} className={cn("p-6 pt-0", className)} {...props} />
))
CardContent.displayName = "CardContent"

const CardFooter = React.forwardRef(({ className, ...props }, ref) => (
  <div
    ref={ref}
    className={cn("flex items-center p-6 pt-0", className)}
    {...props} />
))
CardFooter.displayName = "CardFooter"

export { Card, CardHeader, CardFooter, CardTitle, CardDescription, CardContent }


============================================================


📄 Arquivo : chart.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/chart.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"
import * as RechartsPrimitive from "recharts"

import { cn } from "@/lib/utils"

// Format: { THEME_NAME: CSS_SELECTOR }
const THEMES = {
  light: "",
  dark: ".dark"
}

const ChartContext = React.createContext(null)

function useChart() {
  const context = React.useContext(ChartContext)

  if (!context) {
    throw new Error("useChart must be used within a <ChartContainer />")
  }

  return context
}

const ChartContainer = React.forwardRef(({ id, className, children, config, ...props }, ref) => {
  const uniqueId = React.useId()
  const chartId = `chart-${id || uniqueId.replace(/:/g, "")}`

  return (
    <ChartContext.Provider value={{ config }}>
      <div
        data-chart={chartId}
        ref={ref}
        className={cn(
          "flex aspect-video justify-center text-xs [&_.recharts-cartesian-axis-tick_text]:fill-muted-foreground [&_.recharts-cartesian-grid_line[stroke='#ccc']]:stroke-border/50 [&_.recharts-curve.recharts-tooltip-cursor]:stroke-border [&_.recharts-dot[stroke='#fff']]:stroke-transparent [&_.recharts-layer]:outline-none [&_.recharts-polar-grid_[stroke='#ccc']]:stroke-border [&_.recharts-radial-bar-background-sector]:fill-muted [&_.recharts-rectangle.recharts-tooltip-cursor]:fill-muted [&_.recharts-reference-line_[stroke='#ccc']]:stroke-border [&_.recharts-sector[stroke='#fff']]:stroke-transparent [&_.recharts-sector]:outline-none [&_.recharts-surface]:outline-none",
          className
        )}
        {...props}>
        <ChartStyle id={chartId} config={config} />
        <RechartsPrimitive.ResponsiveContainer>
          {children}
        </RechartsPrimitive.ResponsiveContainer>
      </div>
    </ChartContext.Provider>
  );
})
ChartContainer.displayName = "Chart"

const ChartStyle = ({
  id,
  config
}) => {
  const colorConfig = Object.entries(config).filter(([, config]) => config.theme || config.color)

  if (!colorConfig.length) {
    return null
  }

  return (
    <style
      dangerouslySetInnerHTML={{
        __html: Object.entries(THEMES)
          .map(([theme, prefix]) => `
${prefix} [data-chart=${id}] {
${colorConfig
.map(([key, itemConfig]) => {
const color =
  itemConfig.theme?.[theme] ||
  itemConfig.color
return color ? `  --color-${key}: ${color};` : null
})
.join("\n")}
}
`)
          .join("\n"),
      }} />
  );
}

const ChartTooltip = RechartsPrimitive.Tooltip

const ChartTooltipContent = React.forwardRef((
  {
    active,
    payload,
    className,
    indicator = "dot",
    hideLabel = false,
    hideIndicator = false,
    label,
    labelFormatter,
    labelClassName,
    formatter,
    color,
    nameKey,
    labelKey,
  },
  ref
) => {
  const { config } = useChart()

  const tooltipLabel = React.useMemo(() => {
    if (hideLabel || !payload?.length) {
      return null
    }

    const [item] = payload
    const key = `${labelKey || item?.dataKey || item?.name || "value"}`
    const itemConfig = getPayloadConfigFromPayload(config, item, key)
    const value =
      !labelKey && typeof label === "string"
        ? config[label]?.label || label
        : itemConfig?.label

    if (labelFormatter) {
      return (
        <div className={cn("font-medium", labelClassName)}>
          {labelFormatter(value, payload)}
        </div>
      );
    }

    if (!value) {
      return null
    }

    return <div className={cn("font-medium", labelClassName)}>{value}</div>;
  }, [
    label,
    labelFormatter,
    payload,
    hideLabel,
    labelClassName,
    config,
    labelKey,
  ])

  if (!active || !payload?.length) {
    return null
  }

  const nestLabel = payload.length === 1 && indicator !== "dot"

  return (
    <div
      ref={ref}
      className={cn(
        "grid min-w-[8rem] items-start gap-1.5 rounded-lg border border-border/50 bg-background px-2.5 py-1.5 text-xs shadow-xl",
        className
      )}>
      {!nestLabel ? tooltipLabel : null}
      <div className="grid gap-1.5">
        {payload.map((item, index) => {
          const key = `${nameKey || item.name || item.dataKey || "value"}`
          const itemConfig = getPayloadConfigFromPayload(config, item, key)
          const indicatorColor = color || item.payload.fill || item.color

          return (
            <div
              key={item.dataKey}
              className={cn(
                "flex w-full flex-wrap items-stretch gap-2 [&>svg]:h-2.5 [&>svg]:w-2.5 [&>svg]:text-muted-foreground",
                indicator === "dot" && "items-center"
              )}>
              {formatter && item?.value !== undefined && item.name ? (
                formatter(item.value, item.name, item, index, item.payload)
              ) : (
                <>
                  {itemConfig?.icon ? (
                    <itemConfig.icon />
                  ) : (
                    !hideIndicator && (
                      <div
                        className={cn("shrink-0 rounded-[2px] border-[--color-border] bg-[--color-bg]", {
                          "h-2.5 w-2.5": indicator === "dot",
                          "w-1": indicator === "line",
                          "w-0 border-[1.5px] border-dashed bg-transparent":
                            indicator === "dashed",
                          "my-0.5": nestLabel && indicator === "dashed",
                        })}
                        style={
                          {
                            "--color-bg": indicatorColor,
                            "--color-border": indicatorColor
                          }
                        } />
                    )
                  )}
                  <div
                    className={cn(
                      "flex flex-1 justify-between leading-none",
                      nestLabel ? "items-end" : "items-center"
                    )}>
                    <div className="grid gap-1.5">
                      {nestLabel ? tooltipLabel : null}
                      <span className="text-muted-foreground">
                        {itemConfig?.label || item.name}
                      </span>
                    </div>
                    {item.value && (
                      <span className="font-mono font-medium tabular-nums text-foreground">
                        {item.value.toLocaleString()}
                      </span>
                    )}
                  </div>
                </>
              )}
            </div>
          );
        })}
      </div>
    </div>
  );
})
ChartTooltipContent.displayName = "ChartTooltip"

const ChartLegend = RechartsPrimitive.Legend

const ChartLegendContent = React.forwardRef((
  { className, hideIcon = false, payload, verticalAlign = "bottom", nameKey },
  ref
) => {
  const { config } = useChart()

  if (!payload?.length) {
    return null
  }

  return (
    <div
      ref={ref}
      className={cn(
        "flex items-center justify-center gap-4",
        verticalAlign === "top" ? "pb-3" : "pt-3",
        className
      )}>
      {payload.map((item) => {
        const key = `${nameKey || item.dataKey || "value"}`
        const itemConfig = getPayloadConfigFromPayload(config, item, key)

        return (
          <div
            key={item.value}
            className={cn(
              "flex items-center gap-1.5 [&>svg]:h-3 [&>svg]:w-3 [&>svg]:text-muted-foreground"
            )}>
            {itemConfig?.icon && !hideIcon ? (
              <itemConfig.icon />
            ) : (
              <div
                className="h-2 w-2 shrink-0 rounded-[2px]"
                style={{
                  backgroundColor: item.color,
                }} />
            )}
            {itemConfig?.label}
          </div>
        );
      })}
    </div>
  );
})
ChartLegendContent.displayName = "ChartLegend"

// Helper to extract item config from a payload.
function getPayloadConfigFromPayload(
  config,
  payload,
  key
) {
  if (typeof payload !== "object" || payload === null) {
    return undefined
  }

  const payloadPayload =
    "payload" in payload &&
    typeof payload.payload === "object" &&
    payload.payload !== null
      ? payload.payload
      : undefined

  let configLabelKey = key

  if (
    key in payload &&
    typeof payload[key] === "string"
  ) {
    configLabelKey = payload[key]
  } else if (
    payloadPayload &&
    key in payloadPayload &&
    typeof payloadPayload[key] === "string"
  ) {
    configLabelKey = payloadPayload[key]
  }

  return configLabelKey in config
    ? config[configLabelKey]
    : config[key];
}

export {
  ChartContainer,
  ChartTooltip,
  ChartTooltipContent,
  ChartLegend,
  ChartLegendContent,
  ChartStyle,
}


============================================================


📄 Arquivo : input.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/input.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"

import { cn } from "@/lib/utils"

const Input = React.forwardRef(({ className, type, ...props }, ref) => {
  return (
    <input
      type={type}
      className={cn(
        "flex h-10 w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background file:border-0 file:bg-transparent file:text-sm file:font-medium file:text-foreground placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props} />
  );
})
Input.displayName = "Input"

export { Input }


============================================================


📄 Arquivo : label.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/label.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"
import * as LabelPrimitive from "@radix-ui/react-label"
import { cva } from "class-variance-authority";

import { cn } from "@/lib/utils"

const labelVariants = cva(
  "text-sm font-medium leading-none peer-disabled:cursor-not-allowed peer-disabled:opacity-70"
)

const Label = React.forwardRef(({ className, ...props }, ref) => (
  <LabelPrimitive.Root ref={ref} className={cn(labelVariants(), className)} {...props} />
))
Label.displayName = LabelPrimitive.Root.displayName

export { Label }


============================================================


📄 Arquivo : radio-group.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/radio-group.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"
import * as RadioGroupPrimitive from "@radix-ui/react-radio-group"
import { Circle } from "lucide-react"

import { cn } from "@/lib/utils"

const RadioGroup = React.forwardRef(({ className, ...props }, ref) => {
  return (<RadioGroupPrimitive.Root className={cn("grid gap-2", className)} {...props} ref={ref} />);
})
RadioGroup.displayName = RadioGroupPrimitive.Root.displayName

const RadioGroupItem = React.forwardRef(({ className, ...props }, ref) => {
  return (
    <RadioGroupPrimitive.Item
      ref={ref}
      className={cn(
        "aspect-square h-4 w-4 rounded-full border border-primary text-primary ring-offset-background focus:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50",
        className
      )}
      {...props}>
      <RadioGroupPrimitive.Indicator className="flex items-center justify-center">
        <Circle className="h-2.5 w-2.5 fill-current text-current" />
      </RadioGroupPrimitive.Indicator>
    </RadioGroupPrimitive.Item>
  );
})
RadioGroupItem.displayName = RadioGroupPrimitive.Item.displayName

export { RadioGroup, RadioGroupItem }


============================================================


📄 Arquivo : skeleton.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/skeleton.jsx
--------------------------------------
📜 Conteúdo:

import { cn } from "@/lib/utils"

function Skeleton({
  className,
  ...props
}) {
  return (<div className={cn("animate-pulse rounded-md bg-muted", className)} {...props} />);
}

export { Skeleton }


============================================================


📄 Arquivo : textarea.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/textarea.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"

import { cn } from "@/lib/utils"

const Textarea = React.forwardRef(({ className, ...props }, ref) => {
  return (
    <textarea
      className={cn(
        "flex min-h-[80px] w-full rounded-md border border-input bg-background px-3 py-2 text-base ring-offset-background placeholder:text-muted-foreground focus-visible:outline-none focus-visible:ring-2 focus-visible:ring-ring focus-visible:ring-offset-2 disabled:cursor-not-allowed disabled:opacity-50 md:text-sm",
        className
      )}
      ref={ref}
      {...props} />
  );
})
Textarea.displayName = "Textarea"

export { Textarea }


============================================================


📄 Arquivo : toast.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/toast.jsx
--------------------------------------
📜 Conteúdo:

import * as React from "react"
import * as ToastPrimitives from "@radix-ui/react-toast"
import { cva } from "class-variance-authority";
import { X } from "lucide-react"

import { cn } from "@/lib/utils"

const ToastProvider = ToastPrimitives.Provider

const ToastViewport = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Viewport
    ref={ref}
    className={cn(
      "fixed top-0 z-[100] flex max-h-screen w-full flex-col-reverse p-4 sm:bottom-0 sm:right-0 sm:top-auto sm:flex-col md:max-w-[420px]",
      className
    )}
    {...props} />
))
ToastViewport.displayName = ToastPrimitives.Viewport.displayName

const toastVariants = cva(
  "group pointer-events-auto relative flex w-full items-center justify-between space-x-4 overflow-hidden rounded-md border p-6 pr-8 shadow-lg transition-all data-[swipe=cancel]:translate-x-0 data-[swipe=end]:translate-x-[var(--radix-toast-swipe-end-x)] data-[swipe=move]:translate-x-[var(--radix-toast-swipe-move-x)] data-[swipe=move]:transition-none data-[state=open]:animate-in data-[state=closed]:animate-out data-[swipe=end]:animate-out data-[state=closed]:fade-out-80 data-[state=closed]:slide-out-to-right-full data-[state=open]:slide-in-from-top-full data-[state=open]:sm:slide-in-from-bottom-full",
  {
    variants: {
      variant: {
        default: "border bg-background text-foreground",
        destructive:
          "destructive group border-destructive bg-destructive text-destructive-foreground",
      },
    },
    defaultVariants: {
      variant: "default",
    },
  }
)

const Toast = React.forwardRef(({ className, variant, ...props }, ref) => {
  return (
    <ToastPrimitives.Root
      ref={ref}
      className={cn(toastVariants({ variant }), className)}
      {...props} />
  );
})
Toast.displayName = ToastPrimitives.Root.displayName

const ToastAction = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Action
    ref={ref}
    className={cn(
      "inline-flex h-8 shrink-0 items-center justify-center rounded-md border bg-transparent px-3 text-sm font-medium ring-offset-background transition-colors hover:bg-secondary focus:outline-none focus:ring-2 focus:ring-ring focus:ring-offset-2 disabled:pointer-events-none disabled:opacity-50 group-[.destructive]:border-muted/40 group-[.destructive]:hover:border-destructive/30 group-[.destructive]:hover:bg-destructive group-[.destructive]:hover:text-destructive-foreground group-[.destructive]:focus:ring-destructive",
      className
    )}
    {...props} />
))
ToastAction.displayName = ToastPrimitives.Action.displayName

const ToastClose = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Close
    ref={ref}
    className={cn(
      "absolute right-2 top-2 rounded-md p-1 text-foreground/50 opacity-0 transition-opacity hover:text-foreground focus:opacity-100 focus:outline-none focus:ring-2 group-hover:opacity-100 group-[.destructive]:text-red-300 group-[.destructive]:hover:text-red-50 group-[.destructive]:focus:ring-red-400 group-[.destructive]:focus:ring-offset-red-600",
      className
    )}
    toast-close=""
    {...props}>
    <X className="h-4 w-4" />
  </ToastPrimitives.Close>
))
ToastClose.displayName = ToastPrimitives.Close.displayName

const ToastTitle = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Title ref={ref} className={cn("text-sm font-semibold", className)} {...props} />
))
ToastTitle.displayName = ToastPrimitives.Title.displayName

const ToastDescription = React.forwardRef(({ className, ...props }, ref) => (
  <ToastPrimitives.Description ref={ref} className={cn("text-sm opacity-90", className)} {...props} />
))
ToastDescription.displayName = ToastPrimitives.Description.displayName

export { ToastProvider, ToastViewport, Toast, ToastTitle, ToastDescription, ToastClose, ToastAction };


============================================================


📄 Arquivo : colors.js
📂 Pasta   : config
🧭 Caminho : config/colors.js
--------------------------------------
📜 Conteúdo:

export const VARIANTS = {
  // Verdes
  verde: "text-white bg-emerald-500 border-emerald-600 hover:bg-emerald-600",

  // Vermelhos
  vermelho: "text-white bg-rose-600 border-rose-700 hover:bg-rose-700 shadow-sm",

  // Azuis
  azul_claro: "text-sky-700 bg-sky-100 border-sky-300 hover:bg-sky-200",
  azul_escuro: "text-white bg-sky-600 border-sky-700 hover:bg-sky-700 shadow-sm",

  // Cinzas / Neutros
  cinza: "text-gray-800 bg-gray-200 border-gray-300 hover:bg-gray-300",
  light: "text-gray-800 bg-gray-100 border-gray-200 hover:bg-gray-200",
  dark: "text-white bg-black border-gray-500 hover:bg-gray-800",

  // Transparentes com identidade
  transparent_azul: "text-sky-600 bg-transparent border-none hover:bg-sky-50",
  transparent_vermelho: "text-rose-600 bg-transparent border-none hover:bg-rose-50",
  transparent_verde: "text-emerald-600 bg-transparent border-none hover:bg-emerald-50",
  transparent_cinza: "text-gray-600 bg-transparent border-none hover:bg-gray-100",

  // Branding e utilidades
  primary: "text-white bg-indigo-600 border-indigo-700 hover:bg-indigo-700 shadow-sm",
  secondary: "text-white bg-gray-600 border-gray-700 hover:bg-gray-700",
  warning: "text-white bg-amber-500 border-amber-600 hover:bg-amber-600",
};


============================================================


📄 Arquivo : data_types.js
📂 Pasta   : config
🧭 Caminho : config/data_types.js
--------------------------------------
📜 Conteúdo:




export const USER_ROLES = ["admin", "researcher"]


export const USER_STATUS = ["active", "inactive"]







============================================================


📄 Arquivo : routes.js
📂 Pasta   : config
🧭 Caminho : config/routes.js
--------------------------------------
📜 Conteúdo:

export const PUBLIC_PAGES = ["/login", "/forgot-password", "/validate-code"];


export const PUBLIC_APIS = [
  "/api/auth/login",
  "/api/auth/forgot-password",
  "/api/auth/validate-code",
];

export const AUTHENTICATED_PAGES = [
  "/create",
  "/users",
  "/dashboard",
  "/",
];


export const ROLE_PERMISSIONS = {
  admin: [],
  research: [],
};


============================================================


📄 Arquivo : tabs.js
📂 Pasta   : config
🧭 Caminho : config/tabs.js
--------------------------------------
📜 Conteúdo:

export const TABS = {
  Dashboard: {
    link: "/",
    icon: "dashboard",
  },
  Usuários: {
    link: "/users",
    icon: "group",
  },
  Pesquisas: {
    icon: "app_registration",
    subTabs: {
      "Pesquisas": {
        link: "/researches",
        icon: "pending_actions",
      },
      "Criar pesquisa": {
        link: "/researches/create",
        icon: "add",
      },
    },
  },
  // Relatórios: {
  //   link: "/reports",
  //   icon: "analytics",
  // },
};

export const PERMISSION_TABS = {
  admin: ["Usuários", "Criar pesquisa"],
  research: [],
};

export const TABSTYLES = {
  active: "text-white bg-black border-gray-800 hover:bg-gray-800",
  inactive: "text-gray-700 border-gray-200 hover:bg-gray-100 shadow-sm transition-colors",
};


============================================================


📄 Arquivo : AuthContext.jsx
📂 Pasta   : context
🧭 Caminho : context/AuthContext.jsx
--------------------------------------
📜 Conteúdo:

// src/context/AuthContext.jsx
import React, { createContext, useContext, useEffect, useState } from 'react';
import { getAuth, saveAuth, deleteAuth } from '@/lib/db';

// Contexto de autenticação usando IndexedDB (store "auth")
export const AuthContext = createContext();

export function AuthProvider({ children }) {
  const [userData, setUserData] = useState(null);
  const [loading, setLoading] = useState(true);

  useEffect(() => {
    (async () => {
      try {
        const stored = await getAuth();
        if (stored?.user) {
          setUserData(stored.user);
        }
      } catch (err) {
        console.error('Erro ao ler auth do IndexedDB:', err);
      } finally {
        setLoading(false);
      }
    })();
  }, []);

  const persistAuth = async ({ user, token }) => {
    try {
      await saveAuth({ id: 'current', user, token });
      setUserData(user);
    } catch (err) {
      console.error('Erro ao salvar auth:', err);
    }
  };
  
  const clearAuth = async () => {
    try {
      await deleteAuth();
      setUserData(null);
    } catch (err) {
      console.error('Erro ao deletar auth:', err);
    }
  };

  return (
    <AuthContext.Provider
      value={{ userData, setUserData, loading, persistAuth, clearAuth }}
    >
      {children}
    </AuthContext.Provider>
  );
}

export function useAuth() {
  const ctx = useContext(AuthContext);
  if (!ctx) throw new Error('useAuth must be used within AuthProvider');
  return ctx;
}

============================================================


📄 Arquivo : LoadingContext.jsx
📂 Pasta   : context
🧭 Caminho : context/LoadingContext.jsx
--------------------------------------
📜 Conteúdo:

import { createContext, useState, useContext } from "react";

const LoadingContext = createContext();

export function LoadingContextProvider({ children }) {
  const [isLoading, setIsLoading] = useState(false);

  return (
    <LoadingContext.Provider value={{ isLoading, setIsLoading }}>
      {children}
    </LoadingContext.Provider>
  );
}
export function useLoading() {
  return useContext(LoadingContext);
}


============================================================


📄 Arquivo : MessageContext.jsx
📂 Pasta   : context
🧭 Caminho : context/MessageContext.jsx
--------------------------------------
📜 Conteúdo:

import { createContext, useContext, useState } from "react";
import Message from "@/components/ui/Message";


const MessageContext = createContext();

export function MessageProvider({ children }) {
  const [message, setMessage] = useState("");
  const [variant, setVariant] = useState("info");
  const [show, setShow] = useState(false);

  const showMessage = (msg, type = "info", duration = 3000) => {
    setMessage(msg);
    setVariant(type);
    setShow(true);

    setTimeout(() => {
      setShow(false);
    }, duration);
  };

  return (
    <MessageContext.Provider value={{ showMessage }}>
      {children}
      <Message message={message} variant={variant} show={show} />
    </MessageContext.Provider>
  );
}

export function useMessage() {
  return useContext(MessageContext);
}



============================================================


📄 Arquivo : index.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/index.ts
--------------------------------------
📜 Conteúdo:

export * from './useUsers';
export * from './useFields';
export * from './useResearches';
export * from './useSurveyTimeRanges';
export * from './useSurveyRegions';
export * from './useSurveyGroups';
export * from './useSurveyContributors';
export * from './useStaticSurveys';
export * from './useFormSurveys';
export * from './useDynamicSurveys';
export * from './useResearchContributors';
export * from './useInputTypes';
export * from './useFieldOptions';
export * from './useSurveyAnswers';
export * from './useAuthentication'


============================================================


📄 Arquivo : useAuthentication.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useAuthentication.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useAuthentication.ts
import { useContext, useState, useEffect, useCallback } from 'react';
import { AuthContext } from '@/context/AuthContext';
import { saveAuth, getAuth, deleteAuth } from '@/lib/db';

// Simplified user type (adjust fields as per your API)
type AuthUser = {
  id: string;
  name: string;
  email: string;
  role?: string;
  [key: string]: any;
};

// Payloads for auth actions
type LoginPayload = { email: string; password: string };
type RegisterPayload = { name: string; email: string; password: string; role?: string; status?: string };

type AccessToken = {
  created_at: string;
  expires_at: string;
  token: string;
  token_type: string;
}

// Shape of the response from the auth API
interface AuthResponse {
  access_token: AccessToken;
  user: AuthUser;
  
}

interface UseAuthenticationReturn {
  user: AuthUser | null;
  isAuthenticated: boolean;
  isInitialising: boolean;
  error: string | null;
  login: (email: string, password: string) => Promise<AuthUser>;
  register: (payload: RegisterPayload) => Promise<AuthUser>;
  logout: () => Promise<void>;
}

export function useAuthentication(): UseAuthenticationReturn {
  const { userData, setUserData } = useContext(AuthContext);
  const [isInitialising, setIsInitialising] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  // Centraliza captura de erros
  const withErrorHandler = <T extends any[]>(fn: (...args: T) => Promise<any>) =>
    async (...args: T) => {
      setError(null);
      try {
        return await fn(...args);
      } catch (err: any) {
        const message = err?.message || 'Erro inesperado';
        setError(message);
        throw err;
      }
    };

  // Fetch wrapper
  const fetchJson = async <T>(url: string, options: RequestInit = {}): Promise<T> => {
    const res = await fetch(url, {
      headers: { 'Content-Type': 'application/json' },
      credentials: 'include',
      ...options,
    });
    if (!res.ok) {
      const body = await res.json().catch(() => ({}));
      throw new Error(body.error || `HTTP ${res.status}`);
    }
    return res.json();
  };

  const login = useCallback(
    withErrorHandler(async (email: string, password: string) => {
      const data = await fetchJson<AuthResponse>('/api/auth/login', {
        method: 'POST',
        body: JSON.stringify({ email, password }),
      });

      setUserData(data.user);
      await saveAuth({ id: 'current', user: data.user, token: data.access_token.token, created_at: data.access_token.created_at, expiresAt: data.access_token.expires_at });
      return data.user;
    }),
    [setUserData]
  );

  const register = useCallback(
    withErrorHandler(async (payload: RegisterPayload) => {
      const data = await fetchJson<AuthResponse>('/api/auth/register', {
        method: 'POST',
        body: JSON.stringify(payload),
      });
      return data.user;
    }),
    []
  );

  const logout = useCallback(
    withErrorHandler(async () => {
      try {
        await fetch('/api/auth/logout', { method: 'POST' });
      } catch {
        // silencioso se offline
      }
      setUserData(null);
      await deleteAuth();
    }),
    [setUserData]
  );



  // Tenta restaurar sessão do IndexedDB na inicialização
  useEffect(() => {
    (async () => {
      try {
        const stored = await getAuth();
        if (stored?.user && stored?.token) {
          setUserData(stored.user);
        }
      } catch (err) {
        console.error('Erro ao carregar auth do IndexedDB:', err);
      } finally {
        setIsInitialising(false);
      }
    })();
  }, [setUserData]);

  const isAuthenticated = Boolean(userData);

  return {
    user: userData,
    isAuthenticated,
    isInitialising,
    error,
    login,
    register,
    logout
  };
}


============================================================


📄 Arquivo : useDynamicSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useDynamicSurveys.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useDynamicSurveys.ts
import { useEffect, useState } from "react";
import { DynamicSurvey } from "@/lib/types/indexeddb";
import {
  createDynamicSurvey as createRemoteDynamicSurvey,
  getDynamicSurvey as getRemoteDynamicSurvey,
  updateDynamicSurvey as updateRemoteDynamicSurvey,
  deleteDynamicSurvey as deleteRemoteDynamicSurvey,
} from "@/repositories/server/dynamicSurveyApi";

import {
  createDynamicSurvey as createLocalDynamicSurvey,
  getDynamicSurvey as getLocalDynamicSurvey,
  updateDynamicSurvey as updateLocalDynamicSurvey,
  deleteDynamicSurvey as deleteLocalDynamicSurvey,
} from "@/repositories/indexeddb/dynamicSurveyRepository";

import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";
import dynamic from "next/dynamic";

export function useDynamicSurveys(
  research_id?: string,
  especifico: boolean = true,
  survey_type: string = "Dinâmica"
) {
  const [dynamicSurvey, setDynamicSurveyData] = useState<DynamicSurvey | null>(null);
  const [unSyncedSurveys, setUnSyncedSurveys] = useState<DynamicSurvey[]>([]);
  const [loadingSurveys, setLoadingSurveys] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedSurveys();
  }, []);

  useEffect(() => {
    if (especifico && research_id) {
      fetchSurveyByResearch(research_id, survey_type);
    } else {
      setDynamicSurveyData(null);
      setLoadingSurveys(false);
    }
  }, [especifico, research_id, survey_type]);

  const fetchUnsyncedSurveys = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const surveysPending = unsynced
        .filter((item) => item.store === "dynamic_surveys")
        .map((item) => item.payload as DynamicSurvey);
      setUnSyncedSurveys(surveysPending);
    } catch (error) {
      console.error("[App] Erro ao carregar dynamic surveys pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchSurveyByResearch = async (researchId: string, type: string) => {
    setLoadingSurveys(true);
    try {
      const remote = await getRemoteDynamicSurvey(researchId, type);
      // console.log("[App] Surveys do servidor:", remote);
      const survey = remote;
      setDynamicSurveyData(survey);

      if (survey) {
        await createLocalDynamicSurvey(survey);
      }
    } catch (err) {
      console.warn("[App] Falha ao buscar do servidor, tentando local:", err);
      try {
        const local = await getLocalDynamicSurvey(researchId);
        setDynamicSurveyData(local || null);
      } catch (errLocal) {
        console.error("[App] Falha ao buscar local:", errLocal);
        setError("Erro ao carregar dynamic survey local");
      }
    } finally {
      setLoadingSurveys(false);
    }
  };

  const addDynamicSurvey = async (survey: DynamicSurvey): Promise<DynamicSurvey> => {
    const newSurveyId = uuidv4();
    const localSurvey: DynamicSurvey = { ...survey, id: newSurveyId };

    setDynamicSurveyData(localSurvey);

    try {
      const created = await createRemoteDynamicSurvey(survey);
      await createLocalDynamicSurvey(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar remotamente:", error);
      setError("Falha ao salvar no servidor. Salvo localmente.");
      await saveUnsyncedItem("dynamic_surveys", localSurvey);
      setUnSyncedSurveys((prev) => [...prev, localSurvey]);
      return localSurvey;
    }
  };

  const updateDynamicSurvey = async (id: string, updatedData: DynamicSurvey) => {
    await updateLocalDynamicSurvey(id, updatedData);
    setDynamicSurveyData((prev) => (prev ? { ...prev, ...updatedData } : updatedData));

    try {
      await updateRemoteDynamicSurvey({ ...updatedData, id });
    } catch (error) {
      console.error("[App] Falha ao sincronizar update:", error);
      await saveUnsyncedItem("dynamic_surveys", { ...updatedData, id });
      setUnSyncedSurveys((prev) => [...prev, { ...updatedData, id }]);
    }
  };

  const deleteDynamicSurvey = async (id: string) => {
    setDynamicSurveyData(null);

    try {
      await deleteLocalDynamicSurvey(id);
      await deleteRemoteDynamicSurvey({ id } as DynamicSurvey);
    } catch (error) {
      console.error("[App] Erro ao deletar dynamic survey:", error);
      await saveUnsyncedItem("dynamic_surveys", { id, delete: true } as any);
    }
  };

  return {
    dynamicSurvey,
    unSyncedSurveys,
    loading: loadingSurveys || loadingUnsynced,
    loadingSurveys,
    loadingUnsynced,
    error,
    addDynamicSurvey,
    updateDynamicSurvey,
    deleteDynamicSurvey,
  };
}


============================================================


📄 Arquivo : useFieldOptions.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFieldOptions.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { FieldOption } from "@/lib/types/indexeddb";
import {
  getFieldOptions as getRemoteOptions,
  createFieldOption as createRemoteOption,
  updateFieldOption as updateRemoteOption,
  deleteFieldOption as deleteRemoteOption,
} from "@/repositories/server/fieldOptionApi";
import {
  createFieldOption as createLocalOption,
  getAllFieldOptions as getAllLocalOptions,
  updateFieldOption as updateLocalOption,
  deleteFieldOption as deleteLocalOption,
} from "@/repositories/indexeddb/fieldOptionRepository";
import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useFieldOptions(field_id: string) {
  const [options, setOptions] = useState<FieldOption[]>([]);
  const [unSyncedOptions, setUnSyncedOptions] = useState<FieldOption[]>([]);
  const [loadingOptions, setLoadingOptions] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedOptions();
  }, []);

  useEffect(() => {
    if (field_id) fetchOptions();
  }, [field_id]);

  const fetchUnsyncedOptions = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "field_options")
        .map((item) => item.payload as FieldOption);
      setUnSyncedOptions(pending);
    } catch (error) {
      console.error("[App] Erro ao carregar opções pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchOptions = async () => {
    setLoadingOptions(true);
    try {
      const remoteOptions = await getRemoteOptions(field_id);
      setOptions(remoteOptions);
      await Promise.allSettled(remoteOptions.map((opt) => createLocalOption(opt)));
    } catch (err) {
      console.warn("[App] Falha ao buscar opções do servidor. Usando IndexedDB local.", err);
      try {
        const localOptions = await getAllLocalOptions();
        setOptions(localOptions.filter((o) => o.field_id === field_id));
      } catch (errLocal) {
        console.error("[App] Falha ao carregar opções locais:", errLocal);
        setError("Erro ao carregar opções locais");
      }
    } finally {
      setLoadingOptions(false);
    }
  };

  const addOption = async (option: Omit<FieldOption, "id">): Promise<FieldOption> => {
    const newOption: FieldOption = { ...option, id: uuidv4(), field_id };
    setOptions((prev) => [...prev, newOption]);

    try {
      const created = await createRemoteOption(field_id, option);
      await createLocalOption(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar opção remotamente:", error);
      setError("Falha ao salvar no servidor. Salvo localmente.");
      await saveUnsyncedItem("field_options", newOption);
      setUnSyncedOptions((prev) => [...prev, newOption]);
      await createLocalOption(newOption);
      return newOption;
    }
  };

  const updateOption = async (optionId: string, updatedData: Partial<FieldOption>) => {
    const updated: FieldOption = { ...updatedData, id: optionId, field_id } as FieldOption;
    await updateLocalOption(optionId, updated);

    setOptions((prev) =>
      prev.map((o) => (o.id === optionId ? { ...o, ...updatedData } : o))
    );

    try {
      await updateRemoteOption(field_id, optionId, updatedData);
    } catch (error) {
      console.error("[App] Erro ao atualizar opção remotamente:", error);
      setError("Falha ao sincronizar atualização.");
      await saveUnsyncedItem("field_options", updated);
      setUnSyncedOptions((prev) => [...prev, updated]);
    }
  };

  const deleteOption = async (optionId: string) => {
    await deleteLocalOption(optionId);
    setOptions((prev) => prev.filter((o) => o.id !== optionId));

    try {
      await deleteRemoteOption(field_id, optionId);
    } catch (error) {
      console.error("[App] Erro ao deletar opção remotamente:", error);
      setError("Falha ao sincronizar exclusão.");
      await saveUnsyncedItem("field_options", { id: optionId, field_id });
    }
  };

  return {
    options,
    unSyncedOptions,
    loading: loadingOptions || loadingUnsynced,
    loadingOptions,
    loadingUnsynced,
    error,
    addOption,
    updateOption,
    deleteOption,
  };
}

============================================================


📄 Arquivo : useFields.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFields.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { Field } from "@/lib/types/indexeddb";
import {
  getFields as getRemoteFields,
  createField as createRemoteField,
  updateField as updateRemoteField,
  deleteField as deleteRemoteField,
} from "@/repositories/server/fieldApi";
import {
  createField as createLocalField,
  getAllFields as getAllLocalFields,
  updateField as updateLocalField,
  deleteField as deleteLocalField,
} from "@/repositories/indexeddb/fieldRepository";
import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useFields(survey_id: string, survey_type: string) {
  const [fields, setFields] = useState<Field[]>([]);
  const [unSyncedFields, setUnSyncedFields] = useState<Field[]>([]);
  const [loadingFields, setLoadingFields] = useState<boolean>(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedFields();
  }, []);

  useEffect(() => {
    if (survey_id && survey_type) {
      fetchFields();
    }
  }, [survey_id, survey_type]);

  const fetchUnsyncedFields = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "fields")
        .map((item) => item.payload as Field);
      setUnSyncedFields(pending);
    } catch (error) {
      console.error("[App] Erro ao carregar campos pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchFields = async () => {
    setLoadingFields(true);
    try {
      const remoteFields = await getRemoteFields(survey_id, survey_type);
      // console.log("[App] Campos do servidor:", remoteFields);
      setFields(remoteFields);
      await Promise.allSettled(remoteFields.map((field) => createLocalField(field)));
    } catch (err) {
      console.warn("[App] Falha ao buscar campos do servidor. Usando IndexedDB local.", err);
      try {
        const localFields = await getAllLocalFields();
        setFields(localFields);
      } catch (errLocal) {
        console.error("[App] Falha ao carregar campos locais:", errLocal);
        setError("Erro ao carregar campos locais");
      }
    } finally {
      setLoadingFields(false);
    }
  };

  const addField = async (field: Omit<Field, "id">): Promise<Field> => {
    const newField: Field = {
      ...field,
      id: uuidv4(),
      survey_id,
    };

    setFields((prev) => [...prev, newField]);

    try {
      const created = await createRemoteField(survey_id, survey_type, field);
      await createLocalField(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar campo remotamente:", error);
      setError("Falha ao salvar no servidor. Salvo localmente para sincronizar depois.");
      await saveUnsyncedItem("fields", newField);
      setUnSyncedFields((prev) => [...prev, newField]);
      await createLocalField(newField);
      return newField;
    }
  };

  const updateField = async (id: string, updatedData: Field) => {
    await updateLocalField(id, updatedData);

    setFields((prev) =>
      prev.map((f) => (f.id === id ? { ...f, ...updatedData } : f))
    );

    try {
      await updateRemoteField(id, survey_id, survey_type, updatedData);
    } catch (error) {
      console.error("[App] Erro ao atualizar campo:", error);
      setError("Falha ao sincronizar atualização.");
      await saveUnsyncedItem("fields", { ...updatedData, id, survey_id });
      setUnSyncedFields((prev) => [...prev, { ...updatedData, id, survey_id }]);
    }
  };

  const deleteField = async (id: string) => {
    await deleteLocalField(id);
    setFields((prev) => prev.filter((f) => f.id !== id));

    try {
      await deleteRemoteField(id, survey_id, survey_type);
    } catch (error) {
      console.error("[App] Erro ao deletar campo:", error);
      setError("Falha ao sincronizar exclusão.");
      await saveUnsyncedItem("fields", { id, survey_id });
    }
  };

  return {
    fields,
    unSyncedFields,
    loading: loadingFields || loadingUnsynced,
    loadingFields,
    loadingUnsynced,
    error,
    addField,
    updateField,
    deleteField,
  };
}


============================================================


📄 Arquivo : useFormSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFormSurveys.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useFormSurveys.ts
import { useEffect, useState } from "react";
import { FormSurvey } from "@/lib/types/indexeddb";
import {
  deleteFormSurvey as deleteRemoteFormSurvey,
  createFormSurvey as createRemoteFormSurvey,
  getFormSurvey as getRemoteFormSurvey,
  updateFormSurvey as updateRemoteFormSurvey,
} from "@/repositories/server/formSurveyApi";

import {
  createFormSurvey as createLocalFormSurvey,
  getAllFormSurveys as getAllLocalFormSurveys,
  getFormSurvey as getLocalFormSurvey,
  updateFormSurvey as updateLocalFormSurvey,
  deleteFormSurvey as deleteLocalFormSurvey,
} from "@/repositories/indexeddb/formSurveyRepository";

import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useFormSurveys(
  research_id?: string,
  especifico: boolean = true,
  survey_type: string = "Formulário"
) {
  const [formSurvey, setFormSurvey] = useState<FormSurvey | null>(null);
  const [unSyncedSurveys, setUnSyncedSurveys] = useState<FormSurvey[]>([]);
  const [loadingSurveys, setLoadingSurveys] = useState<boolean>(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedSurveys();
  }, []);

  useEffect(() => {
    if (especifico && research_id) {
      fetchSurveyByResearchAndType(research_id, survey_type);
    } else {
      setFormSurvey(null);
      setLoadingSurveys(false);
    }
  }, [especifico, research_id, survey_type]);

  const fetchUnsyncedSurveys = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const surveysPending = unsynced
        .filter((item) => item.store === "form_surveys")
        .map((item) => item.payload as FormSurvey);
      setUnSyncedSurveys(surveysPending);
    } catch (error) {
      console.error("[App] Erro ao carregar surveys pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchSurveyByResearchAndType = async (researchId: string, type: string) => {
    setLoadingSurveys(true);
    try {
      const remote = await getRemoteFormSurvey(researchId, type);
      // console.log("[App] Surveys do servidor:", remote);
      const survey = remote;
      setFormSurvey(survey);

      if (survey) {
        await createLocalFormSurvey(survey);
      }
    } catch (err) {
      console.warn("[App] Falha ao buscar do servidor, tentando local:", err);
      try {
        const local = await getLocalFormSurvey(researchId);
        setFormSurvey(local || null);
      } catch (errLocal) {
        console.error("[App] Falha ao buscar local:", errLocal);
        setError("Erro ao carregar coleta local");
      }
    } finally {
      setLoadingSurveys(false);
    }
  };

  const addFormSurvey = async (survey: FormSurvey): Promise<FormSurvey> => {
    const newSurveyId = uuidv4();
    const localSurvey: FormSurvey = { ...survey, id: newSurveyId };
    setFormSurvey(localSurvey);
    try {
      const created = await createRemoteFormSurvey(survey);
      await createLocalFormSurvey(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar remotamente:", error);
      setError("Falha ao salvar no servidor. Salvo localmente.");
      await saveUnsyncedItem("form_surveys", localSurvey);
      setUnSyncedSurveys((prev) => [...prev, localSurvey]);
      return localSurvey;
    }
  };

  const updateFormSurvey = async (id: string, updatedData: FormSurvey) => {
    await updateLocalFormSurvey(id, updatedData);
    setFormSurvey((prev) => prev ? { ...prev, ...updatedData } : updatedData);
    try {
      await updateRemoteFormSurvey({ ...updatedData, id });
    } catch (error) {
      console.error("[App] Falha ao sincronizar update:", error);
      setError("Atualização pendente de sincronização.");
      await saveUnsyncedItem("form_surveys", { ...updatedData, id });
      setUnSyncedSurveys((prev) => [...prev, { ...updatedData, id }]);
    }
  };

  const deleteFormSurvey = async (survey: FormSurvey) => {
    setFormSurvey(null);
    try {
      await deleteLocalFormSurvey(survey.id);
      await deleteRemoteFormSurvey(survey);
    } catch (error) {
      console.error("[App] Erro ao deletar form survey:", error);
      await saveUnsyncedItem("form_surveys", {...survey, deleted: true});
    }
  };
  

  return {
    formSurvey,
    unSyncedSurveys,
    loading: loadingSurveys || loadingUnsynced,
    loadingSurveys,
    loadingUnsynced,
    error,
    addFormSurvey,
    updateFormSurvey,
    deleteFormSurvey
  };
}


============================================================


📄 Arquivo : useInputTypes.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useInputTypes.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from 'react';
import { InputType } from '@/lib/types/indexeddb';
import { getInputTypes } from '@/repositories/server/inputTypeApi';
import { createInputType, getAllInputTypes } from '@/repositories/indexeddb';
import { getUnsyncedItems } from "@/lib/db";

export function useInputTypes() {
  const [types, setTypes] = useState<InputType[]>([]);
  const [unSyncedInputTypes, setUnSyncedInputTypes] = useState<InputType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const loadData = async () => {
      setLoading(true);
      await Promise.all([
        loadUnsyncedInputTypes(),
        loadInputTypesWithFallback()
      ]);
      setLoading(false);
    };

    loadData();
  }, []);

  const loadUnsyncedInputTypes = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "input_types")
        .map((item) => item.payload as InputType);
      setUnSyncedInputTypes(pending);
    } catch (err) {
      console.error("[useInputTypes] Falha ao carregar input_types não sincronizados:", err);
    }
  };

  const loadInputTypesWithFallback = async () => {
    try {
      const remote = await getInputTypes();
      // console.log("[useInputTypes] Dados remotos carregados:", remote);
      setTypes(remote);
      await Promise.allSettled(
        remote.map((type) => createInputType(type))
      );
    } catch (errRemote) {
      console.warn("[useInputTypes] Erro remoto. Tentando IndexedDB local:", errRemote);
      try {
        const local = await getAllInputTypes();
        setTypes(local);
      } catch (errLocal) {
        console.error("[useInputTypes] Falha ao carregar dados locais:", errLocal);
        setError("Erro ao carregar dados locais de input_types");
      }
    }
  };

  return { types, unSyncedInputTypes, loading, error };
}


============================================================


📄 Arquivo : useResearchContributors.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useResearchContributors.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from 'react';
import { ResearchContributor } from '@/lib/types/indexeddb';
import { 
  createResearchContributor as createRemoteResearchContributor, 
  getResearchContributors as getAllRemoteResearchContributors,
  deleteResearchContributor as deleteRemoteResearchContributor,
} from '@/repositories/server/researchContributorApi';
import { createItem, getAllItems, deleteItem } from '@/repositories/indexeddb/indexedDBService';
import { saveUnsyncedItem, getUnsyncedItems } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';
import { create } from 'domain';

type LocalResearchContributor = ResearchContributor & { _syncStatus?: 'pending' | 'synced' | 'error' };

export function useResearchContributors(researchId?: string) {
  const [contributors, setContributors] = useState<LocalResearchContributor[]>([]);
  const [unSyncedContributors, setUnSyncedContributors] = useState<LocalResearchContributor[]>([]);
  const [loadingContributors, setLoadingContributors] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedContributors();
  }, []);

  useEffect(() => {
    if (researchId) {
      fetchContributors(researchId);
    } else {
      setContributors([]);
      setLoadingContributors(false);
    }
  }, [researchId]);

  const fetchUnsyncedContributors = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "research_contributors")
        .map((item) => item.payload as LocalResearchContributor);
      setUnSyncedContributors(pending);
    } catch (err) {
      console.error("[App] Erro ao carregar colaboradores pendentes:", err);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchContributors = async (id: string) => {
    setLoadingContributors(true);
    try {
      const remoteContributors = await getAllRemoteResearchContributors(id);
      setContributors(remoteContributors.map(c => ({ ...c, _syncStatus: 'synced' })));
      await Promise.allSettled(
        remoteContributors.map(c => createItem('research_contributors', c))
      );
    } catch (err) {
      console.warn("[App] Falha ao buscar colaboradores do servidor. Usando IndexedDB local.", err);
      try {
        const localContributors = await getAllItems('research_contributors');
        const filteredContributors = localContributors.filter(c => c.research_id === id);
        setContributors(filteredContributors);
      } catch (errLocal) {
        console.error("[App] Falha ao carregar colaboradores locais:", errLocal);
        setError("Erro ao carregar colaboradores locais");
      }
    } finally {
      setLoadingContributors(false);
    }
  };

  const addResearchContributor = async (contributor: ResearchContributor): Promise<ResearchContributor> => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newContributor: LocalResearchContributor = {
      ...contributor,
      id: contributor.id || uuidv4(),
      _syncStatus: isOnline ? 'synced' : 'pending',
    };

    setContributors(prev => [...prev, newContributor]);
    try {
      const created = await createRemoteResearchContributor(contributor);
      await createItem('research_contributors', created);
      return created;
    } catch (err) {
      console.error("[App] Erro ao criar colaborador remotamente:", err);
      setError("Falha ao salvar no servidor. Salvo localmente para sincronizar depois.");
      await saveUnsyncedItem('research_contributors', newContributor);
      setUnSyncedContributors(prev => [...prev, newContributor]);
      return newContributor;
    }
  };

  const removeResearchContributor = async (params: { research_id: string; user_id: string; contributor_id: string }) => {
    const { research_id, user_id, contributor_id } = params;
    try {
      await deleteItem('research_contributors', contributor_id);
      setContributors(prev => prev.filter(c => c.id !== contributor_id));

      try {
        await deleteRemoteResearchContributor(research_id, user_id);
      } catch (err) {
        console.error("[App] Erro ao deletar colaborador remotamente:", err);
        setError("Falha ao sincronizar remoção.");
        await saveUnsyncedItem('research_contributors', { research_id, user_id, delete: true } as any);
        setUnSyncedContributors(prev => [...prev, { research_id, user_id, delete: true } as any]);
      }
    } catch (err) {
      console.error("[App] Erro ao deletar colaborador local:", err);
      setError("Erro ao deletar colaborador local");
    }
  };

  return {
    contributors,
    unSyncedContributors,
    loading: loadingContributors || loadingUnsynced,
    loadingContributors,
    loadingUnsynced,
    error,
    addResearchContributor,
    removeResearchContributor,
  };
}


============================================================


📄 Arquivo : useResearches.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useResearches.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { Research } from "@/lib/types/indexeddb";
import {
  createResearch as createRemoteResearch,
  updateResearch as updateRemoteResearch,
  deleteResearch as deleteRemoteResearch,
  getResearches as getAllRemoteResearches,
} from "@/repositories/server/researchApi";
import {
  createResearch as createLocalResearch,
  getResearch as getLocalResearch,
  getAllResearchs as getAllLocalResearchs,
  updateResearch as updateLocalResearch,
  deleteResearch as deleteLocalResearch,
} from "@/repositories/indexeddb/researchRepository";
import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useResearches(especifico: boolean = false, id?: string) {
  const [researches, setResearches] = useState<Research[]>([]);
  const [researchData, setResearchData] = useState<Research | null>(null);
  const [unSyncedResearchs, setUnSyncedResearchs] = useState<Research[]>([]);
  const [loadingResearches, setLoadingResearches] = useState<boolean>(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedResearches();
  }, []);

  useEffect(() => {
    if (especifico) {
      if (id) {
        fetchResearchById(id);
      } else {
        setResearchData(null);
        setLoadingResearches(false);
      }
    } else {
      fetchResearches();
    }
  }, [especifico, id]);

  const fetchUnsyncedResearches = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const researchesPending = unsynced
        .filter((item) => item.store === "researches")
        .map((item) => item.payload as Research);
      setUnSyncedResearchs(researchesPending);
    } catch (error) {
      console.error("[App] Erro ao carregar pesquisas pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchResearches = async () => {
    setLoadingResearches(true);
    try {
      const remoteResearches = await getAllRemoteResearches();
      setResearches(remoteResearches);
      await Promise.allSettled(
        remoteResearches.map((research) => createLocalResearch(research))
      );
    } catch (err) {
      console.warn("[App] Falha ao buscar pesquisas do servidor. Usando IndexedDB local.", err);
      try {
        const localResearches = await getAllLocalResearchs();
        const filteredResearches = localResearches.filter((research) => research.status === true);
        setResearches(filteredResearches);
      } catch (errLocal) {
        console.error("[App] Falha ao carregar pesquisas locais:", errLocal);
        setError("Erro ao carregar pesquisas locais");
      }
    } finally {
      setLoadingResearches(false);
    }
  };

  const fetchResearchById = async (researchId: string) => {
    setLoadingResearches(true);
    try {
      const local = await getLocalResearch(researchId);
      if (local) {
        setResearchData(local);
      } else {
        throw new Error("Pesquisa não encontrada localmente");
      }
    } catch (err) {
      console.error("[App] Erro ao buscar pesquisa por ID:", err);
      setError("Pesquisa não encontrada localmente");
      setResearchData(null);
    } finally {
      setLoadingResearches(false);
    }
  };

  const addResearch = async (research: Research): Promise<Research> => {
    const newResearchId = uuidv4();
    const localResearch: Research = { ...research, id: newResearchId };

    setResearches((prev) => [...prev, localResearch]);

    try {
      const created = await createRemoteResearch(research);
      await createLocalResearch(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar pesquisa remotamente:", error);
      setError("Falha ao salvar no servidor. Salvo localmente para sincronizar depois.");
      await saveUnsyncedItem("researches", localResearch);
      setUnSyncedResearchs((prev) => [...prev, localResearch]);
      return localResearch;
    }
  };

  const updateResearch = async (id: string, updatedData: Research) => {
    await updateLocalResearch(id, updatedData);
  
    setResearches((prev) =>
      prev
        .map((r) => (r.id === id ? { ...r, ...updatedData } : r))
        .filter((r) => r.status === true)
    );
  
    try {
      await updateRemoteResearch({ ...updatedData, id });
    } catch (error) {
      console.error("[App] Erro ao atualizar pesquisa:", error);
      setError("Falha ao sincronizar atualização.");
      await saveUnsyncedItem("researches", { ...updatedData, id });
      setUnSyncedResearchs((prev) => [...prev, { ...updatedData, id }]);
    }
  };
  


  return {
    researches,
    researchData,
    unSyncedResearchs,
    loading: loadingResearches || loadingUnsynced,
    loadingResearches,
    loadingUnsynced,
    error,
    addResearch,
    updateResearch,
  };
}


============================================================


📄 Arquivo : useStaticSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useStaticSurveys.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useStaticSurveys.ts
import { useEffect, useState } from "react";
import { StaticSurvey } from "@/lib/types/indexeddb";
import {
  createStaticSurvey as createRemoteStaticSurvey,
  getStaticSurvey as getRemoteStaticSurvey,
  updateStaticSurvey as updateRemoteStaticSurvey,
  deleteStaticSurvey as deleteRemoteStaticSurvey,
} from "@/repositories/server/staticSurveyApi";

import {
  createStaticSurvey as createLocalStaticSurvey,
  getStaticSurvey as getLocalStaticSurvey,
  updateStaticSurvey as updateLocalStaticSurvey,
  deleteStaticSurvey as deleteLocalStaticSurvey,
} from "@/repositories/indexeddb/staticSurveyRepository";

import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";
import { stat } from "fs";

export function useStaticSurveys(
  research_id?: string,
  especifico: boolean = true,
  survey_type: string = "Estática"
) {
  const [staticSurvey, setStaticSurveyData] = useState<StaticSurvey | null>(null);
  const [unSyncedSurveys, setUnSyncedSurveys] = useState<StaticSurvey[]>([]);
  const [loadingSurveys, setLoadingSurveys] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedSurveys();
  }, []);

  useEffect(() => {
    if (especifico && research_id) {
      fetchSurveyByResearch(research_id, survey_type);
    } else {
      setStaticSurveyData(null);
      setLoadingSurveys(false);
    }
  }, [especifico, research_id, survey_type]);

  const fetchUnsyncedSurveys = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const surveysPending = unsynced
        .filter((item) => item.store === "static_surveys")
        .map((item) => item.payload as StaticSurvey);
      setUnSyncedSurveys(surveysPending);
    } catch (error) {
      console.error("[App] Erro ao carregar static surveys pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchSurveyByResearch = async (researchId: string, type: string) => {
    setLoadingSurveys(true);
    try {
      const remote = await getRemoteStaticSurvey(researchId, type);
      const survey = remote?.[0] || null;
      setStaticSurveyData(survey);
      if (survey) await createLocalStaticSurvey(survey);
    } catch (err) {
      console.warn("[App] Falha ao buscar do servidor, tentando local:", err);
      try {
        const local = await getLocalStaticSurvey(researchId);
        setStaticSurveyData(local || null);
      } catch (errLocal) {
        console.error("[App] Falha ao buscar local:", errLocal);
        setError("Erro ao carregar static survey local");
      }
    } finally {
      setLoadingSurveys(false);
    }
  };

  const addStaticSurvey = async (survey: StaticSurvey): Promise<StaticSurvey> => {
    const newSurveyId = uuidv4();
    const localSurvey = { ...survey, id: newSurveyId };
    setStaticSurveyData(localSurvey);

    try {
      const created = await createRemoteStaticSurvey(survey);
      await createLocalStaticSurvey(created);
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar remotamente:", error);
      await saveUnsyncedItem("static_surveys", localSurvey);
      setUnSyncedSurveys((prev) => [...prev, localSurvey]);
      return localSurvey;
    }
  };

  const updateStaticSurvey = async (id: string, updatedData: StaticSurvey) => {
    await updateLocalStaticSurvey(id, updatedData);
    setStaticSurveyData((prev) => (prev ? { ...prev, ...updatedData } : updatedData));

    try {
      await updateRemoteStaticSurvey({ ...updatedData, id });
    } catch (error) {
      await saveUnsyncedItem("static_surveys", { ...updatedData, id });
      setUnSyncedSurveys((prev) => [...prev, { ...updatedData, id }]);
    }
  };

  const deleteStaticSurvey = async (id: string) => {
    setStaticSurveyData(null);

    try {
      await deleteLocalStaticSurvey(id);
      await deleteRemoteStaticSurvey({ id } as StaticSurvey);
    } catch (error) {
      console.error("[App] Erro ao deletar static survey:", error);
      await saveUnsyncedItem("static_surveys", { id, delete: true } as any);
    }
  };

  return {
    staticSurvey,
    unSyncedSurveys,
    loading: loadingSurveys || loadingUnsynced,
    loadingSurveys,
    loadingUnsynced,
    error,
    addStaticSurvey,
    updateStaticSurvey,
    deleteStaticSurvey,
  };
}


============================================================


📄 Arquivo : useSurveyAnswers.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyAnswers.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyAnswers.ts
import { useEffect, useState } from 'react';
import { SurveyAnswer } from '@/lib/types/indexeddb';
import { getSurveyAnswers, createSurveyAnswer } from '@/repositories/server/surveyAnswerApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyAnswers() {
  type LocalSurveyAnswer = SurveyAnswer & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [answers, setAnswers] = useState<LocalSurveyAnswer[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const isOnline = typeof window !== 'undefined' && navigator.onLine;
        const data = isOnline ? await getSurveyAnswers() : await getAllItems('survey_answers');
        setAnswers(data);
      } catch (err) {
        setError('Erro ao carregar respostas da coleta');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  const addSurveyAnswer = async (answer: SurveyAnswer) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newAnswer: LocalSurveyAnswer = { ...answer, _syncStatus: isOnline ? 'synced' : 'pending' };

    setAnswers(prev => [...prev, newAnswer]);

    try {
      await createItem('survey_answers', newAnswer);
      if (isOnline) await createSurveyAnswer(answer);
    } catch {
      const errorAnswer: LocalSurveyAnswer = { ...answer, _syncStatus: 'error' };
      await createItem('survey_answers', errorAnswer);
    }
  };

  return {
    answers,
    loading,
    error,
    addSurveyAnswer,
  };
}

============================================================


📄 Arquivo : useSurveyContributors.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyContributors.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyContributors.ts
import { useEffect, useState } from "react";
import { SurveyContributor } from "@/lib/types/indexeddb";
import {
  createSurveyContributor as createRemoteSurveyContributor,
  deleteSurveyContributor as deleteRemoteSurveyContributor,
  getSurveyContributors as getRemoteSurveyContributors,
} from "@/repositories/server/surveyContributorApi";
import {
  createItem as createLocalContributor,
  deleteItem as deleteLocalContributor,
  getAllItems as getAllLocalContributors,
} from "@/repositories/indexeddb/indexedDBService";
import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useSurveyContributors(survey_id: string) {
  const [contributors, setContributors] = useState<SurveyContributor[]>([]);
  const [unSyncedContributors, setUnSyncedContributors] = useState<SurveyContributor[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!survey_id) return;
    fetchUnsyncedContributors();
    fetchContributors();
  }, [survey_id]);

  const fetchUnsyncedContributors = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "survey_contributors")
        .map((item) => item.payload as SurveyContributor)
        .filter((c) => c.survey_id === survey_id);

      setUnSyncedContributors(pending);
    } catch (err) {
      console.error("[App] Erro ao carregar colaboradores pendentes:", err);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchContributors = async () => {
    setLoading(true);
    try {
      const remote = await getRemoteSurveyContributors(survey_id);
      setContributors(remote);
      await Promise.allSettled(remote.map((c) => createLocalContributor("survey_contributors", c)));
    } catch (err) {
      console.warn("[App] Erro remoto. Buscando local:", err);
      try {
        const local = await getAllLocalContributors("survey_contributors");
        const filtered = local.filter((c) => c.survey_id === survey_id);
        setContributors(filtered);
      } catch (errLocal) {
        console.error("[App] Erro local:", errLocal);
        setError("Erro ao carregar colaboradores locais");
      }
    } finally {
      setLoading(false);
    }
  };

  const addSurveyContributor = async (contributor: SurveyContributor): Promise<SurveyContributor> => {
    try {
      const created = await createRemoteSurveyContributor(contributor);
      await createLocalContributor("survey_contributors", created);
      setContributors((prev) =>
        prev.some((c) => c.user_id === created.user_id)
          ? prev
          : [...prev, created]
      );
      return created;
    } catch (error) {
      const fallback = { ...contributor, id: uuidv4() };
      console.error("[App] Erro ao criar colaborador:", error);
      await saveUnsyncedItem("survey_contributors", fallback);
      setUnSyncedContributors((prev) => [...prev, fallback]);
      return fallback;
    }
  };

  const removeSurveyContributor = async (params: { survey_id: string; contributor_id: string }) => {
    const { survey_id, contributor_id } = params;
    setContributors((prev) => prev.filter((c) => c.user_id !== contributor_id));

    try {
      await deleteRemoteSurveyContributor(survey_id, contributor_id);
    } catch (error) {
      console.error("[App] Erro ao deletar remotamente:", error);
      await saveUnsyncedItem("survey_contributors", { survey_id, contributor_id, delete: true } as any);
      setUnSyncedContributors((prev) => [...prev, { survey_id, contributor_id, delete: true } as any]);
    }

    try {
      await deleteLocalContributor("survey_contributors", contributor_id);
    } catch (error) {
      console.warn("[App] Falha ao deletar localmente:", error);
    }
  };

  return {
    contributors,
    unSyncedContributors,
    loading: loading || loadingUnsynced,
    error,
    addSurveyContributor,
    removeSurveyContributor,
  };
}


============================================================


📄 Arquivo : useSurveyGroups.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyGroups.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyGroups.ts
import { useEffect, useState } from 'react';
import { SurveyGroup } from '@/lib/types/indexeddb';
import { createSurveyGroup } from '@/repositories/server/surveyGroupApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyGroups() {
  type LocalSurveyGroup = SurveyGroup & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [groups, setGroups] = useState<LocalSurveyGroup[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('survey_group');
        setGroups(data);
      } catch (err) {
        setError('Erro ao carregar grupos');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addSurveyGroup = async (group: SurveyGroup) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newGroup: LocalSurveyGroup = { ...group, _syncStatus: isOnline ? 'synced' : 'pending' };
    setGroups(prev => [...prev, newGroup]);

    try {
      await createItem('survey_group', newGroup);
      if (isOnline) await createSurveyGroup(group);
    } catch {
      const errorGroup: LocalSurveyGroup = { ...group, _syncStatus: 'error' };
      await createItem('survey_group', errorGroup);
    }
  };

  return { groups, loading, error, addSurveyGroup };
}

============================================================


📄 Arquivo : useSurveyRegions.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyRegions.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyRegions.ts
import { useEffect, useState } from "react";
import { SurveyRegion } from "@/lib/types/indexeddb";
import {
  createSurveyRegion as createRemoteSurveyRegion,
  deleteSurveyRegion as deleteRemoteSurveyRegion,
  getSurveyRegions as getRemoteSurveyRegions,
} from "@/repositories/server/surveyRegionApi";

import {
  createSurveyRegion as createLocalSurveyRegion,
  deleteSurveyRegion as deleteLocalSurveyRegion,
  getAllSurveyRegions as getAllLocalSurveyRegions,
} from "@/repositories/indexeddb/surveyRegionRepository";

import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useSurveyRegions(survey_id: string) {
  const [surveyRegions, setSurveyRegions] = useState<SurveyRegion[]>([]);
  const [unSyncedRegions, setUnSyncedRegions] = useState<SurveyRegion[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!survey_id) return;
    fetchUnsyncedRegions();
    fetchRegions();
  }, [survey_id]);

  const fetchUnsyncedRegions = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === "survey_regions")
        .map((item) => item.payload as SurveyRegion)
        .filter((r) => r.survey_id === survey_id);

      setUnSyncedRegions(pending);
    } catch (error) {
      console.error("[App] Erro ao carregar regiões pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchRegions = async () => {
    setLoading(true);
    try {
      const remoteRegions = await getRemoteSurveyRegions(survey_id);
      
      setSurveyRegions(remoteRegions);
      await Promise.allSettled(
        remoteRegions.map((r) => createLocalSurveyRegion(r))
      );
    } catch (err) {
      console.warn("[App] Erro remoto. Buscando local:", err);
      try {
        const localRegions = await getAllLocalSurveyRegions();
        const filtered = localRegions.filter((r) => r.survey_id === survey_id);
        setSurveyRegions(filtered);
      } catch (errLocal) {
        console.error("[App] Erro local:", errLocal);
        setError("Erro ao carregar regiões");
      }
    } finally {
      setLoading(false);
    }
  };

  const addSurveyRegion = async (region: SurveyRegion): Promise<SurveyRegion> => {
    try {
      const created = await createRemoteSurveyRegion(region);
      await createLocalSurveyRegion(created);
      setSurveyRegions((prev) => [...prev, created]);
      return created;
    } catch (error) {
      const newId = uuidv4();
      const localRegion: SurveyRegion = { ...region, id: newId };
      console.error("[App] Erro ao criar região:", error);
      await saveUnsyncedItem("survey_regions", localRegion);
      setUnSyncedRegions((prev) => [...prev, localRegion]);
      return localRegion;
    }
  };

  const deleteSurveyRegion = async (id: string) => {
    setSurveyRegions((prev) => prev.filter((r) => r.id !== id));

    try {
      await deleteRemoteSurveyRegion(id, survey_id);
    } catch (error) {
      console.error("[App] Falha ao deletar remotamente:", error);
      await saveUnsyncedItem("survey_regions", { id, survey_id } as SurveyRegion);
      setUnSyncedRegions((prev) => [...prev, { id, survey_id } as SurveyRegion]);
    }

    try {
      await deleteLocalSurveyRegion(id);
    } catch (error) {
      console.warn("[App] Falha ao deletar localmente:", error);
    }
  };

  return {
    surveyRegions,
    unSyncedRegions,
    loading: loading || loadingUnsynced,
    error,
    addSurveyRegion,
    deleteSurveyRegion,
  };
}


============================================================


📄 Arquivo : useSurveyTimeRanges.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyTimeRanges.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyTimeRanges.ts
import { useEffect, useState } from 'react';
import { SurveyTimeRange } from '@/lib/types/indexeddb';
import {
  getSurveyTimeRanges as getRemoteSurveyTimeRanges,
  createSurveyTimeRange as createRemoteSurveyTimeRange,
  deleteSurveyTimeRange as deleteRemoteSurveyTimeRange,
} from '@/repositories/server/surveyTimeRangeApi';

import {
  getAllSurveyTimeRanges as getAllLocalSurveyTimeRanges,
  createSurveyTimeRange as createLocalSurveyTimeRange,
  deleteSurveyTimeRange as deleteLocalSurveyTimeRange,
} from '@/repositories/indexeddb/surveyTimeRangeRepository';

import { saveUnsyncedItem, getUnsyncedItems } from '@/lib/db';
import { v4 as uuidv4 } from 'uuid';

export function useSurveyTimeRanges(survey_id: string) {
  const [ranges, setRanges] = useState<SurveyTimeRange[]>([]);
  const [unSyncedRanges, setUnSyncedRanges] = useState<SurveyTimeRange[]>([]);
  const [loading, setLoading] = useState(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    if (!survey_id) return;
    fetchUnsyncedRanges();
    fetchRanges();
  }, [survey_id]);

  const fetchUnsyncedRanges = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const pending = unsynced
        .filter((item) => item.store === 'survey_time_ranges')
        .map((item) => item.payload as SurveyTimeRange)
        .filter((r) => r.survey_id === survey_id);

      setUnSyncedRanges(pending);
    } catch (err) {
      console.error('[App] Erro ao carregar time ranges pendentes:', err);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchRanges = async () => {
    setLoading(true);
    try {
      const remote = await getRemoteSurveyTimeRanges(survey_id);
      setRanges(remote);
      await Promise.allSettled(remote.map((r) => createLocalSurveyTimeRange(r)));
    } catch (err) {
      console.warn('[App] Erro remoto. Buscando local:', err);
      try {
        const local = await getAllLocalSurveyTimeRanges();
        const filtered = local.filter((r) => r.survey_id === survey_id);
        setRanges(filtered);
      } catch (errLocal) {
        console.error('[App] Erro local:', errLocal);
        setError('Erro ao carregar faixas de horário');
      }
    } finally {
      setLoading(false);
    }
  };

  const addSurveyTimeRange = async (
    range: Omit<SurveyTimeRange, 'id'>
  ): Promise<SurveyTimeRange> => {
    try {
      const created = await createRemoteSurveyTimeRange(
        range.survey_id,
       range.survey_type,
        range
      );
      await createLocalSurveyTimeRange(created);
      setRanges((prev) => [...prev, created]);
      return created;
    } catch (err) {
      const fallback = { ...range, id: uuidv4() };
      await saveUnsyncedItem('survey_time_ranges', fallback);
      setUnSyncedRanges((prev) => [...prev, fallback]);
      return fallback;
    }
  };

  const deleteSurveyTimeRange = async (id: string) => {
    setRanges((prev) => prev.filter((r) => r.id !== id));
    try {
      await deleteRemoteSurveyTimeRange(survey_id, id);
    } catch (err) {
      console.warn('[App] Falha ao deletar remotamente:', err);
      await saveUnsyncedItem('survey_time_ranges', { id, survey_id } as SurveyTimeRange);
      setUnSyncedRanges((prev) => [...prev, { id, survey_id } as SurveyTimeRange]);
    }

    try {
      await deleteLocalSurveyTimeRange(id);
    } catch (err) {
      console.warn('[App] Falha ao deletar localmente:', err);
    }
  };

  return {
    ranges,
    unSyncedRanges,
    loading: loading || loadingUnsynced,
    error,
    addSurveyTimeRange,
    deleteSurveyTimeRange,
  };
}


============================================================


📄 Arquivo : useUsers.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useUsers.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { User } from "@/lib/types/indexeddb";
import { 
  createUser as createRemoteUser,
  updateUser as updateRemoteUser,
  getUsers as getAllRemoteUsers,
  getUserById as getRemoteUserById
} from "@/repositories/server/userApi";
import {
  createUser as createLocalUser,
  updateUser as updateLocalUser,
  deleteUser as deleteLocalUser,
  getAllUsers as getAllLocalUsers,
  getUser as getLocalUser
} from "@/repositories/indexeddb/userRepository"; 
import { getUnsyncedItems, saveUnsyncedItem } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

export function useUsers(especifico: boolean = false, id?: string) {
  const [users, setUsers] = useState<User[]>([]);
  const [userData, setUserData] = useState<User | null>(null);
  const [unSyncedUsers, setUnSyncedUsers] = useState<User[]>([]);
  const [loadingUsers, setLoadingUsers] = useState<boolean>(true);
  const [loadingUnsynced, setLoadingUnsynced] = useState<boolean>(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    fetchUnsyncedUsers();
  }, []);

  useEffect(() => {
    if (especifico) {
      if (id) {
        fetchUserById(id);
      } else {
        setUserData(null);
        setLoadingUsers(false);
      }
    } else {
      fetchUsers();
    }
  }, [especifico, id]);

  const fetchUnsyncedUsers = async () => {
    try {
      const unsynced = await getUnsyncedItems();
      const usersPending = unsynced
        .filter((item) => item.store === "users")
        .map((item) => item.payload as User);
      setUnSyncedUsers(usersPending);
    } catch (error) {
      console.error("[App] Erro ao carregar usuários pendentes:", error);
    } finally {
      setLoadingUnsynced(false);
    }
  };

  const fetchUsers = async () => {
    setLoadingUsers(true);
    try {
      const remoteUsers = await getAllRemoteUsers();
      setUsers(remoteUsers);
      // Atualiza o IndexedDB local
      await Promise.allSettled(remoteUsers.map((user) => createLocalUser(user)));
    } catch (err) {
      console.warn("[App] Falha ao buscar usuários do servidor. Usando IndexedDB local.", err);
      try {
        const localUsers = await getAllLocalUsers();
        setUsers(localUsers);
      } catch (errLocal) {
        console.error("[App] Falha ao carregar usuários locais:", errLocal);
        setError("Erro ao carregar usuários locais.");
      }
    } finally {
      setLoadingUsers(false);
    }
  };

  const fetchUserById = async (userId: string) => {
    setLoadingUsers(true);
    try {
      // Primeiro tenta online
      const remote = await getRemoteUserById(userId);
      setUserData(remote);
      await createLocalUser(remote);
    } catch (err) {
      console.warn("[App] Falha ao buscar usuário no servidor, tentando IndexedDB...", err);
      try {
        const local = await getLocalUser(userId);
        if (local) {
          setUserData(local);
        } else {
          throw new Error("Usuário não encontrado localmente.");
        }
      } catch (errLocal) {
        console.error("[App] Erro ao buscar usuário local:", errLocal);
        setError("Usuário não encontrado localmente.");
        setUserData(null);
      }
    } finally {
      setLoadingUsers(false);
    }
  };

  const addUser = async (user: User): Promise<User> => {
    const tempId = uuidv4();
    const localUser: User = { ...user, id: tempId };

    setUsers((prev) => [...prev, localUser]);

    try {
      const created = await createRemoteUser(user);
      await createLocalUser(created);
      setUsers((prev) =>
        prev.map((u) => (u.id === tempId ? created : u))
      );
      return created;
    } catch (error) {
      console.error("[App] Erro ao criar usuário remotamente:", error);
      setError("Falha ao criar usuário. Salvo localmente para sincronizar depois.");
      await saveUnsyncedItem("users", localUser);
      setUnSyncedUsers((prev) => [...prev, localUser]);
      return localUser;
    }
  };

  const updateUser = async (id: string, updatedData: User) => {
    await updateLocalUser(id, updatedData);

    setUsers((prev) =>
      prev.map((u) => (u.id === id ? { ...u, ...updatedData } : u))
    );

    try {
      await updateRemoteUser({ ...updatedData, id });
    } catch (error) {
      console.error("[App] Erro ao atualizar usuário:", error);
      setError("Falha ao atualizar no servidor. Salvo localmente para sincronizar depois.");
      await saveUnsyncedItem("users", { ...updatedData, id });
      setUnSyncedUsers((prev) => [...prev, { ...updatedData, id }]);
    }
  };


  return {
    users,
    userData,
    unSyncedUsers,
    loading: loadingUsers || loadingUnsynced,
    loadingUsers,
    loadingUnsynced,
    error,
    addUser,
    updateUser,
    fetchUsers,
  };
}


============================================================


📄 Arquivo : db.js
📂 Pasta   : lib
🧭 Caminho : lib/db.js
--------------------------------------
📜 Conteúdo:

// lib/db.js
import { openDB } from 'idb';
export const DB_NAME = 'placemaking-db';
export const DB_VERSION = 1;
import { v4 as uuidv4 } from 'uuid'; 

const storeSchema = [
  'auth',
  'users',
  'fields',
  'researches',
  'survey_time_ranges',
  'survey_regions',
  'survey_group',
  'survey_contributors',
  'survey_answers',
  'static_surveys',
  'form_surveys',
  'dynamic_surveys',
  'research_contributors',
  'input_types',
  'field_options',
  'unsynced_items'
];

export async function initPlacemakingDB() {
  return openDB(DB_NAME, DB_VERSION, {
    upgrade(db) {
      for (const storeName of storeSchema) {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: 'id' });
        }
      }
    },
  });
}
export async function saveAuth(auth) {
  const db = await initPlacemakingDB();
  await db.put('auth', { ...auth, id: 'current' });
}

export async function getAuth() {
  const db = await initPlacemakingDB();
  return db.get('auth', 'current');
}

export async function deleteAuth() {
  const db = await initPlacemakingDB();
  return db.delete('auth', 'current');
}



// SALVAR ITEM NÃO SINCRONIZADO
export async function saveUnsyncedItem(type, payload) {
  const db = await initPlacemakingDB();
  const id = uuidv4();
  await db.put('unsynced_items', { id, type, payload });
}

// PEGAR TODOS ITENS NÃO SINCRONIZADOS
export async function getUnsyncedItems() {
  const db = await initPlacemakingDB();
  return db.getAll('unsynced_items');
}

// DELETAR ITEM JÁ SINCRONIZADO
export async function deleteUnsyncedItem(id) {
  const db = await initPlacemakingDB();
  return db.delete('unsynced_items', id);
}


============================================================


📄 Arquivo : network.js
📂 Pasta   : lib
🧭 Caminho : lib/network.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";

export function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(true);

  useEffect(() => {
    const updateStatus = () => setIsOnline(navigator.onLine);

    window.addEventListener("online", updateStatus);
    window.addEventListener("offline", updateStatus);

    updateStatus();

    return () => {
      window.removeEventListener("online", updateStatus);
      window.removeEventListener("offline", updateStatus);
    };
  }, []);

  return isOnline;
}


============================================================


📄 Arquivo : indexeddb.ts
📂 Pasta   : lib/types
🧭 Caminho : lib/types/indexeddb.ts
--------------------------------------
📜 Conteúdo:

import modelSamples from '@/lib/types/models'

export interface User {
  id: string; // UUID
  name: string;
  email: string;
  password: string;
  role: string; // 'admin', 'researcher', etc.
  status: string; // 'active', 'inactive', etc.
  created_at?: string;
  updated_at?: string;
}


export interface Field {
  id?: string;
  activity_id: string;
  title: string;
  input_type_id: string;
  description?: string;
  created_at?: string;
  updated_at?: string;
  survey_id?: string;
  survey_type?: string;
}

export interface Research {
  id?: string;
  title: string;
  description?: string;
  release_date?: string;
  lat?: number;
  long?: number;
  location_title?: string;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
  end_date?: string;
  status? : boolean;
}

// src/lib/types/indexeddb.ts

export interface SurveyTimeRange {
  id: string;
  survey_id: string;
  start_time: string;  // formato: "09:00"
  end_time: string;    // formato: "10:30"
  survey_type: string;
}


export interface SurveyRegion {
  id: string;
  name: string;
  lat: number;
  long: number;
  location_title: string;
  survey_type: string;
  survey_id: string;
}

export interface SurveyGroup {
  id: string;
  survey_type: string;
  survey_id: string;
}

export interface SurveyContributor {
  id: string;
  survey_id: string;
  survey_type: string;
  user_id: string;
  instruction?: string;
  created_at?: string;
  updated_at?: string;
}

export interface SurveyAnswer {
  id: string;
  value: string;
  survey_type: string;
  survey_id: string;
  survey_group_id?: string;
  contributor_id: string;
  registered_at: string;
  survey_time_range_id?: string;
  survey_region_id?: string;
}

export interface StaticSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
  survey_type: string;
}

export interface FormSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
  survey_type: string;
}

export interface DynamicSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
  survey_type: string;
}

export interface ResearchContributor {
  id: string;
  research_id: string;
  user_id: string;
  instruction: string;
}

export interface InputType {
  id: string;
  name: string;
  stored_as: string;
}

export interface FieldOption {
  id: string;
  field_id: string;
  option_text: string;
  option_value?: string;
  created_at: string;
  updated_at: string;
}

export interface UnsyncedData {
  id: string;
  store: keyof StoreTypes; 
  payload: any;
}

export type StoreTypes = {
  users: User;
  fields: Field;
  researches: Research;
  survey_time_ranges: SurveyTimeRange;
  survey_regions: SurveyRegion;
  survey_group: SurveyGroup;
  survey_contributors: SurveyContributor;
  survey_answers: SurveyAnswer;
  static_surveys: StaticSurvey;
  form_surveys: FormSurvey;
  dynamic_surveys: DynamicSurvey;
  research_contributors: ResearchContributor;
  input_types: InputType;
  field_options: FieldOption;
  unsynced_data: UnsyncedData;
};







============================================================


📄 Arquivo : models.js
📂 Pasta   : lib/types
🧭 Caminho : lib/types/models.js
--------------------------------------
📜 Conteúdo:

const modelSamples = {
    users: {
      id: "",
      name: "",
      email: "",
      password: "",
      role: "",
      status: "",
      created_at: undefined,
      updated_at: undefined,
    },
    fields: {
      id: undefined,
      activity_id: "",
      title: "",
      input_type: "",
      description: undefined,
      created_at: undefined,
      updated_at: undefined,
    },
    researches: {
      id: undefined,
      title: "",
      description: undefined,
      release_date: undefined,
      lat: undefined,
      long: undefined,
      location_title: undefined,
      created_by: undefined,
      created_at: undefined,
      updated_at: undefined,
      end_date: undefined,
      status: undefined,
    },
    survey_time_ranges: {
      id: "",
      start_time: "",
      end_time: "",
      survey_id: "",
      survey_type: "",
    },
    survey_regions: {
      id: "",
      name: "",
      lat: 0,
      long: 0,
      location_title: "",
      survey_type: "",
      survey_id: "",
    },
    survey_group: {
      id: "",
      survey_type: "",
      survey_id: "",
    },
    survey_contributors: {
      id: "",
      survey_id: "",
      survey_type: "",
      user_id: "",
      instruction: undefined,
      created_at: undefined,
      updated_at: undefined,
    },
    survey_answers: {
      id: "",
      value: "",
      survey_type: "",
      survey_id: "",
      survey_group_id: undefined,
      contributor_id: "",
      registered_at: "",
      survey_time_range_id: undefined,
      survey_region_id: undefined,
    },
    static_surveys: {
      id: "",
      title: "",
      description: undefined,
      lat: 0,
      long: 0,
      location_title: "",
      research_id: undefined,
      survey_type: "",
    },
    form_surveys: {
      id: "",
      title: "",
      description: undefined,
      lat: 0,
      long: 0,
      location_title: "",
      research_id: undefined,
      survey_type: "",
    },
    dynamic_surveys: {
      id: "",
      title: "",
      description: undefined,
      lat: 0,
      long: 0,
      location_title: "",
      research_id: undefined,
      survey_type: "",
    },
    research_contributors: {
      id: "",
      research_id: "",
      user_id: "",
      instruction: "",
    },
    input_types: {
      id: "",
      name: "",
      stored_as: "",
    },
    field_options: {
      id: "",
      field_id: "",
      option_text: "",
      option_value: undefined,
      created_at: "",
      updated_at: "",
    },
    unsynced_items: {
      id: "",              
      store: "",           
      payload: {},         
      created_at: "",     
    },
};

export default modelSamples;



/**
 * Formata um objeto de dados para conter apenas os campos válidos
 * de acordo com o modelo da store no modelSamples.
 *
 * @param {Object} data - O objeto de dados que será formatado.
 * @param {string} storeType - O nome da store (ex: 'researches', 'users', etc).
 * @returns {Object} Objeto formatado contendo apenas os campos esperados.
 */
export function formatDataByModel(data, storeType) {
  const sample = modelSamples[storeType];

  if (!sample) {
    console.warn(`Store type '${storeType}' não encontrado no modelSamples.`);
    return {};
  }

  const formatted = {};

  for (const key of Object.keys(sample)) {
    if (key in data) {
      formatted[key] = data[key];
    } else {
      formatted[key] = undefined;
    }
  }

  return formatted;
}
  

============================================================


📄 Arquivo : utils.js
📂 Pasta   : lib
🧭 Caminho : lib/utils.js
--------------------------------------
📜 Conteúdo:

import { clsx } from "clsx";
import { twMerge } from "tailwind-merge"

export function cn(...inputs) {
  return twMerge(clsx(inputs));
}


============================================================


📄 Arquivo : middleware.js
📂 Pasta   : .
🧭 Caminho : middleware.js
--------------------------------------
📜 Conteúdo:

import { NextResponse } from "next/server";
import { jwtVerify } from "jose";
import {
  PUBLIC_PAGES,
  PUBLIC_APIS,
  AUTHENTICATED_PAGES,
  ROLE_PERMISSIONS,
} from "@/config/routes";

const JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET);

export async function middleware(request) {
  const { pathname } = request.nextUrl;
  const token = request.cookies.get("token")?.value;
  const isPublicRoute = PUBLIC_PAGES.includes(pathname) || PUBLIC_APIS.includes(pathname);

  let payload = null;
  if (token) {
    try {
      const { payload: verifiedPayload } = await jwtVerify(token, JWT_SECRET);
      // console.log("Payload:", verifiedPayload);
      payload = verifiedPayload;
    } catch (error) {
      // Token inválido ou expirado: payload continua null
    }
  }
  
  if (isPublicRoute) {
    if (payload?.sub) {
      return NextResponse.redirect(new URL("/", request.url));
    }
    return NextResponse.next();
  }

  if (!payload?.sub) {
    return NextResponse.redirect(new URL("/login", request.url));
  }


  if (AUTHENTICATED_PAGES.some((route) => pathname.startsWith(route))) {
    return NextResponse.next();
  }

  const allowedRoutes = ROLE_PERMISSIONS[payload.role] || [];
  if (!allowedRoutes.some((route) => pathname.startsWith(route))) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    "/((?!_next|favicon.ico|manifest.json|workers|robots.txt|img|icons|static|offline|logo|fonts).*)",
  ],
};


============================================================


📄 Arquivo : _app.js
📂 Pasta   : pages
🧭 Caminho : pages/_app.js
--------------------------------------
📜 Conteúdo:

import "@/styles/globals.css";
import { useEffect } from "react";
import { AnimatePresence } from "framer-motion";
import { LoadingContextProvider, useLoading } from "@/context/LoadingContext";
import { MessageProvider } from "@/context/MessageContext";
import { AuthProvider, useAuth } from "@/context/AuthContext";
import Loading from "@/components/ui/Loading";
import { initBackgroundSync } from "@/utils/periodicSync";
import PublicLayout from "@/components/layouts/PublicLayout";
import PrivateLayout from "@/components/layouts/PrivateLayout";
import Head from "next/head";
import { initPlacemakingDB } from "@/lib/db"; // << IMPORTA AQUI

function AppContent({ Component, pageProps }) {
  const { isLoading } = useLoading();
  const PageComponent = Component;
  const pageName = PageComponent.pageName || "Minha Aplicação";
  const layoutType = PageComponent.layout || "public";
  const Layout = layoutType === "private" ? PrivateLayout : PublicLayout;

  return (
    <>
      <Head>
        <title>{`${pageName} | Minha Aplicação`}</title>
        <link
          rel="icon"
          type="image/png"
          sizes="512x512"
          href="/img/icon-512x512.png"
        />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
      </Head>

      <Layout pageName={pageName}>
        <PageComponent {...pageProps} />
      </Layout>
      <AnimatePresence>{isLoading && <Loading />}</AnimatePresence>
    </>
  );
}

function MyApp({ Component, pageProps }) {
  useEffect(() => {
    async function setupApp() {
      try {
        await initPlacemakingDB();
        console.log("[DB] IndexedDB inicializado com sucesso.");
      } catch (error) {
        console.error("[DB] Erro ao inicializar IndexedDB:", error);
      }

      if ('serviceWorker' in navigator) {
        navigator.serviceWorker
          .register('/sw.js')
          .then(() => {
            console.log('SW registrado com sucesso!');
            if (!navigator.serviceWorker.controller) {
              sessionStorage.setItem('sw-activated', '1');
              window.location.reload();
            } else {
              initBackgroundSync();
            }
          })
          .catch(console.error);
      }
    }

    setupApp();
  }, []);

  return (
    <AuthProvider>
      <LoadingContextProvider>
        <MessageProvider>
          <AppContent Component={Component} pageProps={pageProps} />
        </MessageProvider>
      </LoadingContextProvider>
    </AuthProvider>
  );
}

export default MyApp;


============================================================


📄 Arquivo : _document.js
📂 Pasta   : pages
🧭 Caminho : pages/_document.js
--------------------------------------
📜 Conteúdo:

import Document, { Html, Head, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="pt-BR">
        <Head>
          <link rel="manifest" href="/manifest.json" />
          <meta name="theme-color" content="#000000" />
          <link rel="apple-touch-icon" href="/img/521-azul.png" />
          <link
            rel="apple-touch-startup-image"
            href="/splashscreens/521-branco.png"
            media="(device-width: 320px) and (device-height: 568px)"
          />
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta
            name="apple-mobile-web-app-status-bar-style"
            content="black-translucent"
          />

          <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,200,0,-25"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/activity-answers
🧭 Caminho : pages/api/activity-answers/index.js
--------------------------------------
📜 Conteúdo:


export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/activity-answers`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar respostas de atividade' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar resposta de atividade' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : change-password.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/change-password.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Não autorizado: token ausente" });
  }

  const { new_password, confirm_password } = req.body;



  if (!new_password || !confirm_password) {
    return res
      .status(400)
      .json({ error: "Campos obrigatórios não preenchidos" });
  }

  if (new_password !== confirm_password) {
    return res.status(400).json({ error: "As senhas não coincidem" });
  }

  try {
    const response = await fetch(
      `${process.env.SERVER_URL}/auth/reset_password`,
      {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          new_password,
          confirm_password,
        }),
      }
    );

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json({ message: "Senha atualizada com sucesso!" });
  } catch (err) {
    console.error("Erro ao mudar a senha:", err);
    return res.status(500).json({ error: "Erro interno do servidor" });
  }
}


============================================================


📄 Arquivo : forgot-password.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/forgot-password.js
--------------------------------------
📜 Conteúdo:


export default async function handler(req, res) {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const { email} = req.body;
    try {
        const response = await fetch(`${process.env.SERVER_URL}/auth/forgot_password`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email}),
      });

      
      if (!response.ok) {
        const errorData = await response.json();
        return res.status(response.status).json(errorData);
      }
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }
  

============================================================


📄 Arquivo : login.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/login.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { email, password } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/login`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();

    const expiresDate = new Date(data.access_token.expires_at);
    res.setHeader(
      "Set-Cookie",
      serialize("token", data.access_token.token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        path: "/",
        expires: expiresDate,
      })
    );


    return res.status(200).json(data);

  } catch (err) {
    console.error("[Login Error]", err);
    return res
      .status(500)
      .json({ error: "Erro ao conectar com o servidor de autenticação." });
  }
}


============================================================


📄 Arquivo : logout.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/logout.js
--------------------------------------
📜 Conteúdo:

import { serialize, parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Método não permitido" });
  }

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    res.setHeader("Set-Cookie", serialize("token", "", {
      path: "/",
      expires: new Date(0),
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax"
    }));
    return res.status(401).json({ message: "Token não encontrado" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/logout`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      console.error("Erro ao fazer logout no servidor:", await response.text());
    }
  } catch (error) {
    console.error("Erro de conexão com o servidor:", error);
  }

  res.setHeader("Set-Cookie", serialize("token", "", {
    path: "/",
    expires: new Date(0),
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax"
  }));

  return res.status(200).json({ message: "Logout realizado com sucesso" });
}


============================================================


📄 Arquivo : register.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/register.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { name, email, confirmation_email, role, status } = req.body;


  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/register`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ name, email, confirmation_email, role, status }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();

    return res.status(200).json(data);

  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : validate-code.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/validate-code.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { code } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/validate_code`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ token: code }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    const { token, expires_at } = data.access_token;

    const expiresDate = new Date(expires_at);

    res.setHeader(
      "Set-Cookie",
      serialize("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        path: "/",
        expires: expiresDate,
      })
    );

    return res.status(200).json(data);

  } catch (err) {
    console.error("[verify-code]", err);
    return res.status(500).json({ message: "Erro ao verificar código" });
  }
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "user_id"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id, user_id } = req.body;
    const missingFields = checkMissingFields({ research_id, user_id });
    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors/${user_id}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({}),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(201).json(data.contributor);
  } catch (err) {
    console.error("Erro geral:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";
const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "user_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id, user_id } = req.body;

    const missingFields = checkMissingFields({ research_id, user_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors/${user_id}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {

  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id } = req.query;
    const missingFields = checkMissingFields({ research_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    return res.status(200).json(data.contributors);

  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}

============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["field_id", "option_text", "option_value"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { field_id, option_text, option_value  } = req.query;
    const missingFields = checkMissingFields({ field_id, option_text, option_value });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/fields/${field_id}/options`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        option_text,
        option_value,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(201).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";
const checkMissingFields = (dataObj) => {
  const requiredFields = ["field_id", "option_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { field_id, option_id } = req.query;

    const missingFields = checkMissingFields({ field_id, option_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/fields/${field_id}/options/${option_id}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj, requiredFields) => {
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  const { method, query, body } = req;
  const { field_id, option_id } = query;
  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token || "";

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const baseURL = `${process.env.SERVER_URL}/fields/${field_id}/options`;

  try {
    switch (method) {
      case "GET": {
        const missing = checkMissingFields({ field_id }, ["field_id"]);
        if (missing.length > 0)
          return res.status(400).json({ error: `Faltam campos: ${missing.join(", ")}` });

        const response = await fetch(baseURL, {
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      case "POST": {
        const response = await fetch(baseURL, {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      case "PUT": {
        if (!option_id)
          return res.status(400).json({ error: "option_id é obrigatório para PUT" });

        const response = await fetch(`${baseURL}/${option_id}`, {
          method: "PUT",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      case "DELETE": {
        if (!option_id)
          return res.status(400).json({ error: "option_id é obrigatório para DELETE" });

        const response = await fetch(`${baseURL}/${option_id}`, {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      default:
        return res.status(405).json({ error: `Método ${method} não permitido.` });
    }
  } catch (err) {
    console.error("[API][field_options] erro:", err);
    return res.status(500).json({ error: "Erro interno ao conectar com o servidor." });
  }
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "survey_id",
    "survey_type",
    "title",
    "description",
    "input_type_id",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      title,
      description,
      input_type_id
    } = req.body;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      title,
      description,
      input_type_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        title,
        description,
        input_type_id
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "field_id",
    "survey_id",
    "survey_type",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      field_id
    } = req.query;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      field_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields/${field_id}?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      }
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/index.js
--------------------------------------
📜 Conteúdo:

// pages/api/fields/index.js
import { parse } from "cookie";

export default async function handler(req, res) {
  const { method, query, body } = req;
  const { survey_id, survey_type, field_id } = query;

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token || "";
  const SERVER_URL = process.env.SERVER_URL;
  const baseURL = `${SERVER_URL}/survey/${survey_id}/fields`;

  try {
    switch (method) {

      case "GET": {
        console.log("urllll-", baseURL)
        const response = await fetch(`${baseURL}?survey_type=${survey_type}`, {
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        const data = await response.json();  
        return res.status(response.status).json(data.fields);
      }

      case "POST": {

        const response = await fetch(`${baseURL}?survey_type=${survey_type}`, {
          method: "POST",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(body),
        });
        const data = await response.json();
        return res.status(response.status).json(data.field);
      }

      case "PUT": {
        if (!field_id) {
          return res.status(400).json({ error: "field_id é obrigatório para PUT" });
        }

        console.log("Updating field with ID:", field_id, "and body:", body);

        const response = await fetch(`${baseURL}/${field_id}?survey_type=${survey_type}`, {
          method: "PUT",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
          body: JSON.stringify(body),
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      case "DELETE": {
        if (!field_id) {
          return res.status(400).json({ error: "field_id é obrigatório para DELETE" });
        }
        const response = await fetch(`${baseURL}/${field_id}?survey_type=${survey_type}`, {
          method: "DELETE",
          headers: {
            Authorization: `Bearer ${token}`,
            "Content-Type": "application/json",
          },
        });

        const data = await response.json();
        return res.status(response.status).json(data);
      }

      default:
        return res.status(405).json({ error: `Método ${method} não permitido.` });
    }
  } catch (error) {
    console.error("[API][fields] Erro:", error);
    return res.status(500).json({ error: "Erro interno no proxy de fields." });
  }
}


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "field_id",
    "survey_id",
    "survey_type",
    "title",
    "description",
    "input_type_id",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      title,
      description,
      input_type_id,
      field_id
    } = req.query;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      title,
      description,
      input_type_id,
      field_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields/${field_id}?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        title,
        description,
        input_type_id
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : hello.js
📂 Pasta   : pages/api
🧭 Caminho : pages/api/hello.js
--------------------------------------
📜 Conteúdo:

// Next.js API route support: https://nextjs.org/docs/api-routes/introduction

export default function handler(req, res) {
  res.status(200).json({ name: "John Doe" });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/input-types
🧭 Caminho : pages/api/input-types/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";
export default async function handler(req, res) {
  
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const response = await fetch(`${process.env.SERVER_URL}/input_types`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
    });


    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data.input_types);

  } catch (err) {
    console.error("Erro ao buscar input_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/[id].js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";


const BASE_URL = process.env.SERVER_URL || "http://localhost:8000";

async function fetchWithAuth(url, token) {
  const res = await fetch(url, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  const data = await res.json();
  return { ok: res.ok, status: res.status, data };
}

async function getResearchDetails(id, token) {
  const { ok, status, data } = await fetchWithAuth(`${BASE_URL}/research/${id}`, token);
  if (!ok) {
    throw { status, message: "Erro ao buscar dados da pesquisa", details: data };
  }
  return data.research;
}

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Método não permitido" });
  }

  const {
    query: { id },
  } = req;

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  try {
    const [research] = await Promise.all([
      getResearchDetails(id, token)
    ]);

    return res.status(200).json({research});
  } catch (error) {
    console.error("Erro ao buscar dados da pesquisa:", error);
    return res
      .status(error.status || 500)
      .json({ error: error.message || "Erro interno", details: error.details });
  }
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const BASE_URL = process.env.SERVER_URL;

async function createResearch(researchData, token) {
  const researchRes = await fetch(`${BASE_URL}/research`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(researchData),
  });

  const data = await researchRes.json();

  if (!researchRes.ok) {
    throw {
      status: researchRes.status,
      message: "Erro ao criar a pesquisa",
      details: data,
    };
  }

  return data.research;
}


function validateRequest(req) {
  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    throw {
      status: 401,
      message: "Token não fornecido",
    };
  }

  const created_by = req.headers["x-user-id"] || req.body.created_by;

  if (!created_by) {
    throw {
      status: 400,
      message: "ID do criador não fornecido.",
    };
  }

  return { token, created_by };
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Método não permitido" });
  }

  try {
    const { token, created_by } = validateRequest(req);

    const {
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title
    } = req.body;

    const researchPayload = {
      title,
      description,
      release_date: release_date,
      end_date: end_date,
      lat,
      long,
      location_title,
      created_by,
    };

    var research = await createResearch(researchPayload, token);

    return res.status(201).json(
      research,
    );
  } catch (error) {
    console.error("Erro interno:", error);
    return res.status(error.status || 500).json({
      error: error.message || "Erro interno no servidor",
      details: error.details,
    });
  }
}






============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/delete.js
--------------------------------------
📜 Conteúdo:

// deleteResearch.js

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { id } = req.body;

    if (!id) {
      return res.status(400).json({ error: "ID é obrigatório para deletar a pesquisa." });
    }

    const response = await fetch(`${process.env.SERVER_URL}/research/${id}`, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    return res.status(200).json({ message: "Pesquisa deletada com sucesso." });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET" && req.method !== "POST") {
    return res.status(405).json({ error: "Método não permitido" });
  }
  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  if (req.method === "GET") {
    try {
      const response = await fetch(`${process.env.SERVER_URL}/research/`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return res.status(response.status).json(data);
      }

      return res.status(200).json(data?.researches || []);
    } catch (err) {
      console.error("Erro ao buscar pesquisas:", err);
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }

  if (req.method === "POST") {
    const { titulo, descricao, data_criacao } = req.body;

    if (!titulo || !descricao || !data_criacao) {
      return res.status(400).json({ error: "Dados inválidos: título, descrição e data_criacao são obrigatórios" });
    }

    try {
      const response = await fetch(`${process.env.SERVER_URL}/research/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          titulo,
          descricao,
          data_criacao,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        return res.status(response.status).json(data);
      }

      return res.status(201).json(data);
    } catch (err) {
      console.error("Erro ao criar pesquisa:", err);
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }
}


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

async function updateResearch(token, researchId, researchData) {
  const response = await fetch(
    `${process.env.SERVER_URL}/research/${researchId}`,
    {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(researchData),
    }
  );
  return response;
}


export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      id,
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title, 
      status
    } = req.body;

    if (
      !id ||
      !title ||
      !description ||
      !release_date ||
      !lat ||
      !long ||
      !location_title
    ) {
      return res
        .status(400)
        .json({ error: "Todos os campos obrigatórios devem ser preenchidos." });
    }

    const researchData = {
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title,
      status
    };

  
    const updateResponse = await updateResearch(token, id, researchData);
    if (!updateResponse.ok) {
      const errorData = await updateResponse.json();
      return res.status(updateResponse.status).json(errorData);
    }
    const updatedResearch = await updateResponse.json();

    return res.status(200).json(updatedResearch);
  } catch (err) {
    console.error("Erro no handler:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/survey-answers
🧭 Caminho : pages/api/survey-answers/[id].js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const { id } = req.query;

  if (!id || typeof id !== 'string') return res.status(400).json({ error: 'ID inválido' });

  const url = `${process.env.API_BASE_URL}/survey-answers/${id}`;

  try {
    if (req.method === 'GET') {
      const response = await fetch(url);
      const data = await response.json();
      return res.status(200).json(data);
    }

    if (req.method === 'PUT') {
      const response = await fetch(url, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    }

    if (req.method === 'DELETE') {
      const response = await fetch(url, {
        method: 'DELETE',
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    }

    return res.status(405).json({ error: 'Método não permitido' });
  } catch (error) {
    return res.status(500).json({ error: 'Erro ao processar a requisição' });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-answers
🧭 Caminho : pages/api/survey-answers/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  if (req.method === 'GET') {
    try {
      const response = await fetch(`${process.env.API_BASE_URL}/survey-answers`);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar respostas da survey' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(`${process.env.API_BASE_URL}/survey-answers`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar resposta da survey' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/survey-contributors
🧭 Caminho : pages/api/survey-contributors/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  try {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }
    console.log("bodyyyy:", req.body);

    const { survey_id, survey_type, user_id, instruction } = req.body;
    if (!survey_id || !survey_type || !user_id || !instruction) {
      return res
        .status(400)
        .json({ error: "survey_id e survey_type são obrigatórios" });
    }
    const response = await fetch(
      `${process.env.SERVER_URL}/survey/${survey_id}/contributors`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          survey_type: survey_type,
          user_id: user_id,
          instruction: instruction,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    if (!data) {
      return res.status(404).json({ error: "Erro ao adicionar um contribuidor à coleta." });
    }

    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

export default handler;


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/survey-contributors
🧭 Caminho : pages/api/survey-contributors/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
    try {
      if (req.method !== "DELETE") {
        return res.status(405).json({ error: "Method not allowed" });
      }
      const cookies = parse(req.headers.cookie || "");
      const token = cookies.token;
      if (!token) {
        return res.status(401).json({ error: "Token não fornecido" });
      }
  
      const { survey_id, user_id } = req.query;

      if (!survey_id || !user_id) {
        return res.status(400).json({ error: "ID da coleta ou do usuário não fornecido" });

      }
      
      const response = await fetch(
        `${process.env.SERVER_URL}/survey/${survey_id}/contributors/${user_id}`,
        {
          method: "DELETE",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
        }
      );
  
      if (!response.ok) {
        const errorData = await response.json();
        return res.status(response.status).json(errorData);
      }
      const data = await response.json();
      if (!data) {
        return res.status(404).json({ error: "Erro ao deletar um contribuidor da coleta." });
      }
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  };
  
  export default handler;
  

============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-contributors
🧭 Caminho : pages/api/survey-contributors/index.js
--------------------------------------
📜 Conteúdo:

// src/pages/api/survey-contributors/index.js
import { parse } from "cookie";

export default async function handler(req, res) {
  const baseUrl = `${process.env.SERVER_URL}/survey`;
  const { survey_id, contributor_id } = req.query;
  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  if (!survey_id) {
    return res.status(400).json({ error: "survey_id é obrigatório" });
  }

  if (req.method === "GET") {
    try {
      const url = `${baseUrl}/${survey_id}/contributors`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });

      const data = await response.json();
      if (!response.ok) return res.status(response.status).json(data);

      return res.status(200).json(data.contributors);
    } catch (err) {
      console.error("Erro ao buscar contribuidores:", err);
      return res.status(500).json({ error: "Erro ao buscar contribuidores" });
    }
  }

  if (req.method === "POST") {
    const { survey_type, user_id, instruction } = req.body;

    if (!survey_type || !user_id || !instruction) {
      return res.status(400).json({
        error: "Campos survey_type, user_id e instruction são obrigatórios",
      });
    }

    try {
      const url = `${baseUrl}/${survey_id}/contributors`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          survey_type,
          user_id,
          instruction,
        }),
      });

      const data = await response.json();
      if (!response.ok) return res.status(response.status).json(data);

      return res.status(201).json(data.contributor);
    } catch (err) {
      console.error("Erro ao criar colaborador:", err);
      return res.status(500).json({ error: "Erro ao criar colaborador" });
    }
  }

  if (req.method === "DELETE") {
    if (!contributor_id) {
      return res.status(400).json({ error: "contributor_id é obrigatório para deletar" });
    }

    try {
      const url = `${baseUrl}/${survey_id}/contributors/${contributor_id}`;
      const response = await fetch(url, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });

      const data = await response.json();
      if (!response.ok) return res.status(response.status).json(data);

      return res.status(200).json(data);
    } catch (err) {
      console.error("Erro ao deletar colaborador:", err);
      return res.status(500).json({ error: "Erro ao deletar colaborador" });
    }
  }

  return res.status(405).json({ error: "Método não permitido" });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-groups
🧭 Caminho : pages/api/survey-groups/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/survey-groups`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar grupos de survey' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar grupo' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-regions
🧭 Caminho : pages/api/survey-regions/index.js
--------------------------------------
📜 Conteúdo:

// src/pages/api/survey-regions/index.js
import { parse } from "cookie";

export default async function handler(req, res) {
  const baseUrl = `${process.env.SERVER_URL}/survey`;
  const { survey_id, id } = req.query;
  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  if (req.method === "GET") {
    try {
      const url = `${baseUrl}/${survey_id}/region`;
      const response = await fetch(url, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (!response.ok) {
        return res.status(response.status).json(data);
      }
      return res.status(200).json(data.regions);
    } catch (err) {
      console.error("Erro ao buscar regiões:", err);
      return res.status(500).json({ error: "Erro ao buscar regiões" });
    }
  }

  if (req.method === "POST") {
    const { name, lat, long, location_title, survey_type } = req.body;
    try {
      const url = `${baseUrl}/${survey_id}/region?survey_type=${survey_type}`;
      const response = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          name,
          lat,
          long,
          location_title,
        }),
      });
      const data = await response.json();
      if (!response.ok) {
        return res.status(response.status).json(data);
      }
      return res.status(201).json(data.region);
    } catch (err) {
      console.error("Erro ao criar região:", err);
      return res.status(500).json({ error: "Erro ao criar região" });
    }
  }

  if (req.method === "DELETE") {
    try {
      const url = `${baseUrl}/${survey_id}/region/${id}`;
      const response = await fetch(url, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
      });
      const data = await response.json();
      if (!response.ok) {
        return res.status(response.status).json(data);
      }
      return res.status(200).json(data);
    } catch (err) {
      console.error("Erro ao deletar região:", err);
      return res.status(500).json({ error: "Erro ao deletar região" });
    }
  }

  return res.status(405).json({ error: "Método não permitido" });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-time-ranges
🧭 Caminho : pages/api/survey-time-ranges/index.js
--------------------------------------
📜 Conteúdo:

// src/pages/api/survey-time-ranges/index.js
import { parse } from "cookie";

/**
 * Rotas Go ⇄ Frontend
 *  GET    /survey/:surveyId/time-range                 → listar faixas
 *  POST   /survey/:surveyId/time-range?survey_type=..  → criar faixa
 *  DELETE /survey/:surveyId/time-range/:id             → deletar faixa
 *
 * O cookie token (Bearer) é encaminhado em todas as requisições.
 */
export default async function handler(req, res) {
  const { survey_id, id } = req.query;         // id == time-rangeId (DELETE)
  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }
  if (!survey_id) {
    return res.status(400).json({ error: "survey_id é obrigatório" });
  }

  const baseUrl = `${process.env.SERVER_URL}/survey/${survey_id}/time`;

  // ---------- LISTAR ----------
  if (req.method === "GET") {
    try {
      const resp = await fetch(baseUrl, {
        headers: { Authorization: `Bearer ${token}` },
      });
      const json = await resp.json();
      if (!resp.ok) return res.status(resp.status).json(json);
      // o controller devolve em survey_times[]  :contentReference[oaicite:0]{index=0}&#8203;:contentReference[oaicite:1]{index=1}
      return res.status(200).json(json.survey_times ?? json);
    } catch (err) {
      console.error("GET time-ranges:", err);
      return res.status(500).json({ error: "Erro ao buscar faixas de horário" });
    }
  }

  // ---------- CRIAR ----------
  if (req.method === "POST") {
    const { start_time, end_time, survey_type } = req.body;
    if (!start_time || !end_time || !survey_type) {
      return res.status(400).json({ error: "start_time, end_time e survey_type são obrigatórios" });
    }

    try {
      const url = `${baseUrl}?survey_type=${encodeURIComponent(survey_type)}`;
      const resp = await fetch(url, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({ start_time, end_time }),
      });
      const json = await resp.json();
      if (!resp.ok) return res.status(resp.status).json(json);
      // o controller devolve em survey_time {}  :contentReference[oaicite:2]{index=2}&#8203;:contentReference[oaicite:3]{index=3}
      return res.status(201).json(json.survey_time ?? json);
    } catch (err) {
      console.error("POST time-ranges:", err);
      return res.status(500).json({ error: "Erro ao criar faixa de horário" });
    }
  }

  // ---------- DELETAR ----------
  if (req.method === "DELETE") {
    if (!id) return res.status(400).json({ error: "id do time-range ausente" });

    try {
      const resp = await fetch(`${baseUrl}/${id}`, {
        method: "DELETE",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });
      const json = await resp.json();
      if (!resp.ok) return res.status(resp.status).json(json);
      return res.status(200).json(json);
    } catch (err) {
      console.error("DELETE time-ranges:", err);
      return res.status(500).json({ error: "Erro ao deletar faixa de horário" });
    }
  }

  return res.status(405).json({ error: "Método não permitido" });
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/[id].js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { survey_id, research_id, survey_type } = req.query;
    let missingFields = checkMissingFields([
      survey_id,
      research_id,
      survey_type,
    ]);

    if (missingFields.length > 0) {
      return res
        .status(400)
        .json({ error: `Os campos são obrigatórios: ${missingFields}` });
    }

    const response = await fetch(
      `${process.env.SERVER_URL}/research/${research_id}/survey/${survey_id}?survey_type=${encodeURIComponent(survey_type)}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    console.error("Erro ao buscar activity_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ["survey_type", "survey_id", "research_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/surveys/answers
🧭 Caminho : pages/api/surveys/answers/index.js
--------------------------------------
📜 Conteúdo:

// pages/api/survey/answers/batch.js

export default async function handler(req, res) {
    if (req.method !== 'POST') {
      return res.status(405).json({ message: 'Método não permitido' });
    }
  
    try {
      const { answers } = req.body;
  
      if (!answers || !Array.isArray(answers) || answers.length === 0) {
        return res.status(400).json({ message: 'Formato de dados inválido' });
      }

    try {
        const cookies = parse(req.headers.cookie || "");
        const token = cookies.token;
    
        if (!token) {
        return res.status(401).json({ error: "Token não fornecido" });
        }
    } catch (error) {
        console.error('Erro ao processar cookies:', error);
        return res.status(500).json({ message: 'Erro interno do servidor' });
    }
      
  
      // Validar cada resposta
      for (const answer of answers) {
        const { field_id, value, survey_id, survey_type, contributor_id, survey_group_id } = answer;
        
        if (!field_id || !survey_id || !survey_type || !contributor_id || !survey_group_id) {
          return res.status(400).json({ 
            message: 'Dados incompletos em uma ou mais respostas',
            invalid: answer 
          });
        }
      }
  
      // Processar todas as respostas em paralelo
      const results = await Promise.all(
        answers.map(async (answer) => {
          const { field_id, value, survey_id, survey_type, contributor_id, survey_group_id } = answer;
          
          const response = await fetch(`${process.env.SERVER_URL}/survey/${survey_id}/answer`, {
            method: 'POST',
            headers: { 
              'Content-Type': 'application/json',
              'Authorization': `Bearer ${token}` 
            },
            body: JSON.stringify({
              field_id,
              value,
              survey_id,
              survey_type,
              contributor_id,
              survey_group_id
            })
          });
  
          if (!response.ok) {
            const errorData = await response.json();
            throw new Error(`Erro ao processar resposta para campo ${field_id}: ${errorData.message}`);
          }
  
          return await response.json();
        })
      );
  
      return res.status(200).json({ 
        success: true, 
        message: 'Todas as respostas foram processadas com sucesso',
        results 
      });
      
    } catch (error) {
      console.error('Erro ao processar respostas em lote:', error);
      return res.status(500).json({ 
        success: false,
        message: error.message || 'Erro interno do servidor ao processar respostas' 
      });
    }
  }

============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  try {

    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    
    const {survey_type, title, description, lat, long, location_title, research_id} = req.body;
    let missingFields = checkMissingFields({
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id,
    });
    
    if (missingFields.length > 0) {
      return res
        .status(400)
        .json({ error: `Os campos são obrigatórios: ${missingFields}` });
    }
    const response = await fetch(
      `${process.env.SERVER_URL}/survey?survey_type=${encodeURIComponent(survey_type)}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          title: title,
          description: description,
          lat: lat,
          long: long,
          location_title: location_title,
          research_id: research_id
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    if (!data) {
      return res.status(404).json({ error: "Erro ao adicionar um contribuidor à coleta." });
    }

    return res.status(200).json(data.survey);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};


const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "survey_type", "title", "description", "lat", "long", "location_title", "research_id"
  ];

  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from 'cookie';
import { json } from 'stream/consumers';

const handler = async (req, res) => {
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const cookies = parse(req.headers.cookie || '');
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: 'Token não fornecido' });
    }
    const data = JSON.parse(req.body);
    const { id, research_id, survey_type } = data;
    const missingFields = checkMissingFields({ id, research_id, survey_type });
    if (missingFields.length > 0) {
      return res.status(400).json({ error: `Os campos são obrigatórios: ${missingFields.join(', ')}` });
    }

    const response = await fetch(`${process.env.SERVER_URL}/research/${research_id}/survey/${id}?survey_type=${encodeURIComponent(survey_type)}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    return res.status(200).json({ message: 'Survey deletado com sucesso' });
  } catch (err) {
    console.error('Erro ao deletar survey:', err);
    return res.status(500).json({ error: 'Erro ao conectar com o servidor' });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ['id', 'research_id', 'survey_type'];
  return requiredFields.filter(field => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id, survey_type } = req.query;

    const missingFields = checkMissingFields({ research_id, survey_type });
    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/research/${research_id}/survey?survey_type=${encodeURIComponent(
      survey_type
    )}`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data.surveys[0] || {});
  } catch (err) {
    console.error("Erro ao buscar surveys:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "survey_type"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    console.log("upbody:", req.body);
    const {
      id,
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id
    } = req.body;

    const missingFields = checkMissingFields({
      id,
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id,
    });

    if (missingFields.length > 0) {
      return res.status(400).json({ error: `Os campos são obrigatórios: ${missingFields.join(', ')}` });
    }

    const response = await fetch(`${process.env.SERVER_URL}/survey/${id}?survey_type=${encodeURIComponent(
      survey_type
    )}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        survey_type,
        title,
        description,
        lat,
        long,
        location_title,
        research_id,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    console.error("Erro ao atualizar o survey:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "id",
    "survey_type",
    "title",
    "description",
    "lat",
    "long",
    "location_title",
    "research_id"
  ];

  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/sync
🧭 Caminho : pages/api/sync/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  const { entity } = req.query;

  if (!entity)
    return res.status(400).json({ error: "Entity não especificada" });

  const baseURL = `https://placemaking-server-go.vercel.app/api/v1`;
  const url = `${baseURL}/sync/${entity}`;

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;
  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  try {
    if (req.method === "GET") {
      const response = await fetch(url, {
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });
      if (!response.ok) throw new Error(`Erro ao buscar ${entity}`);
      const data = await response.json();
      // return res.status(200).json({ [entity]: data });
      return res.status(200).json(data);
    }

    if (req.method === "PATCH") {
      const response = await fetch(url, {
        method: "PATCH",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify(req.body),
      });
      if (!response.ok) throw new Error(`Erro ao sincronizar ${entity}`);
      const data = await response.json();
      return res.status(200).json(data);
    }

    return res.status(405).json({ error: "Método não permitido" });
  } catch (error) {
    console.error(`[API SYNC] Erro:`, error);
    return res.status(500).json({ error: "Erro interno ao sincronizar dados" });
  }
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/[id].js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
    if (req.method !== "GET") {
      return res.status(405).json({ error: "Method not allowed" });
    }
  
    const { id } = req.query;
  
    const token = req.cookies?.token;
    if (!token) return res.status(401).json({ error: "Token não encontrado" });
  
    try {
      const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });
  
      const data = await response.json();
      if (!response.ok) {
        return res.status(response.status).json({ error: data.message || "Erro ao buscar usuário" });
      }
  
      return res.status(200).json({ user: data });
    } catch (err) {
      console.error("[GET /api/users/[id]]", err);
      return res.status(500).json({ error: "Erro interno ao buscar usuário" });
    }
  }
  

============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/delete.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { id } = req.body;

  if (!id) {
    return res.status(400).json({ error: "ID do usuário não fornecido" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data);
  } catch (err) {
    console.error("[delete]", err);
    return res.status(500).json({ error: "Erro ao deletar usuário" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
    });

    const data = await response.json();
    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data.users);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : register.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/register.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { name, email, role, status } = req.body;
  const confirmation_email = req.body.confirmation_email || email;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/register`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
      body: JSON.stringify({ name, email, confirmation_email, role, status }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data.user);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/update.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { id, name, email, role, status } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ name, email, role, status }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }


    return res.status(200).json(data);
  } catch (err) {

    console.error("[update]", err);
    return res.status(500).json({ error: "Erro ao atualizar usuário" });
  }
}


============================================================


📄 Arquivo : forgot-password.js
📂 Pasta   : pages
🧭 Caminho : pages/forgot-password.js
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import Image from "next/image";
import Button from "@/components/ui/Button";
import { motion } from "framer-motion";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import Link from "next/link";
import { useRouter } from "next/router"; 

export default function ForgotPassword() {
  const [email, setEmail] = useState("");
  const { showMessage } = useMessage();
  const { isLoading, setIsLoading } = useLoading();
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const response = await fetch("/api/auth/forgot-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || "Erro ao enviar email");
      }

      showMessage(
        "Se o email estiver cadastrado, você receberá o código para recuperar sua senha.",
        "verde"
      );
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 10000);
    } finally {
      setIsLoading(false);
      localStorage.setItem("recover_email", email);
      router.push("/validate-code"); 
    }
  };

  return (
    <div
      className="h-screen flex items-center justify-center p-8 bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken"
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <h2 className="text-xl font-semibold text-center text-gray-800 mb-4">
          Recuperar Senha
        </h2>

        <form className="space-y-4" onSubmit={handleSubmit}>
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              inputMode="email"
              autoComplete="email"
              className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="seu@email.com"
              required
            />
          </div>
          <div className="flex justify-end p-2">
            <Link
              href="/login"
              className="text-sm text-blue-500 hover:underline"
            >
              Login?
            </Link>
          </div>

          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Enviando..." : "Enviar"}
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

ForgotPassword.pageName = "Recuperar Senha";
ForgotPassword.layout = "public";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages
🧭 Caminho : pages/index.js
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { motion } from "framer-motion";
import { useLoading } from "@/context/LoadingContext";
import FiltersComponent from "@/components/ui/FiltersComponent";
import { useMessage } from "@/context/MessageContext";
import { useRouter } from "next/router";
import ResearchCardDashboard from "@/components/ui/Research/ResearchCardDashboard";
import ResearchCardSkeleton from "@/components/ui/Research/ResearchCardSkeleton";
import Switch from "@/components/ui/Switch";
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";
import { useResearches } from "@/hooks/useResearches"; // << usando o hook certo!
import { Info } from "lucide-react";
import {
  ResponsiveContainer,
  PieChart,
  Pie,
  Cell,
  Tooltip,
  Legend,
} from "recharts";

export default function Home() {
  const { researches, loading } = useResearches(); // << usando hook
  const [filters, setFilters] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");
  const [showCategory, setShowCategory] = useState({
    completed: false,
    ongoing: true,
    future: true,
  });
  const [selectedResearch, setSelectedResearch] = useState(null);
  const [page, setPage] = useState({ completed: 1, ongoing: 1, future: 1 });
  const perPage = 3;
  const { setIsLoading } = useLoading();
  const { showMessage } = useMessage();
  const [showFilters, setShowFilters] = useState(false);
  const router = useRouter();

  const currentDate = new Date();
  const categorizedResearches = {
    completed: [],
    ongoing: [],
    future: [],
  };

  // Mockando os dados para o gráfico

  const charData = [
    {
      id: 1,
      title: "Uso do espaço público",
      description:
        "Com que frequência você utiliza os espaços públicos da sua região?",
      chartData: [
        { label: "Diariamente", value: 40 },
        { label: "Semanalmente", value: 30 },
        { label: "Raramente", value: 20 },
        { label: "Nunca", value: 10 },
      ],
    },
    {
      id: 2,
      title: "Atividades preferidas",
      description: "Quais atividades você mais realiza nos espaços públicos?",
      chartData: [
        { label: "Caminhada", value: 45 },
        { label: "Lazer com crianças", value: 25 },
        { label: "Encontros sociais", value: 20 },
        { label: "Atividades físicas", value: 10 },
      ],
    },
    {
      id: 3,
      title: "Sensação de segurança",
      description:
        "Como você avalia a segurança nos espaços públicos da sua área?",
      chartData: [
        { label: "Muito seguro", value: 15 },
        { label: "Relativamente seguro", value: 50 },
        { label: "Pouco seguro", value: 25 },
        { label: "Inseguro", value: 10 },
      ],
    },
    {
      id: 4,
      title: "Infraestrutura percebida",
      description: "Como você avalia a infraestrutura dos espaços públicos?",
      chartData: [
        { label: "Excelente", value: 10 },
        { label: "Boa", value: 35 },
        { label: "Regular", value: 30 },
        { label: "Ruim", value: 25 },
      ],
    },
  ];

  // Cores para os gráficos
  const COLORS = [
    "#0088FE",
    "#00C49F",
    "#FFBB28",
    "#FF8042",
    "#A28EFF",
    "#FF6699",
  ];

  // Paginação das Researches do Footer
  const itemsPerPage = 5;
  const [currentPage, setCurrentPage] = useState(1);
  const startIndex = (currentPage - 1) * itemsPerPage;
  const endIndex = startIndex + itemsPerPage;
  const totalPages = Math.ceil(researches.length / itemsPerPage);

  const nextPage = () => {
    if (endIndex < researches.length) setCurrentPage((prev) => prev + 1);
  };

  const prevPage = () => {
    if (currentPage > 1) setCurrentPage((prev) => prev - 1);
  };

  //Paginação dos gráficos

  const [chartPage, setChartPage] = useState(0);
  const totalChartPages = charData.length;

  const nextChart = () => {
    if (chartPage < totalChartPages - 1) setChartPage((prev) => prev + 1);
  };

  const prevChart = () => {
    if (chartPage > 0) setChartPage((prev) => prev - 1);
  };

  researches.forEach((research) => {
    const endDate = new Date(research.end_date);
    const startDate = new Date(research.release_date);
    if (endDate < currentDate) {
      categorizedResearches.completed.push(research);
    } else if (startDate > currentDate) {
      categorizedResearches.future.push(research);
    } else {
      categorizedResearches.ongoing.push(research);
    }
  });

  const handleResearchClick = (research) => {
    setSelectedResearch(research);
  };

  const filterAndSortResearches = (list) => {
    return list
      .filter(
        (research) =>
          research.title.toLowerCase().includes(filters.toLowerCase()) ||
          research.description.toLowerCase().includes(filters.toLowerCase()) ||
          research.location_title.toLowerCase().includes(filters.toLowerCase())
      )
      .sort((a, b) => {
        const dateA = new Date(a.created_at);
        const dateB = new Date(b.created_at);
        return sortOrder === "asc" ? dateA - dateB : dateB - dateA;
      });
  };

  return (
    <motion.section
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="bg-transparent rounded-2xl p-6 md:p-8 gap-6"
    >
      <div className="min-h-screen bg-transparent">
        <main className="p-4 md:p-8 max-w-8xl mx-auto">
          <motion.div
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.5 }}
            className="flex items-center gap-4 bg-blue-50 border border-blue-200 text-blue-700 p-4 rounded-lg shadow-sm mb-8"
          >
            <Info size={24} className="text-blue-500" />
            <div className="text-sm font-medium">
              <strong>Aviso:</strong> Esta página ainda está em desenvolvimento.
              Em breve você verá aqui as pesquisas futuras e resumos de dados
              para resposta rápida.
            </div>
          </motion.div>
          <motion.section
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            transition={{ duration: 0.4 }}
            className="bg-transparent rounded-2xl p-6 md:p-8"
          >
            <div className="flex flex-col md:flex-row md:justify-between md:items-center mb-6">
              <h2 className="text-3xl font-bold text-gray-800">
                Suas Pesquisas
              </h2>
  
            <FiltersComponent
              showFilters={showFilters}
              setShowFilters={setShowFilters}
              variants={VARIANTS}
              filters={[
                {
                  key: "filters",
                  label: "Buscar por título, descrição ou local",
                  icon: "search",
                  type: "text",
                  value: filters,
                  defaultValue: "",
                },
                {
                  key: "sortOrder",
                  label: "Ordenação",
                  icon: "sort",
                  type: "button-group",
                  value: sortOrder,
                  defaultValue: "asc",
                  options: [
                    { label: "Mais Recentes", value: "asc" },
                    { label: "Mais Antigos", value: "desc" },
                  ],
                },
                {
                  key: "showCategory",
                  label: "Mostrar categorias",
                  type: "switch-group",
                  options: [
                    {
                      label: "Pesquisas Já Realizadas",
                      value: "completed",
                      checked: showCategory.completed,
                    },
                    {
                      label: "Pesquisas em Andamento",
                      value: "ongoing",
                      checked: showCategory.ongoing,
                    },
                    {
                      label: "Pesquisas Futuras",
                      value: "future",
                      checked: showCategory.future,
                    },
                  ],
                },
              ]}
              onChange={(key, value) => {
                if (key === "filters") setFilters(value);
                if (key === "sortOrder") setSortOrder(value);
                if (key === "showCategory") {
                  setShowCategory((prev) => ({ ...prev, ...value }));
                }
              }}
              onClear={() => {
                setFilters("");
                setSortOrder("asc");
                setShowCategory({
                  completed: true,
                  ongoing: true,
                  future: true,
                });
              }}
            />
</div>
            {loading
              ? Array.from({ length: 6 }).map((_, index) => (
                  <ResearchCardSkeleton key={index} />
                ))
              : Object.entries(categorizedResearches).map(([key, list]) => {
                  if (!showCategory[key]) return null;
                  const filteredAndSorted = filterAndSortResearches(list);
                  const totalPages = Math.ceil(
                    filteredAndSorted.length / perPage
                  );

                  const handlePrevious = () => {
                    setPage((prev) => ({
                      ...prev,
                      [key]: Math.max(prev[key] - 1, 1),
                    }));
                  };

                  const handleNext = () => {
                    setPage((prev) => ({
                      ...prev,
                      [key]: Math.min(prev[key] + 1, totalPages),
                    }));
                  };

                  return (
                    <div key={key} className="mt-10">
                      <h3 className="text-2xl font-semibold mb-4 text-gray-700">
                        {key === "completed"
                          ? "Pesquisas Passadas"
                          : key === "ongoing"
                          ? "Pesquisas em Andamento"
                          : "Pesquisas Futuras"}
                      </h3>

                      {filteredAndSorted.length === 0 ? (
                        <p className="text-gray-500 text-sm">
                          Nenhuma pesquisa encontrada.
                        </p>
                      ) : (
                        <motion.div
                          layout
                          className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 gap-6"
                        >
                          {filteredAndSorted
                            .slice(
                              (page[key] - 1) * perPage,
                              page[key] * perPage
                            )
                            .map((research) => (
                              <motion.div
                                key={research.id}
                                layout
                                initial={{ opacity: 0 }}
                                animate={{ opacity: 1 }}
                                transition={{ duration: 0.3 }}
                              >
                                <ResearchCardDashboard
                                  showButton={true}
                                  research={research}
                                />
                              </motion.div>
                            ))}
                        </motion.div>
                      )}

                      {filteredAndSorted.length > perPage && (
                        <div className="flex items-center justify-between gap-6 mt-6">
                          <Button
                            onClick={handlePrevious}
                            disabled={page[key] === 1}
                            variant="secondary"
                            className="px-4 py-2 text-sm"
                          >
                            Anterior
                          </Button>
                          <span className="text-sm text-gray-700">
                            Página {page[key]} de {totalPages}
                          </span>
                          <Button
                            onClick={handleNext}
                            disabled={page[key] === totalPages}
                            variant="secondary"
                            className="px-4 py-2 text-sm"
                          >
                            Próxima
                          </Button>
                        </div>
                      )}

                      <hr className="my-6 border-gray-200" />
                    </div>
                  );
                })}
            <div className="flex flex-col gap-2">
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                transition={{ duration: 0.3 }}
                className="flex flex-row items-center gap-2 bg-slate-300 rounded-full px-2 py-1 text-sm text-gray-500 w-50"
              >
                <span className="material-symbols-outlined text-gray-500">
                  search
                </span>
                <p className="text-sm text-gray-500">
                  Busque aqui por título, descrição ou local
                </p>
              </motion.div>
              <div className="grid grid-cols-2 gap-4 mt-10">
                <div className="flex flex-col items-center gap-2">
                  <motion.div
                    initial={{ opacity: 0, y: 10 }}
                    animate={{ opacity: 1, y: 0 }}
                    transition={{ duration: 0.3 }}
                    className="w-full h-full bg-white shadow-md rounded-lg p-4 space-y-2"
                  >
                    <div className="flex items-center justify-between mb-2">
                      <h3 className="text-lg font-semibold text-gray-700">
                        Pesquisas
                      </h3>
                      <div className="flex flex-row items-center justify-between gap-4 px-2 py-3">
                        <span className="material-symbols-outlined text-gray-500">
                          info
                        </span>
                        <p className="text-sm text-gray-500">
                          Clique em uma pesquisa para ver mais detalhes ou
                          responder.
                        </p>
                      </div>
                    </div>

                    {/* Lista de pesquisas */}
                    <ul className="space-y-2 max-h-64 overflow-y-auto">
                      {researches
                        .slice(startIndex, endIndex)
                        .map((research) => (
                          <li
                            key={research.id}
                            className="p-3 border border-gray-200 rounded hover:bg-gray-100 cursor-pointer"
                            onClick={() => handleResearchClick(research)}
                          >
                            <p className="font-medium">{research.title}</p>
                            <p className="text-sm text-gray-500">
                              {research.description}
                            </p>
                          </li>
                        ))}
                    </ul>

                    {/* Paginação */}
                    <div className="flex justify-between items-center pt-2 text-sm">
                      <button
                        onClick={prevPage}
                        disabled={currentPage === 1}
                        className="px-3 py-1 bg-slate-100 rounded disabled:opacity-50"
                      >
                        Anterior
                      </button>
                      <span className="text-gray-600">
                        Página {currentPage} - {totalPages}
                      </span>
                      <button
                        onClick={nextPage}
                        disabled={endIndex >= researches.length}
                        className="px-3 py-1 bg-slate-100 rounded disabled:opacity-50"
                      >
                        Próxima
                      </button>
                    </div>
                  </motion.div>
                </div>
                <div className="flex items-center gap-2 w-full h-full justify-center">
                  {selectedResearch ? (
                    <motion.div
                      key={selectedResearch.id}
                      initial={{ opacity: 0, x: 10 }}
                      animate={{ opacity: 1, x: 0 }}
                      transition={{ duration: 0.3 }}
                      className="w-full bg-white shadow-md rounded-lg p-4 space-y-4 h-full"
                    >
                      <div className="flex justify-between items-center">
                        <h3 className="text-lg font-semibold text-gray-700">
                          {selectedResearch.title}
                        </h3>
                        <button
                          className="text-sm text-blue-600 underline"
                          onClick={() => viewResponses(selectedResearch.id)}
                        >
                          Ver respostas
                        </button>
                      </div>
                      <div className="w-full max-h-80 h-full flex flex-col items-center justify-center gap-2">
                        {charData.length > 0 && (
                          <>
                            <h2 className="text-base font-semibold text-gray-700 mb-1">
                              {charData[chartPage].title}
                            </h2>
                            <span className="text-sm text-gray-500">
                              {charData[chartPage].description}
                            </span>

                            <div className="w-full h-60 my-2">
                              <ResponsiveContainer width="100%" height="100%">
                                <PieChart>
                                  <Pie
                                    data={charData[chartPage].chartData}
                                    dataKey="value"
                                    nameKey="label"
                                    cx="50%"
                                    cy="50%"
                                    outerRadius={60}
                                    fill="#8884d8"
                                    label
                                  >
                                    {charData[chartPage].chartData.map(
                                      (_, index) => (
                                        <Cell
                                          key={`cell-${index}`}
                                          fill={COLORS[index % COLORS.length]}
                                        />
                                      )
                                    )}
                                  </Pie>
                                  <Tooltip />
                                  <Legend
                                    verticalAlign="bottom"
                                    height={2}
                                    fontSize={1}
                                  />
                                </PieChart>
                              </ResponsiveContainer>
                            </div>

                            <div className="flex justify-between text-sm mt-2">
                              <button
                                onClick={prevChart}
                                disabled={chartPage === 0}
                                className="px-3 py-1 bg-slate-100 rounded disabled:opacity-50"
                              >
                                Anterior
                              </button>
                              <span className="text-gray-600">
                                Gráfico {chartPage + 1} de {totalChartPages}
                              </span>
                              <button
                                onClick={nextChart}
                                disabled={chartPage >= totalChartPages - 1}
                                className="px-3 py-1 bg-slate-100 rounded disabled:opacity-50"
                              >
                                Próximo
                              </button>
                            </div>
                          </>
                        )}
                      </div>
                    </motion.div>
                  ) : (
                    <div className="text-sm text-gray-400 italic">
                      Selecione uma pesquisa
                    </div>
                  )}
                </div>
              </div>
            </div>
          </motion.section>
        </main>
      </div>
    </motion.section>
  );
}

Home.layout = "private";
Home.pageName = "Dashboard";


============================================================


📄 Arquivo : login.js
📂 Pasta   : pages
🧭 Caminho : pages/login.js
--------------------------------------
📜 Conteúdo:

import { use, useState } from "react";
import Button from "@/components/ui/Button";
import Image from "next/image";
import { motion } from "framer-motion";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import Link from "next/link";
import { useRouter } from "next/router";
import { useAuthentication } from "@/hooks";

export default function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);

  const { isLoading, setIsLoading } = useLoading(false);
  const { showMessage } = useMessage();
  const { login } = useAuthentication();
  const router = useRouter();

  const handleLogin = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      await login(email, password);
      showMessage("Login efetuado com sucesso!", "verde");
      router.push("/");
    } catch (err) {
      showMessage(err.message || "Erro ao fazer login", "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div
      className="
        h-screen flex items-center justify-center p-8
        bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken
      "
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <form className="space-y-4" onSubmit={handleLogin}>
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              inputMode="email"
              autoComplete="email"
              autoCorrect="off"
              className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="seu@email.com"
              required
            />
          </div>

          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              Senha
            </label>
            <div className="relative">
              <input
                type={showPassword ? "text" : "password"}
                id="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500 pr-14"
                placeholder="********"
                required
              />
              <button
                type="button"
                onClick={() => setShowPassword(!showPassword)}
                className="absolute top-1/2 right-4 transform -translate-y-1/2 text-sm hover:underline"
              >
                {showPassword ? "Ocultar" : "Mostrar"}
              </button>
            </div>
          </div>

          <div className="flex justify-end p-2">
            <Link
              href="/forgot-password"
              className="text-sm text-blue-500 hover:underline"
            >
              Esqueceu a senha?
            </Link>
          </div>
          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Entrando..." : "Entrar"}
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

Login.pageName = "Login";
Login.layout = "public";


============================================================


📄 Arquivo : offline.js
📂 Pasta   : pages
🧭 Caminho : pages/offline.js
--------------------------------------
📜 Conteúdo:

export default function HomeOffline() {
  return (
    <div style={{ textAlign: "center", padding: "20px" }}>
      <h1>Você está offline</h1>
      <p>Esta é uma versão offline do nosso site.</p>
      <p>Verifique sua conexão e tente novamente.</p>
    </div>
  );
}


============================================================


📄 Arquivo : reports.js
📂 Pasta   : pages
🧭 Caminho : pages/reports.js
--------------------------------------
📜 Conteúdo:



export default function Reports() {
    return (
        <div>
        <h1>Reports</h1>
        <p>This is the reports page.</p>
        </div>
    );
}

============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/researches/[id]
🧭 Caminho : pages/researches/[id]/index.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { useResearches } from "@/hooks/useResearches";
import { useUsers } from "@/hooks/useUsers";
import { useFormSurveys } from "@/hooks/useFormSurveys";
import { useStaticSurveys } from "@/hooks/useStaticSurveys";
import { useDynamicSurveys } from "@/hooks/useDynamicSurveys";
import ResearchForm from "@/components/research/ResearchForm";
import { useMessage } from "@/context/MessageContext";
import ResearchLoadingSkeleton from "@/components/research/ResearchLoadingSkeleton";
import SideBarSectionsFilter from "@/components/ui/SideBarSectionsFilter";
import AddSurveyPrompt from "@/components/surveys/AddSurveyPrompt";
import CollectionFormSection from "@/components/surveys/CollectionFormSection";
import CollectionStaticSection from "@/components/surveys/CollectionStaticSection";
import CollectionDynamicSection from "@/components/surveys/CollectionDynamicSection";
import { formatDataByModel } from "@/lib/types/models";

const SURVEY_TYPES = [
  { id: "formulario", label: "Formulário", icon: "description" },
  { id: "estatica", label: "Estática", icon: "insights" },
  { id: "dinamica", label: "Dinâmica", icon: "sync_alt" },
];

export default function EditResearch() {
  const router = useRouter();
  const { id } = router.query;
  const { showMessage } = useMessage();
  const { researchData, loading: loadingResearch, updateResearch } = useResearches(true, id);
  const { users, loading: loadingUsers } = useUsers();
  const { formSurvey } = useFormSurveys(id, true, "Formulário");
  const { staticSurvey } = useStaticSurveys(id, true, "Estática");
  const { dynamicSurvey } = useDynamicSurveys(id, true, "Dinâmica");
  const [renderedSurveys, setRenderedSurveys] = useState([]);
  const [isCreatingSurvey, setIsCreatingSurvey] = useState(false);

  const sidebarSections = [
    { id: "pesquisa", label: "Pesquisa", icon: "search" },
    ...SURVEY_TYPES,
  ];

  useEffect(() => {
    if (!id) return;
    const list = [];
    if (formSurvey) list.push(renderSurveyComponent("Formulário"));
    if (staticSurvey) list.push(renderSurveyComponent("Estática"));
    if (dynamicSurvey) list.push(renderSurveyComponent("Dinâmica"));
  }, [id, formSurvey, staticSurvey, dynamicSurvey]);

  const renderSurveyComponent = (surveyLabel) => {
    const surveyType = SURVEY_TYPES.find((t) => t.label === surveyLabel);
    if (!surveyType || renderedSurveys.some((s) => s.id === surveyType.id)) return;

    let SurveyComponent = null;
    switch (surveyLabel.toLowerCase()) {
      case "formulário":
        SurveyComponent = CollectionFormSection;
        break;
      case "estática":
        SurveyComponent = CollectionStaticSection;
        break;
      case "dinâmica":
        SurveyComponent = CollectionDynamicSection;
        break;
      default:
        console.warn(`Tipo de coleta desconhecido: ${surveyLabel}`);
        return;
    }

    setRenderedSurveys((prev) => [
      ...prev,
      {
        ...surveyType,
        component: (
          <SurveyComponent
            key={`survey-${surveyType.id}`}
            research_id={id}
            handleCancelCreateSurvey={handleCancelCreateSurvey}
            users={users.map((u) => ({
              value: u.id,
              label: u.name,
              role: u.role,
              status: u.status,
              email: u.email,
            }))}
          />
        ),
      },
    ]);
  };

  const handleStartCreateSurvey = (selectedTypeId) => {
    const typeObj = SURVEY_TYPES.find((t) => t.id === selectedTypeId);
    if (!typeObj) return;

    renderSurveyComponent(typeObj.label);

    setTimeout(() => {
      const element = document.getElementById(`survey-${selectedTypeId}`);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }, 300);

    setIsCreatingSurvey(true);
  };

  const handleCancelCreateSurvey = () => {
    setRenderedSurveys((prev) => prev.filter((s) => s.id !== "formulario"));
    setIsCreatingSurvey(false);
  };

  const handleResearchUpdate = async (payload) => {
    if (!id) return;
    try {
      const formattedPayload = formatDataByModel({ ...payload, id }, "researches");
      await updateResearch(id, formattedPayload);
      showMessage("Pesquisa atualizada com sucesso", "verde", 5000);
      router.reload();
    } catch (err) {
      console.error("Erro ao atualizar a pesquisa:", err);
      showMessage("Erro ao atualizar a pesquisa", "vermelho_claro", 5000);
    }
  };

  if (!id || loadingResearch || loadingUsers) return <ResearchLoadingSkeleton />;

  if (!researchData) {
    return <div className="p-6 text-red-500">Não foi possível carregar a pesquisa.</div>;
  }

  return (
    <div className="relative">
      <main className="p-4 sm:p-6 space-y-20 mb-20">
        <section id="pesquisa">
          <h2 className="text-xl font-bold mb-4">Pesquisa</h2>
          <ResearchForm
            isEdit
            initialData={researchData}
            users={users.map((u) => ({
              value: u.id,
              label: u.name,
              role: u.role,
              status: u.status,
              email: u.email,
            }))}
            onSubmit={handleResearchUpdate}
          />
        </section>

        {!isCreatingSurvey && (
          <section id="create-survey">
            <h2 className="text-xl font-bold mb-4">Criar coleta</h2>
            <AddSurveyPrompt onContinue={handleStartCreateSurvey} />
          </section>
        )}

        {renderedSurveys.map((survey) => (
          <section id={`survey-${survey.id}`} key={`survey-${survey.id}`}>
            <h2 className="text-xl font-bold mb-4">{survey.label}</h2>
            {survey.component}
          </section>
        ))}
      </main>

      <SideBarSectionsFilter sections={sidebarSections} position="right" />
    </div>
  );
}

EditResearch.layout = "private";
EditResearch.pageName = "Editar Pesquisa";


============================================================


📄 Arquivo : answers.js
📂 Pasta   : pages/researches/[id]/surveys/[surveyid]
🧭 Caminho : pages/researches/[id]/surveys/[surveyid]/answers.js
--------------------------------------
📜 Conteúdo:

'use client';

import { useEffect, useState } from 'react';
import { useRouter } from 'next/router';
import { Card, CardContent } from '@/components/ui/card';
import { Input } from '@/components/ui/input';
import { Textarea } from '@/components/ui/textarea';
import { RadioGroup, RadioGroupItem } from '@/components/ui/radio-group';
import { Label } from '@/components/ui/label';
import  Button  from '@/components/ui/Button';
import { useMessage } from "@/context/MessageContext";
import { useFields } from '@/hooks/useFields';

export default function ResearchAnswers() {
  const router = useRouter();
  const { showMessage } = useMessage();

  const [answers, setAnswers] = useState({});
  const [submitting, setSubmitting] = useState(false);

  const surveyType = router.query.survey_type;

  const { fields } = useFields(router.query.surveyid, surveyType);

  const handleChange = (fieldId, value) => {
    setAnswers((prev) => ({ ...prev, [fieldId]: value }));
  };

  const validateAnswers = () => {
    const requiredFields = MOCK_FIELDS.filter(field => field.required);
    const missingFields = requiredFields.filter(field => !answers[field.id]);

    if (missingFields.length > 0) {
      const fieldNames = missingFields.map(f => f.title).join(', ');
      showMessage(`Preencha os campos obrigatórios: ${fieldNames}`, 'vermelho_claro');
      return false;
    }

    return true;
  };

  const handleSubmit = async () => {
    if (!validateAnswers()) return;
    setSubmitting(true);

    try {
      const response = await fetch(`/api/researches/${router.query.id}/answers`, {
        method: 'POST',
        headers: {
          'Content-Type': 'application/json',
        },
        body: JSON.stringify({ answers }),
      });
x
      if (!response.ok) {
        throw new Error('Erro ao enviar respostas');
      }

      showMessage('Respostas enviadas com sucesso!', 'verde_claro');
      router.push('/pesquisas');
    } catch (err) {
      showMessage('Erro ao enviar respostas.', 'vermelho_claro');
    } finally {
      setSubmitting(false);
    }
  };

  return (
    <div className="flex flex-col gap-4 p-4 max-w-3xl mx-auto">
      <div className="mb-6">
        <h1 className="text-2xl font-bold">Pesquisa Placemaking (Mock)</h1>
        <p className="text-gray-700 mt-2">Este é um formulário simulado de teste para a interface de respostas.</p>
      </div>

      {fields.map((field) => (
        <Card key={field.id} className={field.required ? 'border-l-4 border-l-blue-500' : ''}>
          <CardContent className="p-4 flex flex-col gap-2">
            <Label className="font-medium flex items-center">
              {field.title}
              {field.required && <span className="text-red-500 ml-1">*</span>}
            </Label>
            {field.description && <p className="text-sm text-gray-500">{field.description}</p>}

            {field.input_type === 'text' && (
              <Input
                placeholder="Digite sua resposta"
                value={answers[field.id] || ''}
                onChange={(e) => handleChange(field.id, e.target.value)}
              />
            )}

            {field.input_type === 'long_text' && (
              <Textarea
                placeholder="Digite sua resposta completa"
                value={answers[field.id] || ''}
                onChange={(e) => handleChange(field.id, e.target.value)}
                rows={4}
              />
            )}

            {field.input_type === 'multiple_choice' && (
              <RadioGroup
                value={answers[field.id] || ''}
                onValueChange={(value) => handleChange(field.id, value)}
                className="space-y-2"
              >
                {MOCK_OPTIONS[field.id]?.map((option) => (
                  <div key={option.id} className="flex items-center space-x-2">
                    <RadioGroupItem value={option.label} id={`${field.id}-${option.id}`} />
                    <Label htmlFor={`${field.id}-${option.id}`}>{option.label}</Label>
                  </div>
                ))}
              </RadioGroup>
            )}
          </CardContent>
        </Card>
      ))}

      <div className="flex justify-between mt-6">
        <Button variant="outline" onClick={() => router.push('/')}>
          Cancelar
        </Button>
        <Button onClick={handleSubmit} disabled={submitting}>
          {submitting ? 'Enviando...' : 'Enviar Respostas'}
        </Button>
      </div>
    </div>
  );
}

ResearchAnswers.pageName = "Responder Pesquisa (Mock)";
ResearchAnswers.layout = "private";

============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/researches/[id]/surveys/[surveyid]
🧭 Caminho : pages/researches/[id]/surveys/[surveyid]/index.js
--------------------------------------
📜 Conteúdo:

// src/app/surveys/[surveyid]/index.tsx

import React, { use, useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { useRouter } from "next/router";
import { ClipboardCopy, Check, ChevronDown } from "lucide-react";
import Switch from "@/components/ui/Switch";
import * as Tooltip from "@radix-ui/react-tooltip";
import { Clock, MapPin } from "lucide-react";

import { useDynamicSurveys } from "@/hooks/useDynamicSurveys";
import { useFormSurveys } from "@/hooks/useFormSurveys";
import { useStaticSurveys } from "@/hooks/useStaticSurveys";
import { useSurveyContributors } from "@/hooks/useSurveyContributors";
import { useSurveyRegions } from "@/hooks/useSurveyRegions";
import { useSurveyTimeRanges } from "@/hooks/useSurveyTimeRanges";
import { useLoading } from "@/context/LoadingContext";
import MapPreview from "@/components/map/MapPreviewNoSSR";

import UserCardCompact from "@/components/ui/UserCardCompact";
import Button from "@/components/ui/Button";

export default function ResearchSurvey() {
  const router = useRouter();
  const { surveyid } = router.query;

  const { isLoading } = useLoading();
  const { dynamicSurvey, isLoading: loadingSurvey } =
    useDynamicSurveys(surveyid) || null;
  const { formSurvey, isLoading: loadingFormSurvey } =
    useFormSurveys(surveyid) || null;
  const { staticSurvey, isLoading: loadingStaticSurvey } =
    useStaticSurveys(surveyid) || null;
  const { contributors, isLoading: loadingContributors } =
    useSurveyContributors(surveyid);

  const [showMoreInfo, setShowMoreInfo] = useState(false);
  const [showContributors, setShowContributors] = useState(false);
  const [showMap, setShowMap] = useState(true);
  const [copied, setCopied] = useState(false);
  const [imageUrl, setImageUrl] = useState("");
  const [copiedRangeId, setCopiedRangeId] = useState(null);

  const { surveyRegions } = useSurveyRegions(surveyid);
  const { ranges: surveyTimeRanges } = useSurveyTimeRanges(surveyid);

  const survey = dynamicSurvey || formSurvey || staticSurvey;

  const handleCopyCoords = () => {
    if (survey?.lat && survey?.long) {
      const shortAddress =
        survey.location_title?.split(",").slice(0, 3).join(",").trim() || "";
      navigator.clipboard.writeText(
        `${shortAddress}: ${survey.lat}, ${survey.long}`
      );
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const handleCopyRange = (range) => {
    const text = `${range.start_time} - ${range.end_time}`;
    navigator.clipboard.writeText(text);
  };

  const getShortAddress = (fullAddress) => {
    if (!fullAddress) return "";
    const parts = fullAddress.split(",");
    return parts.slice(0, 3).join(",").trim();
  };

  useEffect(() => {
    console.log("surveyTimeRanges", surveyTimeRanges);
  }, [surveyTimeRanges]);

  useEffect(() => {
    const idx = Math.floor(Math.random() * 5);
    setImageUrl(`/img/cards/img-${idx}.jpg`);
  }, []);

  return (
    <motion.section
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="max-w-screen-lg mx-auto p-6 md:p-8 box-border flex flex-col gap-6 items-center"
    >
      {/* Detalhes da Coleta */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md border-2 w-full"
      >
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="relative rounded-t-lg h-32 overflow-hidden box-border"
          style={{
            backgroundImage: `url('${imageUrl}')`,
            backgroundSize: "cover",
            backgroundPosition: "center",
          }}
        >
          <div className="absolute inset-0 bg-black/40 rounded-t-lg" />
          <div className="absolute inset-0 flex items-center px-4 z-10">
            <h2 className="text-white text-3xl font-semibold truncate drop-shadow-md">
              {survey?.title}
            </h2>
          </div>
        </motion.div>

        {loadingSurvey ? (
          <p className="text-gray-600 italic">
            Carregando detalhes da coleta...
          </p>
        ) : survey ? (
          <div className="flex flex-col gap-2 px-6 pb-6">
            <h2 className="text-xl font-semibold">Detalhes da Coleta</h2>
            <ul className="space-y-2 text-gray-700 text-sm">
              <li>
                <strong>Título:</strong> {survey.title}
              </li>
              <li>
                <strong>Descrição:</strong> {survey.description}
              </li>
              <li>
                <strong>Tipo:</strong> {survey.survey_type}
              </li>
            </ul>
          </div>
        ) : (
          <p className="text-red-500">Coleta não encontrada.</p>
        )}
      </motion.div>

      {/* Informações Adicionais */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md border-2 w-full p-6"
      >
        <SectionToggle
          title="Informações Adicionais"
          isChecked={showMoreInfo}
          onChange={() => setShowMoreInfo((prev) => !prev)}
        />
        <AnimatePresence>
          {showMoreInfo && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: "auto" }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3 }}
              className="overflow-hidden"
            >
              <div className="flex flex-col gap-3">
                <div className="flex items-center gap-2">
                  <h2 className="text-base sm:text-lg font-semibold text-gray-800">
                    Micro-regiões
                  </h2>
                  <Tooltip.Provider delayDuration={100}>
                    <Tooltip.Root>
                      <Tooltip.Trigger asChild>
                        <button>
                          <MapPin
                            size={16}
                            className="text-gray-400 hover:text-gray-600 transition"
                          />
                        </button>
                      </Tooltip.Trigger>
                      <Tooltip.Portal>
                        <Tooltip.Content
                          side="top"
                          className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                          sideOffset={6}
                        >
                          Regiões onde a coleta de dados ocorrerá.
                          <Tooltip.Arrow className="fill-gray-800" />
                        </Tooltip.Content>
                      </Tooltip.Portal>
                    </Tooltip.Root>
                  </Tooltip.Provider>
                </div>
                {surveyRegions?.length ? (
                  surveyRegions.map((region) => (
                    <div
                      key={region.id}
                      className="flex flex-row justify-between items-center gap-4 p-2 border rounded-md bg-gray-50"
                    >
                      <div>
                        <p className="text-gray-800 font-semibold">
                          {region.name}
                        </p>
                        <p className="text-gray-500">{region.description}</p>
                      </div>
                      <div className="flex flex-row justify-end gap-4">
                        <p className="text-gray-500">
                          <strong>Latitude:</strong> {region.lat}
                        </p>
                        <p className="text-gray-500">
                          <strong>Longitude:</strong> {region.long}
                        </p>
                        <button
                          onClick={() => handleCopyCoords(region)}
                          className="flex items-center gap-2 text-sm text-blue-600 underline hover:text-blue-800 transition"
                        >
                          {copied ? (
                            <Check size={16} className="text-green-600" />
                          ) : (
                            <ClipboardCopy size={20} />
                          )}
                        </button>
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-gray-500">Nenhuma região cadastrada.</p>
                )}
                <div className="flex items-center gap-2">
                  <h2 className="text-base sm:text-lg font-semibold text-gray-800">
                    Horas de Coleta
                  </h2>
                  <Tooltip.Provider delayDuration={100}>
                    <Tooltip.Root>
                      <Tooltip.Trigger asChild>
                        <button>
                          <Clock
                            size={16}
                            className="text-gray-400 hover:text-gray-600 transition"
                          />
                        </button>
                      </Tooltip.Trigger>
                      <Tooltip.Portal>
                        <Tooltip.Content
                          side="top"
                          className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                          sideOffset={6}
                        >
                          Horários exatos de atuação dos pesquisadores em campo.
                          <Tooltip.Arrow className="fill-gray-800" />
                        </Tooltip.Content>
                      </Tooltip.Portal>
                    </Tooltip.Root>
                  </Tooltip.Provider>
                </div>
                {surveyTimeRanges?.length ? (
                  surveyTimeRanges.map((range) => (
                    <div
                      key={range.id}
                      className="flex flex-row justify-between items-center gap-4 p-2 border rounded-md bg-gray-50"
                    >
                      <div>
                        <p className="text-gray-800 font-semibold">
                          {range.start_time} - {range.end_time}
                        </p>
                        <p className="text-gray-500">{range.description}</p>
                      </div>
                      <div className="flex flex-row gap-2 items-center">
                        <p className="text-gray-500">
                          <strong>ID:</strong> {range.id}
                        </p>
                        <button
                          onClick={() => handleCopyRange(range)}
                          className="flex items-center gap-2 text-sm text-blue-600 underline hover:text-blue-800 transition"
                        >
                          {copiedRangeId === range.id ? (
                            <Check size={16} className="text-green-600" />
                          ) : (
                            <ClipboardCopy size={20} />
                          )}
                        </button>
                      </div>
                    </div>
                  ))
                ) : (
                  <p className="text-gray-500">
                    Nenhum intervalo de tempo cadastrado.
                  </p>
                )}
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>

      {/* Mapa da Coleta */}

      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md border-2 w-full p-6"
      >
        <SectionToggle
          title="Mapa da Coleta"
          isChecked={showMap}
          onChange={() => setShowMap((prev) => !prev)}
        />
        <AnimatePresence>
          {showMap && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: "auto" }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3 }}
              className="mt-4 text-sm text-gray-700 border rounded-md p-4 bg-gray-50 space-y-4 "
            >
              {loadingSurvey ? (
                <p className="text-gray-400">Carregando mapa...</p>
              ) : survey?.lat && survey?.long ? (
                <MapPreview
                  lat={survey.lat}
                  lng={survey.long}
                  height="200px"
                  width="100"
                />
              ) : (
                <p className="text-gray-400">Nenhuma localização disponível.</p>
              )}

              <div className="flex flex-row justify-between items-center gap-4 mt-2 text-gray-700 text-sm">
                <motion.p>
                  <strong>Localização:</strong>{" "}
                  {getShortAddress(survey?.location_title)}
                </motion.p>
                <div className="flex flex-row  justify-end gap-4">
                  <motion.p>
                    <strong>Latitude:</strong> {survey?.lat}
                  </motion.p>
                  <motion.p>
                    <strong>Longitude:</strong> {survey?.long}
                  </motion.p>
                  <button
                    onClick={handleCopyCoords}
                    className="flex items-center gap-2 text-sm text-blue-600 underline hover:text-blue-800 transition"
                  >
                    {copied ? (
                      <Check size={16} className="text-green-600" />
                    ) : (
                      <ClipboardCopy size={20} />
                    )}
                  </button>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>

      {/* Colaboradores */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md border-2 w-full p-6"
      >
        <SectionToggle
          title="Colaboradores"
          isChecked={showContributors}
          onChange={() => setShowContributors((prev) => !prev)}
        />
        <AnimatePresence>
          {showContributors && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: "auto" }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3 }}
              className="overflow-hidden"
            >
              {loadingContributors ? (
                <p className="text-gray-400">Carregando colaboradores...</p>
              ) : contributors?.length ? (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-4">
                  {contributors.map((contributor) => (
                    <UserCardCompact
                      key={contributor.id}
                      user={{
                        id: contributor.user.id,
                        name: contributor.user.name,
                        role: contributor.user.role,
                        email: contributor.user.email,
                        status: contributor.user.status,
                      }}
                    />
                  ))}
                </div>
              ) : (
                <p className="text-gray-400">Nenhum colaborador encontrado.</p>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>

      {/* Respostas */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md border-2 w-full p-6"
      >
        <h1 className="text-2xl font-bold">Respostas</h1>
        <p className="text-gray-400">Em breve...</p>
      </motion.div>

      {/* Botão de Responder */}
      <Button
        onClick={() =>
          router.push(
            `/researches/${router.query.id}/surveys/${surveyid}/answers?survey_type=${survey?.survey_type}`
          )
        }
        disabled={isLoading}
        variant="primary"
        className="w-fit sm:w-auto px-6 py-2 mt-4 flex items-center gap-2 text-sm"
      >
        <span className="material-symbols-outlined text-base">send</span>
        <span>Responder Pesquisa</span>
      </Button>
    </motion.section>
  );
}

function SectionToggle({ title, isChecked, onChange }) {
  return (
    <div className="flex justify-between items-center">
      <h2 className="text-2xl font-semibold text-gray-800">{title}</h2>
      <Switch type="arrow" checked={isChecked} onChange={onChange} />
    </div>
  );
}

ResearchSurvey.pageName = "Visualizar Coleta";
ResearchSurvey.layout = "private";


============================================================


📄 Arquivo : view.js
📂 Pasta   : pages/researches/[id]
🧭 Caminho : pages/researches/[id]/view.js
--------------------------------------
📜 Conteúdo:

import React, { useState, useEffect, useCallback } from "react";
import { ChevronDown, ClipboardCopy, Check } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import { useRouter } from "next/router";
import { VARIANTS } from "@/config/colors";
import UserCardCompact from "@/components/ui/UserCardCompact";
import MapPreview from "@/components/map/MapPreviewNoSSR";
import Switch from "@/components/ui/Switch";

import { useDynamicSurveys } from "@/hooks/useDynamicSurveys";
import { useFormSurveys } from "@/hooks/useFormSurveys";
import { useStaticSurveys } from "@/hooks/useStaticSurveys";
import { useResearchContributors } from "@/hooks/useResearchContributors";
import { useResearches } from "@/hooks/useResearches";
import { useUsers } from "@/hooks/useUsers";

export default function ResearchView() {
  const router = useRouter();
  const { id } = router.query;

  const { dynamicSurvey, dynamicSurveyError } = useDynamicSurveys(id);
  const { formSurvey, formSurveyError } = useFormSurveys(id);
  const { staticSurvey, unSyncedstaticSurveys } = useStaticSurveys(id);
  const { contributors: contributorsData } = useResearchContributors(id);
  const { researchData: selectedResearch } = useResearches(true, id);
  const { users: allUsers } = useUsers() || null;
  const [showContributors, setShowContributors] = useState(false);
  const [showSurveys, setshowSurveys] = useState(false);
  const [showMap, setShowMap] = useState(true);
  const [copied, setCopied] = useState(false);

  const [imageUrl, setImageUrl] = useState("");

  const { userData: author } =
    useUsers(true, selectedResearch?.created_by) || null;

  const surveys = [dynamicSurvey, formSurvey, staticSurvey].filter(
    (survey) => survey !== null
  );

  const userMap = allUsers
    ? Object.fromEntries(allUsers.map((user) => [user.id, user]))
    : {};

  const contributorsList =
    contributorsData?.map((contributor) => ({
      ...contributor,
      user: userMap[contributor.user_id] || null,
    })) || [];

  const handleCopyCoords = () => {
    const name = selectedResearch?.location_title;
    const lat = selectedResearch?.lat;
    const lng = selectedResearch?.long;
    if (lat && lng) {
      navigator.clipboard.writeText(`${getShortAddress(name)}: ${lat}, ${lng}`);
      setCopied(true);
      setTimeout(() => setCopied(false), 2000);
    }
  };

  const getShortAddress = (fullAddress) => {
    if (!fullAddress) return "";
    const parts = fullAddress.split(",");
    return parts.slice(0, 3).join(",").trim();
  };

  useEffect(() => {
    const idx = Math.floor(Math.random() * 5);
    setImageUrl(`/img/cards/img-${idx}.jpg`);
  }, []);

  useEffect(() => {
    console.log("contributors:", contributorsList);
  }, [contributorsList]);

  return (
    <motion.section
      initial={{ opacity: 0, y: 20 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="max-w-screen-lg mx-auto p-6 md:p-8 box-border"
    >
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 bg-white rounded-lg shadow-md box-border border-2"
      >
        <motion.div
          initial={{ opacity: 0, y: -10 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.5 }}
          className="relative rounded-t-lg h-32 overflow-hidden box-border"
          style={{
            backgroundImage: `url('${imageUrl}')`,
            backgroundSize: "cover",
            backgroundPosition: "center",
          }}
        >
          <div className="absolute inset-0 bg-black/40 rounded-t-lg" />
          <div className="absolute inset-0 flex items-center px-4 z-10">
            <h2 className="text-white text-3xl font-semibold truncate drop-shadow-md">
              {selectedResearch?.title}
            </h2>
          </div>
        </motion.div>

        <div className="px-6 pb-6 md:px-8 flex flex-col gap-4">
          <motion.p>
            <strong>Descrição:</strong> {selectedResearch?.description}
          </motion.p>
          <motion.p>
            <strong>Início:</strong> {selectedResearch?.release_date}
          </motion.p>
          <motion.p>
            <strong>Fim:</strong> {selectedResearch?.end_date}
          </motion.p>
            <motion.p>
              <strong>Criada por:</strong> {author?.name}
            </motion.p>
        </div>
      </motion.div>
      {/* Seção Mapa com Toggle */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 p-6 md:p-8 bg-white rounded-lg shadow-md box-border border-2 mt-4 h-fit"
      >
        <SectionToggle
          title="Mapa"
          isChecked={showMap}
          onChange={() => setShowMap((prev) => !prev)}
        />

        <AnimatePresence>
          {showMap && selectedResearch?.lat && selectedResearch?.long && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: "auto" }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3 }}
              className="mt-4 text-sm text-gray-700 border rounded-md p-4 bg-gray-50 space-y-4 "
            >
              <MapPreview
                lat={selectedResearch.lat}
                lng={selectedResearch.long}
                height="200px"
                width="100"
              />
              <div className="flex flex-row justify-between items-center gap-4">
                <motion.p>
                  <strong>Localização:</strong>{" "}
                  {getShortAddress(selectedResearch?.location_title)}
                </motion.p>
                <div className="flex flex-row  justify-end gap-4">
                  <motion.p>
                    <strong>Latitude:</strong> {selectedResearch?.lat}
                  </motion.p>
                  <motion.p>
                    <strong>Longitude:</strong> {selectedResearch?.long}
                  </motion.p>
                  <button
                    onClick={handleCopyCoords}
                    className="flex items-center gap-2 text-sm text-blue-600 underline hover:text-blue-800 transition"
                  >
                    {copied ? (
                      <Check size={16} className="text-green-600" />
                    ) : (
                      <ClipboardCopy size={20} />
                    )}
                  </button>
                </div>
              </div>
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
      {/* Seção Colaboradores com Toggle */}
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 p-6 md:p-8 bg-white rounded-lg shadow-md box-border border-2 mt-4 h-fit"
      >
        <SectionToggle
          title="Colaboradores"
          isChecked={showContributors}
          onChange={() => setShowContributors((prev) => !prev)}
        />

        <AnimatePresence>
          {showContributors && (
            <motion.div
              initial={{ opacity: 0, height: 0 }}
              animate={{ opacity: 1, height: "auto" }}
              exit={{ opacity: 0, height: 0 }}
              transition={{ duration: 0.3 }}
              className="overflow-hidden"
            >
              {contributorsList === null ? (
                <p className="text-gray-400">Carregando colaboradores...</p>
              ) : contributorsList.length === 0 ? (
                <p className="text-gray-400">Nenhum colaborador encontrado.</p>
              ) : (
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {contributorsList.map((user) => (
                    <UserCardCompact
                      key={user.id}
                      user={{
                        id: user.user?.id,
                        name: user.user?.name,
                        role: user.user?.role,
                        status: user.user?.status,
                        email: user.user?.email,
                        instruction: user.instruction, // se o componente aceitar
                      }}
                    />
                  ))}
                </div>
              )}
            </motion.div>
          )}
        </AnimatePresence>
      </motion.div>
      <motion.div
        initial={{ opacity: 0, y: 20 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="flex flex-col gap-4 p-6 md:p-8 bg-white rounded-lg shadow-md box-border border-2 mt-4 h-fit"
      >
        <SectionToggle
          title="Coletas"
          isChecked={showSurveys}
          onChange={() => setshowSurveys((prev) => !prev)}
        />
        {showSurveys && (
          <motion.div
            initial={{ opacity: 0, height: 0 }}
            animate={{ opacity: 1, height: "auto" }}
            exit={{ opacity: 0, height: 0 }}
            transition={{ duration: 0.3 }}
            className="mt-4 text-sm text-gray-700 border rounded-md p-4 bg-gray-50 space-y-4"
          >
            {(() => {
              const filteredSurveys = surveys.filter(
                (s) => s.research_id === selectedResearch.id
              );

              if (filteredSurveys.length === 0) {
                return (
                  <div className="text-gray-500 italic">
                    Nenhuma survey vinculada a esta pesquisa.
                  </div>
                );
              }

              const grouped = filteredSurveys.reduce((acc, survey) => {
                const type = survey.survey_type || "outros";
                acc[type] = acc[type] || [];
                acc[type].push(survey);
                return acc;
              }, {});

              return Object.entries(grouped).map(([type, group]) => (
                <div className="flex flex-col items-center w-full" key={type}>
                  <h3 className="text-lg font-semibold text-gray-800 capitalize mb-2">
                    {type}
                  </h3>
                    {group.map((survey) => (
                      <div
                        className="flex flex-row items-center justify-between w-full"
                        key={survey.id}
                      >
                        <div className="flex flex-col w-full items-start justify-start gap-1">  
                          {survey.title || `Survey ${survey.id}`}
                          <span className="text-gray-500 text-xs">
                            {survey.description}
                          </span>
                          </div>
                          <button
                            onClick={() =>
                              router.push(
                                `/researches/${selectedResearch.id}/surveys/${survey.id}`
                              )
                            }
                            className="text-blue-600 hover:text-blue-800 transition ml-2"
                          >
                            <span className="material-symbols-outlined text-2xl">
                              visibility
                            </span>
                          </button>
                          <span className="text-gray-500 text-xs ml-2">
                            {survey._syncStatus}
                          </span>
                      </div>
                    ))}
                </div>
              ));
            })()}
          </motion.div>
        )}
      </motion.div>
    </motion.section>
  );
}

function SectionToggle({ title, isChecked, onChange }) {
  return (
    <div className="flex justify-between items-center">
      <h2 className="text-2xl font-semibold text-gray-800">{title}</h2>
      <Switch type="arrow" checked={isChecked} onChange={onChange} />
    </div>
  );
}

ResearchView.pageName = "Visualizar Pesquisa";
ResearchView.layout = "private";


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/researches
🧭 Caminho : pages/researches/create.js
--------------------------------------
📜 Conteúdo:

import { useRouter } from "next/router";
import { useMemo } from "react";
import ResearchForm from "@/components/research/ResearchForm";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import { useUsers, useAuthentication, useResearches } from "@/hooks";
import {formatDataByModel} from "@/lib/types/models";


export default function CreateResearch() {
  const { users: rawUsers, loading: usersLoading, error: usersError } = useUsers();
  const { addResearch } = useResearches();
  const { user } = useAuthentication();
  const { showMessage } = useMessage();
  const { setIsLoading } = useLoading();
  const router = useRouter();
  

  const users = useMemo(() => {
    if (!Array.isArray(rawUsers)) return [];
    return rawUsers.map((user) => ({
      value: user.id,
      id: user.id,
      label: user.name,
      role: user.role,
      status: user.status,
      email: user.email,
    }));
  }, [rawUsers]);

  const handleCreate = async (payload) => {
    setIsLoading(true);
    try {
      const userId = user?.id;
      if (!userId) {
        showMessage("Usuário não encontrado", "vermelho", 5000);
        return;
      }

      const release_date = payload.release_date
        ? `${payload.release_date}T00:00:00`
        : null;
      const end_date = payload.end_date
        ? `${payload.end_date}T00:00:00`
        : null;

      const finalPayload = {
        ...payload,
        release_date,
        end_date,
        created_by: userId,
      };

      const formattedPayload = formatDataByModel(
        finalPayload,
        "researches"
      );

      const created = await addResearch(formattedPayload);

      showMessage("Pesquisa criada com sucesso!", "verde", 4000);
      router.push(`/researches/${created?.id || ""}`);
    } catch (error) {
      console.error("Erro ao criar pesquisa:", error);
      showMessage("Erro interno ao criar pesquisa.", "vermelho", 5000);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="pb-20">
      <ResearchForm
        isEdit={false}
        onSubmit={handleCreate}
        users={users}
      />
    </div>
  );
}

CreateResearch.layout = "private";
CreateResearch.pageName = "Criar Pesquisa";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/researches
🧭 Caminho : pages/researches/index.js
--------------------------------------
📜 Conteúdo:

import { useState, useMemo, useCallback } from "react";
import { motion } from "framer-motion";
import { useRouter } from "next/router";
import Button from "@/components/ui/Button";
import FiltersComponent from "@/components/ui/FiltersComponent";
import ResearchCard from "@/components/ui/Research/ResearchCard";
import ResearchCardSkeleton from "@/components/ui/Research/ResearchCardSkeleton";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import { useResearches } from "@/hooks/useResearches";
import { VARIANTS } from "@/config/colors";

export default function Researches() {
  const { researches, unSyncedResearchs, loading, error } = useResearches();
  const [filters, setFilters] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");
  const [showCategory, setShowCategory] = useState({
    completed: true,
    ongoing: true,
    future: true,
  });
  const [page, setPage] = useState({
    completed: 1,
    ongoing: 1,
    future: 1,
  });
  const perPage = 3;
  const { setIsLoading } = useLoading();
  const { showMessage } = useMessage();
  const router = useRouter();
  const [showFilters, setShowFilters] = useState(false);

  const currentDate = useMemo(() => new Date(), []);

  const categorizedResearches = useMemo(() => {
    const cat = { completed: [], ongoing: [], future: [] };
    researches.forEach((research) => {
      const endDate = new Date(research.end_date);
      const startDate = new Date(research.release_date);

      if (endDate < currentDate) cat.completed.push(research);
      else if (startDate > currentDate) cat.future.push(research);
      else cat.ongoing.push(research);
    });
    return cat;
  }, [researches, currentDate]);

  const filterAndSortResearches = useCallback((list) => {
    return list
      .filter(
        (research) =>
          research.title?.toLowerCase().includes(filters.toLowerCase()) ||
          research.description?.toLowerCase().includes(filters.toLowerCase()) ||
          research.location_title?.toLowerCase().includes(filters.toLowerCase())
      )
      .sort((a, b) => {
        const aDate = a?.created_at ?? "";
        const bDate = b?.created_at ?? "";
        return sortOrder === "asc"
          ? aDate.localeCompare(bDate)
          : bDate.localeCompare(aDate);
      });
  }, [filters, sortOrder]);

  const paginatedResearches = useCallback((list, category) => {
    const filteredAndSorted = filterAndSortResearches(list);
    const totalPages = Math.ceil(filteredAndSorted.length / perPage);
    const currentPage = page[category] ?? 1;
    const sliced = filteredAndSorted.slice((currentPage - 1) * perPage, currentPage * perPage);
    return { sliced, totalPages };
  }, [filterAndSortResearches, page]);

  const handleSync = async () => {
    try {
      setIsLoading(true);
      showMessage("Dados atualizados com sucesso!", "azul_claro");
    } catch (err) {
      console.error("Erro ao sincronizar:", err);
      showMessage("Erro ao sincronizar dados.", "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-transparent">
      <main className="p-4 md:p-8 max-w-8xl mx-auto">
        <motion.section
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.4 }}
          className="bg-transparent rounded-2xl p-6 md:p-8"
        >
          <div className="flex flex-col md:flex-row md:justify-between md:items-center gap-4 mb-6">
            <h2 className="text-3xl font-bold text-gray-800">
              Gerenciar Pesquisas
            </h2>
            <Button
              onClick={handleSync}
              disabled={loading}
              className="w-full sm:w-fit self-start sm:self-auto px-4 py-2 transition flex items-center justify-center gap-2 text-sm"
              variant="secondary"
            >
              <span className="material-symbols-outlined text-base">sync</span>
              <span>Atualizar</span>
            </Button>
          </div>

          {/* Se existirem pesquisas não sincronizadas */}
          {(unSyncedResearchs.length > 0) && (
            <div className="mb-10">
              <h3 className="text-2xl font-semibold mb-4 text-orange-600">
                Pesquisas Não Sincronizadas
              </h3>
              <motion.div
                layout
                className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"
              >
                {loading
                  ? Array.from({ length: 6 }).map((_, index) => (
                      <ResearchCardSkeleton key={index} />
                    ))
                  : unSyncedResearchs.map((research) => (
                      <motion.div
                        key={research.id}
                        layout
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 0.3 }}
                      >
                        <ResearchCard
                          research={research}
                          onViewDetails={() =>
                            router.push(`/researches/${research.id}`)
                          }
                        />
                      </motion.div>
                    ))}
              </motion.div>
              <hr className="my-6 border-gray-300" />
            </div>
          )}

          <FiltersComponent
            showFilters={showFilters}
            setShowFilters={setShowFilters}
            variants={VARIANTS}
            filters={[
              {
                key: "filters",
                label: "Buscar por título, descrição ou local",
                icon: "search",
                type: "text",
                value: filters,
                defaultValue: "",
              },
              {
                key: "sortOrder",
                label: "Ordenação",
                icon: "sort",
                type: "button-group",
                value: sortOrder,
                defaultValue: "asc",
                options: [
                  { label: "Mais Recentes", value: "asc" },
                  { label: "Mais Antigos", value: "desc" },
                ],
              },
              {
                key: "showCategory",
                label: "Mostrar categorias",
                type: "switch-group",
                options: [
                  { label: "Pesquisas Já Realizadas", value: "completed", checked: showCategory.completed },
                  { label: "Pesquisas em Andamento", value: "ongoing", checked: showCategory.ongoing },
                  { label: "Pesquisas Futuras", value: "future", checked: showCategory.future },
                ],
              },
            ]}
            onChange={(key, value) => {
              if (key === "filters") setFilters(value);
              if (key === "sortOrder") setSortOrder(value);
              if (key === "showCategory") setShowCategory((prev) => ({ ...prev, ...value }));
            }}
            onClear={() => {
              setFilters("");
              setSortOrder("asc");
              setShowCategory({ completed: true, ongoing: true, future: true });
            }}
          />

          {/* Renderização das Categorias */}
          {Object.entries(categorizedResearches).map(([key, list]) => {
            if (!showCategory[key]) return null;

            const { sliced, totalPages } = paginatedResearches(list, key);

            const handlePrevious = () => {
              setPage((prev) => ({
                ...prev,
                [key]: Math.max(prev[key] - 1, 1),
              }));
            };

            const handleNext = () => {
              setPage((prev) => ({
                ...prev,
                [key]: Math.min(prev[key] + 1, totalPages),
              }));
            };

            return (
              <div key={key} className="mt-10">
                <h3 className="text-2xl font-semibold mb-4 text-gray-700">
                  {key === "completed"
                    ? "Pesquisas Já Realizadas"
                    : key === "ongoing"
                    ? "Pesquisas em Andamento"
                    : "Pesquisas Futuras"}
                </h3>
                {loading ? (
                  <motion.div
                    layout
                    className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"
                  >
                    {Array.from({ length: 6 }).map((_, index) => (
                      <ResearchCardSkeleton key={index} />
                    ))}
                  </motion.div>
                ) : sliced.length === 0 ? (
                  <p className="text-gray-500 text-sm">
                    Nenhuma pesquisa encontrada.
                  </p>
                ) : (
                  <motion.div
                    layout
                    className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-3 gap-6"
                  >
                    {sliced.map((research) => (
                      <motion.div
                        key={research.id}
                        layout
                        initial={{ opacity: 0 }}
                        animate={{ opacity: 1 }}
                        transition={{ duration: 0.3 }}
                      >
                        <ResearchCard
                          research={research}
                          onViewDetails={() =>
                            router.push(`/researches/${research.id}`)
                          }
                        />
                      </motion.div>
                    ))}
                  </motion.div>
                )}

                {sliced.length > 0 && (
                  <div className="flex items-center justify-between gap-6 mt-6">
                    <Button
                      onClick={handlePrevious}
                      disabled={page[key] === 1}
                      variant="secondary"
                      className="px-4 py-2 text-sm"
                    >
                      Anterior
                    </Button>
                    <span className="text-sm text-gray-700">
                      Página {page[key]} de {totalPages}
                    </span>
                    <Button
                      onClick={handleNext}
                      disabled={page[key] === totalPages}
                      variant="secondary"
                      className="px-4 py-2 text-sm"
                    >
                      Próxima
                    </Button>
                  </div>
                )}
                <hr className="my-6 border-gray-200" />
              </div>
            );
          })}
        </motion.section>
      </main>
    </div>
  );
}

Researches.pageName = "Gerenciar Pesquisas";
Researches.layout = "private";


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/users
🧭 Caminho : pages/users/[id].js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import { motion } from "framer-motion";
import Button from "@/components/ui/Button";
import { useAuth } from "@/context/AuthContext";
import { formatDateToDDMMYY } from "@/utils/formatDate";
import { useUsers } from "@/hooks/useUsers";

export default function Profile() {
  const { isLoading, setIsLoading } = useLoading(false);
  const { showMessage } = useMessage();
  const { userData, saveUserInfo } = useAuth();
  const router = useRouter();
  const { id: routeUserId } = router.query;

  const [showNewPassword, setShowNewPassword] = useState(false);
  const [form, setForm] = useState({
    id: "",
    name: "",
    email: "",
    status: "",
    role: "",
    created_at: "",
    updated_at: "",
  });
  const [passwordForm, setPasswordForm] = useState({
    new_password: "",
    confirm_password: "",
  });

  const isSelf = userData?.id === routeUserId;

  const { userData: selectedUser } = useUsers(true, routeUserId);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handlePasswordChange = (e) => {
    const { name, value } = e.target;
    setPasswordForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      const res = await fetch("/api/users/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Erro ao atualizar perfil");

      if (data.user) {
        if (isSelf) saveUserInfo(data.user);
        await updateCachedItemById("users", data.user.id, data.user);

        setForm((prev) => ({
          ...prev,
          updated_at: formatDateToDDMMYY(data.user.updated_at),
        }));

        showMessage("Perfil atualizado com sucesso!", "verde");
      }
    } catch (err) {
      showMessage(err.message, "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePasswordSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      if (passwordForm.new_password !== passwordForm.confirm_password) {
        throw new Error("As senhas não coincidem");
      }

      const res = await fetch("/api/auth/change-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(passwordForm),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Erro ao atualizar senha");

      showMessage("Senha atualizada com sucesso!", "verde");
      setPasswordForm({ new_password: "", confirm_password: "" });
    } catch (err) {
      showMessage(err.message, "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  useEffect(() => {
    if (selectedUser) {
      setForm({
        id: selectedUser.id,
        name: selectedUser.name,
        email: selectedUser.email,
        status: selectedUser.status,
        role: selectedUser.role,
        created_at: formatDateToDDMMYY(selectedUser.created_at),
        updated_at: formatDateToDDMMYY(selectedUser.updated_at),
      });
    }
  }, [selectedUser]);

  return (
    <div className="min-h-screen bg-transparent">
      <main className="p-2 md:p-6 space-y-8 max-w-3xl mx-auto">
        {!selectedUser ? (
          <div className="flex justify-center items-center h-96">
            <div className="animate-spin rounded-full h-10 w-10 border-t-2 border-b-2 border-gray-900" />
          </div>
        ) : (
          <>
            <motion.section
              initial={{ opacity: 0, y: 20 }}
              animate={{ opacity: 1, y: 0 }}
              transition={{ duration: 0.6 }}
              className="bg-white p-6 rounded shadow space-y-4"
            >
              <h2 className="text-xl font-semibold mb-4">Dados do Perfil</h2>
              <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-700">
                <div>
                  <span className="font-bold">Nome:</span>
                  <p>{form.name}</p>
                </div>
                <div>
                  <span className="font-bold">E-mail:</span>
                  <p>{form.email}</p>
                </div>
                <div>
                  <span className="font-bold">ID:</span>
                  <p>{form.id}</p>
                </div>
                <div>
                  <span className="font-bold">Status:</span>
                  <p>{form.status}</p>
                </div>
                <div>
                  <span className="font-bold">Papel:</span>
                  <p>{form.role}</p>
                </div>
                <div>
                  <span className="font-bold">Criado em:</span>
                  <p>{form.created_at}</p>
                </div>
                <div>
                  <span className="font-bold">Atualizado em:</span>
                  <p>{form.updated_at}</p>
                </div>
              </div>
            </motion.section>

            {isSelf && (
              <>
                {/* Editar nome e e-mail */}
                <motion.section
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.6 }}
                  className="bg-white p-6 rounded shadow space-y-4"
                >
                  <h2 className="text-xl font-semibold mb-4">
                    Editar Informações
                  </h2>
                  <form onSubmit={handleSubmit} className="space-y-4">
                    <input
                      type="text"
                      name="name"
                      placeholder="Nome"
                      value={form.name}
                      onChange={handleChange}
                      className="border p-2 rounded w-full"
                      required
                    />
                    <input
                      type="email"
                      name="email"
                      placeholder="E-mail"
                      value={form.email}
                      onChange={handleChange}
                      className="border p-2 rounded w-full"
                      required
                    />
                    <div className="flex justify-center">
                      <Button
                        type="submit"
                        variant="dark"
                        className="w-full max-w-60 text-md active:scale-95"
                        disabled={isLoading}
                      >
                        {isLoading ? "Salvando..." : "Salvar Alterações"}
                      </Button>
                    </div>
                  </form>
                </motion.section>

                {/* Alterar senha */}
                <motion.section
                  initial={{ opacity: 0, y: 20 }}
                  animate={{ opacity: 1, y: 0 }}
                  transition={{ duration: 0.6 }}
                  className="bg-white p-6 rounded shadow space-y-4"
                >
                  <h2 className="text-xl font-semibold mb-4">Alterar Senha</h2>
                  <form onSubmit={handlePasswordSubmit} className="space-y-4">
                    <div className="relative">
                      <input
                        type={showNewPassword ? "text" : "password"}
                        name="new_password"
                        placeholder="Nova Senha"
                        value={passwordForm.new_password}
                        onChange={handlePasswordChange}
                        className="border p-2 rounded w-full pr-12"
                        required
                      />
                      <button
                        type="button"
                        onClick={() => setShowNewPassword((prev) => !prev)}
                        className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-600"
                      >
                        {showNewPassword ? "Ocultar" : "Mostrar"}
                      </button>
                    </div>
                    <div className="relative">
                      <input
                        type={showNewPassword ? "text" : "password"}
                        name="confirm_password"
                        placeholder="Confirme a Nova Senha"
                        value={passwordForm.confirm_password}
                        onChange={handlePasswordChange}
                        className="border p-2 rounded w-full pr-12"
                        required
                      />
                      <button
                        type="button"
                        onClick={() => setShowNewPassword((prev) => !prev)}
                        className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-600"
                      >
                        {showNewPassword ? "Ocultar" : "Mostrar"}
                      </button>
                    </div>
                    <div className="flex justify-center">
                      <Button
                        type="submit"
                        variant="dark"
                        className="w-full max-w-60 text-md active:scale-95"
                        disabled={isLoading}
                      >
                        {isLoading ? "Atualizando..." : "Alterar Senha"}
                      </Button>
                    </div>
                  </form>
                </motion.section>
              </>
            )}
          </>
        )}
      </main>
    </div>
  );
}

Profile.layout = "private";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/users
🧭 Caminho : pages/users/index.js
--------------------------------------
📜 Conteúdo:

import { useState, useMemo } from "react";
import Button from "@/components/ui/Button";
import ModalUser from "@/components/ui/ModalUser";
import ModalRegisterUser from "@/components/ui/ModalRegisterUser";
import FiltersComponent from "@/components/ui/FiltersComponent";
import  UserCard from "@/components/ui/UserCard";
import { useUsers } from "@/hooks/useUsers"; // agora usa seu hook
import { useMessage } from "@/context/MessageContext";
import { VARIANTS } from "@/config/colors";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";
import UserCardSkeleton from "@/components/ui/UserCardSkeleton";

export default function Users() {
  const { users, addUser, updateUser, loading } = useUsers();
  const { showMessage } = useMessage();
  const [selectedUser, setSelectedUser] = useState(null);
  const [isRegisterOpen, setIsRegisterOpen] = useState(false);

  const [page, setPage] = useState(1);
  const [perPage] = useState(10);

  const [searchTerm, setSearchTerm] = useState("");
  const [order, setOrder] = useState("desc");
  const [filterStatus, setFilterStatus] = useState("");
  const [filterRole, setFilterRole] = useState("");
  const [showFilters, setShowFilters] = useState(false);

  const filteredUsers = useMemo(() => {
    let filtered = users;

    if (searchTerm)
      filtered = filtered.filter(
        (u) =>
          u.name.toLowerCase().includes(searchTerm.toLowerCase()) ||
          u.email.toLowerCase().includes(searchTerm.toLowerCase())
      );

    if (filterStatus)
      filtered = filtered.filter((u) => u.status === filterStatus);
    if (filterRole) filtered = filtered.filter((u) => u.role === filterRole);

    if (order === "desc")
      filtered = filtered.sort((a, b) =>
        b.created_at.localeCompare(a.created_at)
      );
    else
      filtered = filtered.sort((a, b) =>
        a.created_at.localeCompare(b.created_at)
      );

    return filtered;
  }, [users, searchTerm, filterStatus, filterRole, order]);

  const paginatedUsers = useMemo(() => {
    const start = (page - 1) * perPage;
    return filteredUsers.slice(start, start + perPage);
  }, [filteredUsers, page, perPage]);

  const totalPages = Math.ceil(filteredUsers.length / perPage);

  const handleUserCreated = async (newUser) => {
    try {
      await addUser(newUser);
      showMessage("Usuário criado com sucesso!", "verde");
    } catch (err) {
      console.error(err);
      showMessage("Erro ao criar usuário.", "vermelho_claro");
    }
  };

  const handleUserUpdated = async (updatedUser) => {
    try {
      console.log("Atualizando usuário:", updatedUser);
      await updateUser(updatedUser.id, updatedUser);
      showMessage("Usuário atualizado!", "verde");
    } catch (err) {
      console.error(err);
      showMessage("Erro ao atualizar usuário.", "vermelho_claro");
    }
  };

  const handleUserDeleted = async (userId) => {
    try {
      await removeUser(userId);
      showMessage("Usuário deletado!", "verde");
    } catch (err) {
      console.error(err);
      showMessage("Erro ao deletar usuário.", "vermelho_claro");
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="p-2 md:p-8 max-w-7xl mx-auto">
        <div className="flex justify-end mb-4">
          <Button
            onClick={() => setIsRegisterOpen(true)}
            variant="dark"
            className="flex px-4 py-2 gap-2 items-center"
          >
            <span className="material-symbols-outlined">person_add</span>
            Cadastrar usuário
          </Button>
        </div>

        <section className="bg-white rounded-lg shadow p-6">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-4">
            <h2 className="text-2xl font-bold mb-2 md:mb-0">
              Usuários Cadastrados
            </h2>
          </div>

          <FiltersComponent
            showFilters={showFilters}
            setShowFilters={setShowFilters}
            variants={VARIANTS}
            mobilePosition="right"
            filters={[
              {
                key: "searchTerm",
                label: "Buscar por nome ou e-mail",
                icon: "search",
                type: "text",
                value: searchTerm,
                defaultValue: "",
              },
              {
                key: "order",
                label: "Ordem de cadastro",
                icon: "sort",
                type: "button-group",
                value: order,
                defaultValue: "desc",
                options: [
                  { label: "Mais novo", value: "desc" },
                  { label: "Mais velho", value: "asc" },
                ],
              },
              {
                key: "filterStatus",
                label: "Filtrar por status",
                icon: "flag",
                type: "button-group",
                value: filterStatus,
                defaultValue: "",
                options: [
                  { label: "Todos", value: "" },
                  ...USER_STATUS.map((s) => ({ label: s, value: s })),
                ],
              },
              {
                key: "filterRole",
                label: "Filtrar por papel",
                icon: "groups",
                type: "button-group",
                value: filterRole,
                defaultValue: "",
                options: [
                  { label: "Todos", value: "" },
                  ...USER_ROLES.map((r) => ({ label: r, value: r })),
                ],
              },
            ]}
            onChange={(key, value) => {
              if (key === "searchTerm") setSearchTerm(value);
              if (key === "order") setOrder(value);
              if (key === "filterStatus") setFilterStatus(value);
              if (key === "filterRole") setFilterRole(value);
              setPage(1); // Resetar para página 1 ao mudar filtros
            }}
            onClear={() => {
              setSearchTerm("");
              setOrder("desc");
              setFilterStatus("");
              setFilterRole("");
              setPage(1);
            }}
          />

          {loading ? (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {Array.from({ length: 8 }).map((_, idx) => (
                <UserCardSkeleton key={idx} />
              ))}
            </div>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {paginatedUsers.map((u) => (
                <UserCard
                  key={u.id}
                  user={u}
                  onViewDetails={() => setSelectedUser(u)}
                />
              ))}
            </div>
          )}

          <div className="flex items-center justify-between mt-6">
            <Button
              onClick={() => page > 1 && setPage(page - 1)}
              disabled={page === 1}
              variant="dark"
            >
              Anterior
            </Button>
            <span className="text-sm text-gray-700">
              Página {page} de {totalPages}
            </span>
            <Button
              onClick={() => page < totalPages && setPage(page + 1)}
              disabled={page === totalPages}
              variant="dark"
            >
              Próxima
            </Button>
          </div>
        </section>
      </main>

      <ModalUser
        isOpen={!!selectedUser}
        user={selectedUser}
        onClose={() => setSelectedUser(null)}
        onUserUpdated={handleUserUpdated}
        onUserDeleted={handleUserDeleted}
        showMessage={showMessage}
      />

      <ModalRegisterUser
        isOpen={isRegisterOpen}
        onClose={() => setIsRegisterOpen(false)}
        onUserCreated={handleUserCreated}
        showMessage={showMessage}
      />
    </div>
  );
}

Users.pageName = "Gerenciar Usuários";
Users.layout = "private";


============================================================


📄 Arquivo : validate-code.js
📂 Pasta   : pages
🧭 Caminho : pages/validate-code.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import Button from "@/components/ui/Button";
import Image from "next/image";
import { motion } from "framer-motion";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import { useRouter } from "next/router";
import { useAuth } from "@/context/AuthContext";


export default function ValidateCode() {
  const [code, setCode] = useState("");
  const [email, setEmail] = useState("");
  const { showMessage } = useMessage();
  const { isLoading, setIsLoading } = useLoading();
  const router = useRouter();
  const { saveCredentials, saveUserInfo } = useAuth();
  

  useEffect(() => {
    const storedEmail = localStorage.getItem("recover_email");
    if (storedEmail) setEmail(storedEmail);
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
  
    try {
      const response = await fetch("/api/auth/validate-code", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ code }),
      });
  
      const data = await response.json();
  
      if (!response.ok) {
        throw new Error(data.message || "Código inválido");
      }
  
      const { token, token_type, expires_at } = data.access_token;
  
      await saveCredentials({
        access_token: token,
        token_type,
        expires_at,
      });
  
      await saveUserInfo(data.user);
  
      showMessage(data.message, "verde");
      router.push("/profile");
  
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 7000);
      console.error("[handleSubmit]", err);
    } finally {
      setIsLoading(false);
    }
  };
  

  const handleResend = async () => {
    try {
      const response = await fetch("/api/auth/forgot-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || "Erro ao reenviar código");
      }

      showMessage("Código reenviado com sucesso!", "verde");
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 7000);
    }
  };

  return (
    <div
      className="h-screen flex items-center justify-center p-8 bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken"
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <h2 className="text-xl font-semibold text-center text-gray-800 mb-2">
          Verificar Código
        </h2>

        {email && (
          <p className="text-sm text-gray-600 text-center mb-4">
            Código enviado para: <span className="font-medium">{email}</span>. Verifique na caixa de spam ou na lixeira.
          </p>
        )}

        <form className="space-y-4" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="code" className="block text-sm font-medium text-gray-700">
              Código de Verificação
            </label>
            <input
              type="text"
              id="code"
              value={code}
              onChange={(e) => setCode(e.target.value)}
              maxLength={8}
              className="mt-1 block w-full px-4 py-3 text-lg tracking-widest text-center border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="XXXXXXXX"
              required
            />
          </div>
          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Verificando..." : "Verificar"}
          </Button>

          <Button
            type="button"
            variant="azul_claro"
            className="w-full text-bg py-2 mt-2"
            onClick={handleResend}
          >
            Reenviar código
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

ValidateCode.pageName = "Verificar Código";
ValidateCode.layout = "public";


============================================================


📄 Arquivo : dynamicSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/dynamicSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { DynamicSurvey } from '@/lib/types/indexeddb';
  
  const store = 'dynamic_surveys' as const;
  
  export async function createDynamicSurvey(data: DynamicSurvey) {
    return createItem(store, data);
  }
  
  export async function getDynamicSurvey(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllDynamicSurveys() {
    return getAllItems(store);
  }
  
  export async function updateDynamicSurvey(id: string, data: Partial<DynamicSurvey>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteDynamicSurvey(id: string) {
    return deleteItem(store, id);
  }

============================================================


📄 Arquivo : fieldOptionRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/fieldOptionRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { FieldOption } from '@/lib/types/indexeddb';
  
  const store = 'field_options' as const;
  
  export async function createFieldOption(data: FieldOption) {
    return createItem(store, data);
  }
  
  export async function getFieldOption(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFieldOptions() {
    return getAllItems(store);
  }
  
  export async function updateFieldOption(id: string, data: Partial<FieldOption>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteFieldOption(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : fieldRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/fieldRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { Field } from '@/lib/types/indexeddb';
  
  const store = 'fields' as const;
  
  export async function createField(field: Field) {
    return createItem(store, field);
  }
  
  export async function getField(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFields() {
    return getAllItems(store);
  }
  
  export async function updateField(id: string, data: Partial<Field>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteField(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : formSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/formSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { FormSurvey } from '@/lib/types/indexeddb';
  
  const store = 'form_surveys' as const;
  
  export async function createFormSurvey(data: FormSurvey) {
    return createItem(store, data);
  }
  
  export async function getFormSurvey(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFormSurveys() {
    return getAllItems(store);
  }
  
  export async function updateFormSurvey(id: string, data: Partial<FormSurvey>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteFormSurvey(id: string) {
    console.log('Deleting form survey with ID:', id);
    return deleteItem(store, id);
  }

============================================================


📄 Arquivo : index.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/index.ts
--------------------------------------
📜 Conteúdo:

export * from './userRepository';
export * from './surveyAnswerRepository';
export * from './fieldRepository';
export * from './researchRepository';
export * from './surveyTimeRangeRepository';
export * from './surveyRegionRepository';
export * from './surveyGroupRepository';
export * from './surveyContributorRepository';
export * from './staticSurveyRepository';
export * from './formSurveyRepository';
export * from './dynamicSurveyRepository';
export * from './researchContributorRepository';
export * from './inputTypeRepository';
export * from './fieldOptionRepository';


============================================================


📄 Arquivo : indexedDBService.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/indexedDBService.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/indexeddb/indexedDBService.ts
import { openDB, IDBPDatabase } from 'idb';
import type { StoreTypes } from '@/lib/types/indexeddb';

const DB_NAME = 'placemaking-db';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase<any>> | null = null;

export function getDB(): Promise<IDBPDatabase<any>> {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        for (const store of Object.keys(storeSchema)) {
          if (!db.objectStoreNames.contains(store)) {
            db.createObjectStore(store, { keyPath: 'id' });
          }
        }
        if (!db.objectStoreNames.contains('unsynced_data')) {
          db.createObjectStore('unsynced_data', { keyPath: 'id' });
        }
      },
    });
  }
  return dbPromise;
}


export const storeSchema: Record<keyof StoreTypes, { keyPath: keyof any }> = {
  users: { keyPath: 'id' },
  fields: { keyPath: 'id' },
  researches: { keyPath: 'id' },
  survey_time_ranges: { keyPath: 'id' },
  survey_regions: { keyPath: 'id' },
  survey_group: { keyPath: 'id' },
  survey_contributors: { keyPath: 'id' },
  survey_answers: { keyPath: 'id' },
  static_surveys: { keyPath: 'id' },
  form_surveys: { keyPath: 'id' },
  dynamic_surveys: { keyPath: 'id' },
  research_contributors: { keyPath: 'id' },
  input_types: { keyPath: 'id' },
  field_options: { keyPath: 'id' },
  unsynced_data: { keyPath: 'id' },
};

export async function createItem<K extends keyof StoreTypes>(store: K, data: StoreTypes[K]): Promise<void> {
  const db = await getDB();
  await db.put(store, data);
}

export async function getItem<K extends keyof StoreTypes>(store: K, id: string): Promise<StoreTypes[K] | undefined> {
  const db = await getDB();
  return db.get(store, id);
}

export async function getAllItems<K extends keyof StoreTypes>(store: K): Promise<StoreTypes[K][]> {
  const db = await getDB();
  return db.getAll(store);
}

export async function updateItem<T = any>(store: string, id: string, data: Partial<T>): Promise<void> {
  const db = await getDB();
  const current = await db.get(store, id);
  if (current) {
    await db.put(store, { ...current, ...data });
  }
}

export async function deleteItem<K extends keyof StoreTypes>(store: K, id: string): Promise<void> {
  const db = await getDB();
  await db.delete(store, id);
}


============================================================


📄 Arquivo : inputTypeRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/inputTypeRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { InputType } from '@/lib/types/indexeddb';
  
  const store = 'input_types' as const;
  
  export async function createInputType(data: InputType) {
    return createItem(store, data);
  }
  
  export async function getInputType(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllInputTypes() {
    return getAllItems(store);
  }
  
  export async function updateInputType(id: string, data: Partial<InputType>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteInputType(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : researchContributorRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/researchContributorRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { ResearchContributor } from '@/lib/types/indexeddb';
  
  const store = 'research_contributors' as const;
  
  export async function createResearchContributor(data: ResearchContributor) {
    return createItem(store, data);
  }
  
  export async function getResearchContributor(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllResearchContributors() {
    return getAllItems(store);
  }
  
  export async function updateResearchContributor(id: string, data: Partial<ResearchContributor>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteResearchContributor(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : researchRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/researchRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { Research } from '@/lib/types/indexeddb';
  
  const store = 'researches' as const;
  
  export async function createResearch(research: Research) {
    return createItem(store, research);
  }
  
  export async function getResearch(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllResearchs() {
    return getAllItems(store);
  }
  
  export async function updateResearch(id: string, data: Research) {
    return updateItem('researches', id, data);
  }
  
  export async function deleteResearch(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : staticSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/staticSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
  createItem,
  getItem,
  getAllItems,
  updateItem,
  deleteItem,
} from './indexedDBService';
import type { StaticSurvey } from '@/lib/types/indexeddb';

const store = 'static_surveys' as const;

export async function createStaticSurvey(data: StaticSurvey) {
  return createItem(store, data);
}

export async function getStaticSurvey(id: string) {
  return getItem(store, id);
}

export async function getAllStaticSurveys() {
  return getAllItems(store);
}

export async function updateStaticSurvey(id: string, data: Partial<StaticSurvey>) {
  return updateItem(store, id, data);
}

export async function deleteStaticSurvey(id: string) {
  return deleteItem(store, id);
}

============================================================


📄 Arquivo : surveyAnswerRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyAnswerRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyAnswer } from '@/lib/types/indexeddb';
  
  const store = 'survey_answers' as const;
  
  export async function createSurveyAnswer(answer: SurveyAnswer) {
    return createItem(store, answer);
  }
  
  export async function getSurveyAnswer(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyAnswers() {
    return getAllItems(store);
  }
  
  export async function updateSurveyAnswer(id: string, data: Partial<SurveyAnswer>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyAnswer(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyContributorRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyContributorRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyContributor } from '@/lib/types/indexeddb';
  
  const store = 'survey_contributors' as const;
  
  export async function createSurveyContributor(data: SurveyContributor) {
    return createItem(store, data);
  }
  
  export async function getSurveyContributor(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyContributors() {
    return getAllItems(store);
  }
  
  export async function updateSurveyContributor(id: string, data: Partial<SurveyContributor>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyContributor(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyGroupRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyGroupRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyGroup } from '@/lib/types/indexeddb';
  
  const store = 'survey_group' as const;
  
  export async function createSurveyGroup(data: SurveyGroup) {
    return createItem(store, data);
  }
  
  export async function getSurveyGroup(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyGroups() {
    return getAllItems(store);
  }
  
  export async function updateSurveyGroup(id: string, data: Partial<SurveyGroup>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyGroup(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyRegionRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyRegionRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyRegion } from '@/lib/types/indexeddb';
  
  const store = 'survey_regions' as const;
  
  export async function createSurveyRegion(data: SurveyRegion) {
    return createItem(store, data);
  }
  
  export async function getSurveyRegion(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyRegions() {
    return getAllItems(store);
  }
  
  export async function updateSurveyRegion(id: string, data: Partial<SurveyRegion>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyRegion(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyTimeRangeRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyTimeRangeRepository.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/indexeddb/surveyTimeRangeRepository.ts

import { SurveyTimeRange } from '@/lib/types/indexeddb';
import { getAllItems, createItem, deleteItem } from './indexedDBService';

export async function getAllSurveyTimeRanges(): Promise<SurveyTimeRange[]> {
  return await getAllItems('survey_time_ranges');
}

export async function createSurveyTimeRange(range: SurveyTimeRange) {
  return await createItem('survey_time_ranges', range);
}

export async function deleteSurveyTimeRange(id: string) {
  return await deleteItem('survey_time_ranges', id);
}


============================================================


📄 Arquivo : userRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/userRepository.ts
--------------------------------------
📜 Conteúdo:

import {
  createItem,
  getItem,
  getAllItems,
  updateItem,
  deleteItem,
} from "./indexedDBService";
import type { User } from "@/lib/types/indexeddb";

const store = "users" as const;

export async function createUser(user: User) {
  return createItem(store, user);
}

export async function getUser(id: string) {
  return getItem(store, id);
}

export async function getAllUsers() {
  return getAllItems(store);
}

export async function updateUser(id: string, data: Partial<User>) {
  return updateItem(store, id, data);
}

export async function deleteUser(id: string) {
  return deleteItem(store, id);
}


============================================================


📄 Arquivo : dynamicSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/dynamicSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/DynamicSurveyApi.ts
import { DynamicSurvey } from '@/lib/types/indexeddb';
const baseUrl = '/api/surveys'; 
export async function getDynamicSurvey(research_id: string, survey_type: string): Promise<DynamicSurvey> {
  const url = `${baseUrl}?research_id=${encodeURIComponent(research_id)}&survey_type=${encodeURIComponent(survey_type)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar surveys de Dynamiculário');
  return res.json();
}

export async function createDynamicSurvey(data: DynamicSurvey): Promise<DynamicSurvey> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey de Dynamiculário');
  return res.json();
}

export async function updateDynamicSurvey(data: DynamicSurvey): Promise<DynamicSurvey> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar survey de Dynamiculário');
  return res.json();
}

export async function deleteDynamicSurvey(data: DynamicSurvey): Promise<void> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao deletar survey de Dynamiculário');
}




============================================================


📄 Arquivo : fieldApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/fieldApi.ts
--------------------------------------
📜 Conteúdo:

// repositories/server/fieldApi.ts
import { Field } from '@/lib/types/indexeddb';

const baseUrl = '/api/fields';

export async function getFields(survey_id: string, survey_type: string): Promise<Field[]> {
  const url = `${baseUrl}?survey_id=${survey_id}&survey_type=${survey_type}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar campos');
  const data = await res.json();
  return data || [];
}

export async function createField(
  survey_id: string,
  survey_type: string,
  payload: Partial<Field>
): Promise<Field> {
  const url = `${baseUrl}?survey_id=${survey_id}&survey_type=${survey_type}`;
  const res = await fetch(url, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error('Erro ao criar campo');
  const data = await res.json();
  return data;
}

export async function updateField(
  field_id: string,
  survey_id: string,
  survey_type: string,
  payload: Partial<Field>
): Promise<Field> {
  const url = `${baseUrl}?field_id=${field_id}&survey_id=${survey_id}&survey_type=${survey_type}`;
  const res = await fetch(url, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(payload),
  });
  if (!res.ok) throw new Error('Erro ao atualizar campo');
  const data = await res.json();
  return data.field;
}

export async function deleteField(
  field_id: string,
  survey_id: string,
  survey_type: string
): Promise<{ message: string }> {
  const url = `${baseUrl}?field_id=${field_id}&survey_id=${survey_id}&survey_type=${survey_type}`;
  const res = await fetch(url, {
    method: 'DELETE',
    headers: {
      'Content-Type': 'application/json',
    },
  });
  if (!res.ok) throw new Error('Erro ao deletar campo');
  return res.json();
}



============================================================


📄 Arquivo : fieldOptionApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/fieldOptionApi.ts
--------------------------------------
📜 Conteúdo:

import { FieldOption } from '@/lib/types/indexeddb';

const baseUrl = '/api/field_options';

export async function getFieldOptions(field_id: string): Promise<FieldOption[]> {
  const res = await fetch(`${baseUrl}?field_id=${field_id}`);
  if (!res.ok) throw new Error('Erro ao buscar opções do campo');
  const data = await res.json();
  return data.options || [];
}

export async function createFieldOption(field_id: string, data: Partial<FieldOption>): Promise<FieldOption> {
  const res = await fetch(`${baseUrl}?field_id=${field_id}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar opção do campo');
  const response = await res.json();
  return response.option;
}

export async function updateFieldOption(
  field_id: string,
  option_id: string,
  data: Partial<FieldOption>
): Promise<FieldOption> {
  const res = await fetch(`${baseUrl}?field_id=${field_id}&option_id=${option_id}`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar opção do campo');
  const response = await res.json();
  return response.option;
}

export async function deleteFieldOption(field_id: string, option_id: string): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}?field_id=${field_id}&option_id=${option_id}`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
  });
  if (!res.ok) throw new Error('Erro ao deletar opção do campo');
  return res.json();
}


============================================================


📄 Arquivo : formSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/formSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/formSurveyApi.ts
import { FormSurvey } from '@/lib/types/indexeddb';
const baseUrl = '/api/surveys'; 
export async function getFormSurvey(research_id: string, survey_type: string): Promise<FormSurvey> {
  const url = `${baseUrl}?research_id=${encodeURIComponent(research_id)}&survey_type=${encodeURIComponent(survey_type)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar surveys de formulário');
  return res.json();
}

export async function createFormSurvey(data: FormSurvey): Promise<FormSurvey> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey de formulário');
  return res.json();
}

export async function updateFormSurvey(data: FormSurvey): Promise<FormSurvey> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar survey de formulário');
  return res.json();
}

export async function deleteFormSurvey(data: FormSurvey): Promise<void> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao deletar survey de formulário');
}




============================================================


📄 Arquivo : index.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/index.ts
--------------------------------------
📜 Conteúdo:

export * from './userApi';
export * from './fieldApi';
export * from './researchApi';
export * from './surveyTimeRangeApi';
export * from './surveyRegionApi';
export * from './surveyGroupApi';
export * from './surveyContributorApi';
export * from './surveyAnswerApi';
export * from './staticSurveyApi';
export * from './formSurveyApi';
export * from './dynamicSurveyApi';
export * from './researchContributorApi';
export * from './inputTypeApi';
export * from './fieldOptionApi';


============================================================


📄 Arquivo : inputTypeApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/inputTypeApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/inputTypeApi.ts
import { InputType } from '@/lib/types/indexeddb';

const baseUrl = '/api/input-types';

export async function getInputTypes(): Promise<InputType[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar tipos de input');
  return res.json();
}


============================================================


📄 Arquivo : researchApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/researchApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/researchApi.ts
import { Research } from '@/lib/types/indexeddb';

const baseUrl = '/api/researches';

export async function getResearches(): Promise<Research[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar pesquisas');
  return res.json();
}

export async function getResearchById(id: string): Promise<Research> {
  const res = await fetch(`${baseUrl}/${id}`);
  if (!res.ok) throw new Error('Erro ao buscar pesquisa');
  const { research } = await res.json();
  return research;
}

export async function createResearch(data: Research): Promise<Research> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar pesquisa');
  return res.json();
}

export async function updateResearch(data: Research): Promise<Research> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar pesquisa');
  return res.json();
}

export async function deleteResearch(id: string): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id }),
  });
  if (!res.ok) throw new Error('Erro ao deletar pesquisa');
  return res.json();
}


============================================================


📄 Arquivo : researchContributorApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/researchContributorApi.ts
--------------------------------------
📜 Conteúdo:

import { ResearchContributor } from '@/lib/types/indexeddb';

const baseUrl = '/api/contributors'; 

export async function getResearchContributors(research_id: string): Promise<ResearchContributor[]> {
  const res = await fetch(`${baseUrl}?research_id=${research_id}`);
  if (!res.ok) throw new Error('Erro ao buscar colaboradores da pesquisa');
  return res.json();
}

export async function createResearchContributor(data: ResearchContributor): Promise<ResearchContributor> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar colaborador da pesquisa');
  return res.json();
}

export async function deleteResearchContributor(research_id: string, user_id: string): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    body: JSON.stringify({ user_id, research_id }),
    headers: { 'Content-Type': 'application/json' },
  });
  if (!res.ok) throw new Error('Erro ao deletar colaborador da pesquisa');
  return res.json();
}


============================================================


📄 Arquivo : staticSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/staticSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/StaticSurveyApi.ts
import { StaticSurvey } from '@/lib/types/indexeddb';
const baseUrl = '/api/surveys'; 
export async function getStaticSurvey(research_id: string, survey_type: string): Promise<StaticSurvey[]> {
  const url = `${baseUrl}?research_id=${encodeURIComponent(research_id)}&survey_type=${encodeURIComponent(survey_type)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar surveys de Staticulário');
  return res.json();
}

export async function createStaticSurvey(data: StaticSurvey): Promise<StaticSurvey> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey de Staticulário');
  return res.json();
}

export async function updateStaticSurvey(data: StaticSurvey): Promise<StaticSurvey> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar survey de Staticulário');
  return res.json();
}

export async function deleteStaticSurvey(data: StaticSurvey): Promise<void> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao deletar survey de Staticulário');
}




============================================================


📄 Arquivo : surveyAnswerApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyAnswerApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyAnswerApi.ts
import { SurveyAnswer } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-answers';

export async function getSurveyAnswers(): Promise<SurveyAnswer[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar respostas de coleta');
  return res.json();
}

export async function createSurveyAnswer(data: SurveyAnswer): Promise<SurveyAnswer> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar resposta');
  return res.json();
}


============================================================


📄 Arquivo : surveyContributorApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyContributorApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyContributorApi.ts
import { SurveyContributor } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-contributors';

export async function getSurveyContributors(survey_id: string): Promise<SurveyContributor[]> {
  const url = `${baseUrl}?survey_id=${encodeURIComponent(survey_id)}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar colaboradores da coleta');
  return res.json();
}

export async function createSurveyContributor(data: SurveyContributor): Promise<SurveyContributor> {

  console.log('Creating survey contributor:', data);
  const res = await fetch(`${baseUrl}?survey_id=${encodeURIComponent(data.survey_id)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      survey_type: data.survey_type,
      user_id: data.user_id,
      instruction: data.instruction,
    }),
  });
  if (!res.ok) throw new Error('Erro ao criar colaborador da coleta');
  return res.json();
}

export async function deleteSurveyContributor(survey_id: string, contributor_id: string): Promise<{ message: string }> {
  const url = `${baseUrl}?survey_id=${encodeURIComponent(survey_id)}&contributor_id=${encodeURIComponent(contributor_id)}`;
  const res = await fetch(url, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
  });
  if (!res.ok) throw new Error('Erro ao deletar colaborador');
  return res.json();
}


============================================================


📄 Arquivo : surveyGroupApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyGroupApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyGroupApi.ts
import { SurveyGroup } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-groups';

export async function getSurveyGroups(): Promise<SurveyGroup[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar grupos da coleta');
  return res.json();
}

export async function createSurveyGroup(data: SurveyGroup): Promise<SurveyGroup> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar grupo');
  return res.json();
}


============================================================


📄 Arquivo : surveyRegionApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyRegionApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyRegionApi.ts
import { SurveyRegion } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-regions';

// Busca todas as regiões de uma survey específica
export async function getSurveyRegions(survey_id: string): Promise<SurveyRegion[]> {
  const res = await fetch(`${baseUrl}?survey_id=${encodeURIComponent(survey_id)}`);
  if (!res.ok) throw new Error('Erro ao buscar regiões da coleta');
  return res.json();
}

// Cria uma nova região
export async function createSurveyRegion(data: SurveyRegion): Promise<SurveyRegion> {
  const res = await fetch(`${baseUrl}?survey_id=${encodeURIComponent(data.survey_id)}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar região da coleta');
  return res.json();
}

// Deleta uma região
export async function deleteSurveyRegion(id: string, survey_id: string): Promise<void> {
  const res = await fetch(`${baseUrl}?survey_id=${encodeURIComponent(survey_id)}&id=${encodeURIComponent(id)}`, {
    method: 'DELETE',
  });
  if (!res.ok) throw new Error('Erro ao deletar região da coleta');
}


============================================================


📄 Arquivo : surveyTimeRangeApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyTimeRangeApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyTimeRangeApi.ts
import { SurveyTimeRange } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-time-ranges';

export async function getSurveyTimeRanges(surveyId: string): Promise<SurveyTimeRange[]> {
  const res = await fetch(`${baseUrl}?survey_id=${surveyId}`);
  if (!res.ok) throw new Error('Erro ao buscar faixas de horário');
  return res.json();
}

export async function createSurveyTimeRange(
  surveyId: string,
  surveyType: string,
  data: Omit<SurveyTimeRange, 'id'>
): Promise<SurveyTimeRange> {
  const res = await fetch(`${baseUrl}?survey_id=${surveyId}`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      ...data,
      survey_type: surveyType,
    }),
  });
  if (!res.ok) throw new Error('Erro ao criar faixa de horário');
  return res.json();
}

export async function deleteSurveyTimeRange(surveyId: string, id: string): Promise<void> {
  const res = await fetch(`${baseUrl}?survey_id=${surveyId}&id=${id}`, {
    method: 'DELETE',
  });
  if (!res.ok) throw new Error('Erro ao deletar faixa de horário');
}


============================================================


📄 Arquivo : userApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/userApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/userApi.ts

import { User } from '@/lib/types/indexeddb';

export async function getUsers(): Promise<User[]> {
  const res = await fetch('/api/users');
  if (!res.ok) throw new Error('Erro ao buscar usuários');
  const data = await res.json();
  return data;
}

export async function getUserById(id: string): Promise<User> {
  const res = await fetch(`/api/users/${id}`);
  if (!res.ok) throw new Error('Erro ao buscar usuário');
  const { user } = await res.json();
  return user;
}

export async function createUser(data: Partial<User>): Promise<User> {
  const res = await fetch('/api/users/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar usuário');
  return res.json();
}

export async function updateUser(data: Partial<User>): Promise<User> {
  const res = await fetch('/api/users/update', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar usuário');
  return res.json();
}

export async function deleteUser(id: string): Promise<{ message: string }> {
  const res = await fetch('/api/users/delete', {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id }),
  });
  if (!res.ok) throw new Error('Erro ao deletar usuário');
  return res.json();
}

============================================================


📄 Arquivo : cache.js
📂 Pasta   : services
🧭 Caminho : services/cache.js
--------------------------------------
📜 Conteúdo:

import { initCachedDB } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

// ======================
// UTILS
// ======================

const getStore = async (storeName, mode = "readonly") => {
  const db = await initCachedDB();
  const tx = db.transaction(storeName, mode);
  return tx.objectStore(storeName);
};

const configMap = {
  users: {
    endpoint: "/api/users", // Usado para leitura e sincronização geral
    createEndpoint: "/api/auth/register", // Usado para criar usuário
    updateEndpoint: "/api/users/update", // Usado para atualizar usuário
    deleteEndpoint: "/api/users/delete", // Usado para deletar usuário
    extract: (res) => res.users || [],
    single: (res) => res.user || null,
  },
  researches: {
    endpoint: "/api/researches",
    createEndpoint: "/api/researches/create",
    updateEndpoint: "/api/researches/update",
    deleteEndpoint: "/api/researches/delete",
    extract: (res) => res.researches || [],
    single: (res) => res.research || null,
  },
  surveys: {
    endpoint: "/api/surveys",
    createEndpoint: "/api/surveys/create",
    updateEndpoint: "/api/surveys/update",
    deleteEndpoint: "/api/surveys/delete",
    extract: (res) => res.surveys || [],
    single: (res) => res.research || null,
  },
};

// ======================
// CACHE FUNCTIONS
// ======================

export async function getCachedData(
  storeName,
  {
    paginated = false,
    page = 1,
    perPage = 20,
    order = "desc",
    search = "",
    filterStatus = "",
    filterRole = "",
  } = {}
) {
  const mainStore = await getStore(storeName);
  const baseItems = await mainStore.getAll();

  let pendingItems = [];
  try {
    const pendingStore = await getStore("itemTobeCreated");
    const allPending = await pendingStore.getAll();
    pendingItems = allPending.filter((item) => item._originStore === storeName);
  } catch (err) {
    // Se a store pending não estiver disponível, ignora
  }

  let allItems = [...baseItems, ...pendingItems];

  // 🔍 Filtro por busca (nome ou email)
  if (search) {
    const lowerSearch = search.toLowerCase();
    allItems = allItems.filter(
      (item) =>
        item.name?.toLowerCase().includes(lowerSearch) ||
        item.email?.toLowerCase().includes(lowerSearch)
    );
  }

  if (filterStatus) {
    allItems = allItems.filter((item) => item.status === filterStatus);
  }

  if (filterRole) {
    allItems = allItems.filter((item) => item.role === filterRole);
  }

  allItems.sort((a, b) => {
    const dateA = new Date(a.created_at || a.createdAt || 0).getTime();
    const dateB = new Date(b.created_at || b.createdAt || 0).getTime();
    return order === "asc" ? dateA - dateB : dateB - dateA;
  });

  if (!paginated) return allItems;

  const total = allItems.length;
  const totalPages = Math.ceil(total / perPage);
  const start = (page - 1) * perPage;
  const items = allItems.slice(start, start + perPage);

  return {
    items,
    total,
    page,
    perPage,
    totalPages,
  };
}

export async function getCachedItemById(storeName, id) {
  const store = await getStore(storeName);
  return (await store.get(id)) || null;
}

export async function addCachedItem(storeName, item) {
  const store = await getStore(storeName, "readwrite");
  if (await store.get(item.id)) throw new Error(`Item ${item.id} já existe`);
  await store.put(item);
}

export async function updateCachedItemById(storeName, id, updates) {
  const store = await getStore(storeName, "readwrite");
  const item = await store.get(id);
  if (!item) throw new Error(`Item ${id} não encontrado`);
  const updated = { ...item, ...updates };
  await store.put(updated);
  return updated;
}

export async function deleteCachedItemById(storeName, id) {
  const store = await getStore(storeName, "readwrite");
  if (!(await store.get(id))) throw new Error(`Item ${id} não encontrado`);
  await store.delete(id);
}

// ======================
// SYNC MARKERS
// ======================

export const markItemForCreate = async (store, item) => {
  const mainStore = await getStore(store, "readonly");
  const mainItems = await mainStore.getAll();
  const duplicateInMain = mainItems.find((i) => i.email === item.email);

  let duplicateInPending = false;
  try {
    const pendingStore = await getStore("itemTobeCreated", "readonly");
    const pendingItems = await pendingStore.getAll();
    duplicateInPending = pendingItems.some(
      (i) => i._originStore === store && i.email === item.email
    );
  } catch (err) {
    // Se não conseguir verificar duplicidade, segue sem bloquear.
  }

  if (duplicateInMain || duplicateInPending) {
    throw new Error(`Registro com email ${item.email} já existe.`);
  }

  const tempId = `temp-${uuidv4()}`;
  const newItem = {
    ...item,
    id: tempId,
    _syncStatus: "pendingCreate",
    _originStore: store,
  };

  const pendingStoreWrite = await getStore("itemTobeCreated", "readwrite");
  await pendingStoreWrite.put(newItem);
  return newItem;
};

export const markItemForUpdate = (store, id, updates) =>
  updateCachedItemById(store, id, { ...updates, _syncStatus: "pendingUpdate" });

export async function markItemForDelete(store, id) {
  const item = await getCachedItemById(store, id);
  if (item) {
    await updateCachedItemById(store, id, {
      ...item,
      _syncStatus: "pendingDelete",
    });
  }
}

// ======================
// SANITIZE
// ======================

export const sanitizeData = (data, fields = ["_syncStatus"]) =>
  Object.fromEntries(
    Object.entries(data || {}).filter(([key]) => !fields.includes(key))
  );

export const sanitizeDataArray = (arr, fields) =>
  arr.map((item) => sanitizeData(item, fields));

// ======================
// SYNC FUNCTIONS
// ======================

export async function syncCachedData(store) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  try {
    const res = await fetch(config.endpoint);
    if (!res.ok) throw new Error(`Erro ao sync ${store}`);
    const items = config.extract(await res.json());
    const storeRef = await getStore(store, "readwrite");
    await storeRef.clear();
    for (const item of items) {
      await storeRef.put({ ...item, _syncStatus: "synced" });
    }
    return { success: true, updated: items.length };
  } catch (err) {
    throw err;
  }
}

export async function syncCachedDataById(store, id) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  try {
    const res = await fetch(`${config.endpoint}/${id}`);
    if (!res.ok) throw new Error(`Erro ao sync ${store}/${id}`);
    const item = config.single(await res.json());
    if (!item) throw new Error(`Item ${id} não encontrado`);
    const storeRef = await getStore(store, "readwrite");
    await storeRef.put({ ...item, _syncStatus: "synced" });
    return { success: true, updated: item };
  } catch (err) {
    throw err;
  }
}

export async function syncLocalToServer(store) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  if (!navigator.onLine) return { success: false, message: "Offline" };

  const db = await initCachedDB();

  // Sincroniza pendingCreate
  const mainItems = await db.getAll(store);
  const pendingItems = await db.getAll("itemTobeCreated");
  const toBeCreated = pendingItems.filter(
    (item) => item._originStore === store
  );

  await Promise.all(
    toBeCreated.map(async (item) => {
      try {
        const payload = sanitizeData(item, [
          "_syncStatus",
          "_originStore",
          "id",
        ]);
        const endpointForCreation = config.createEndpoint || config.endpoint;
        const res = await fetch(endpointForCreation, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.ok) {
          const resData = await res.json();
          const serverItem = config.single(resData);
          if (serverItem) {
            await db.put(store, { ...serverItem, _syncStatus: "synced" });
            await db.delete("itemTobeCreated", item.id);
          }
        }
      } catch (err) {
        // Erro na criação é logado internamente se necessário
      }
    })
  );

  // Sincroniza update e delete
  await Promise.all(
    mainItems.map(async (item) => {
      const status = item._syncStatus;
      if (!status?.startsWith("pending")) return;
      const action = status.replace("pending", "").toLowerCase();
      const endpointForAction =
        action === "delete" ? config.deleteEndpoint : config.updateEndpoint;
      const method = action === "delete" ? "DELETE" : "PUT";
      const body = JSON.stringify(sanitizeData(item));
      try {
        const res = await fetch(endpointForAction, {
          method,
          headers: { "Content-Type": "application/json" },
          body,
        });
        if (res.ok) {
          if (action === "delete") {
            await db.delete(store, item.id);
          } else {
            let updatedItem = item;
            try {
              const resData = await res.json();
              const serverItem = config.single(resData);
              if (serverItem) updatedItem = serverItem;
            } catch (_) {}
            await db.put(store, { ...updatedItem, _syncStatus: "synced" });
          }
        }
      } catch (err) {
        // Erro na sincronização de update/delete
      }
    })
  );

  return { success: true };
}

export async function syncServerToCache(store, queryParams = {}) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);

  try {
    const url = new URL(config.endpoint, window.location.origin);
    Object.entries(queryParams).forEach(([key, value]) => {
      if (value !== undefined && value !== null) {
        url.searchParams.set(key, value);
      }
    });

    const res = await fetch(url.toString());
    
    if (res.status === 404  ) {
      return { success: false, message: "Nenhum dado encontrado" };
    }

    if (!res.ok) throw new Error(`Erro ao sync servidor->cache de ${store}`);

    const serverItems = config.extract(await res.json());

    const storeRef = await getStore(store, "readwrite");
    const localItems = await storeRef.getAll();
    const localMap = new Map(localItems.map((item) => [item.id, item]));

    for (const serverItem of serverItems) {
      const local = localMap.get(serverItem.id);
      if (
        !local ||
        local._syncStatus === "synced" ||
        local._syncStatus === "pendingUpdate" ||
        local._syncStatus === "pendingCreate"
      ) {
        await storeRef.put({ ...serverItem, _syncStatus: "synced" });
      }
    }

    return { success: true, updated: serverItems.length };
  } catch (err) {
    throw err;
  }
}


============================================================


📄 Arquivo : registerServiceWorker.js
📂 Pasta   : services
🧭 Caminho : services/registerServiceWorker.js
--------------------------------------
📜 Conteúdo:

// /services/registerServiceWorker.js
export function registerServiceWorker() {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/workers/sw.js')
        .then(reg => console.log('✅ Service Worker registrado!', reg))
        .catch(err => console.error('❌ Erro ao registrar o Service Worker:', err));
    }
  }
  

============================================================


📄 Arquivo : globals.css
📂 Pasta   : styles
🧭 Caminho : styles/globals.css
--------------------------------------
📜 Conteúdo:

@tailwind base;
@tailwind components;
@tailwind utilities;



body {
  color: black;
  background: white;
  font-family: Inter, sans-serif;
}



/* global.css */
.react-calendar {
  @apply rounded-lg p-3 bg-white text-sm;
}
.react-calendar__tile--active {
  @apply bg-black text-white rounded-md;
}
.react-calendar__tile--now {
  @apply bg-blue-100;
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0%);
  }
}

@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0%);
  }
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-slide-in-left {
  animation: slideInLeft 0.3s ease-out;
}



@layer base {
  :root {
    --background: 0 0% 100%;
    --foreground: 0 0% 3.9%;
    --card: 0 0% 100%;
    --card-foreground: 0 0% 3.9%;
    --popover: 0 0% 100%;
    --popover-foreground: 0 0% 3.9%;
    --primary: 0 0% 9%;
    --primary-foreground: 0 0% 98%;
    --secondary: 0 0% 96.1%;
    --secondary-foreground: 0 0% 9%;
    --muted: 0 0% 96.1%;
    --muted-foreground: 0 0% 45.1%;
    --accent: 0 0% 96.1%;
    --accent-foreground: 0 0% 9%;
    --destructive: 0 84.2% 60.2%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 89.8%;
    --input: 0 0% 89.8%;
    --ring: 0 0% 3.9%;
    --chart-1: 12 76% 61%;
    --chart-2: 173 58% 39%;
    --chart-3: 197 37% 24%;
    --chart-4: 43 74% 66%;
    --chart-5: 27 87% 67%;
    --radius: 0.5rem;
  }
  .dark {
    --background: 0 0% 3.9%;
    --foreground: 0 0% 98%;
    --card: 0 0% 3.9%;
    --card-foreground: 0 0% 98%;
    --popover: 0 0% 3.9%;
    --popover-foreground: 0 0% 98%;
    --primary: 0 0% 98%;
    --primary-foreground: 0 0% 9%;
    --secondary: 0 0% 14.9%;
    --secondary-foreground: 0 0% 98%;
    --muted: 0 0% 14.9%;
    --muted-foreground: 0 0% 63.9%;
    --accent: 0 0% 14.9%;
    --accent-foreground: 0 0% 98%;
    --destructive: 0 62.8% 30.6%;
    --destructive-foreground: 0 0% 98%;
    --border: 0 0% 14.9%;
    --input: 0 0% 14.9%;
    --ring: 0 0% 83.1%;
    --chart-1: 220 70% 50%;
    --chart-2: 160 60% 45%;
    --chart-3: 30 80% 55%;
    --chart-4: 280 65% 60%;
    --chart-5: 340 75% 55%;
  }
}



@layer base {
  * {
    @apply border-border;
  }
  body {
    @apply bg-background text-foreground;
  }
}


============================================================


📄 Arquivo : checkAndSyncIfEmpty.js
📂 Pasta   : utils
🧭 Caminho : utils/checkAndSyncIfEmpty.js
--------------------------------------
📜 Conteúdo:

// src/utils/checkAndSyncIfEmpty.js

import { getAllItems } from "@/repositories/indexeddb/indexedDBService"; 

export async function checkAndSyncIfEmpty() {
  try {
    const users = await getAllItems("users");
    if (
      (users.length === 0) &&
      navigator.serviceWorker.controller
    ) {
      navigator.serviceWorker.controller.postMessage("TRIGGER_PULL");
    } else {
      console.log("[App] IndexedDB já possui dados.");
    }
  } catch (error) {
    console.error("[App] Erro ao checar IndexedDB:", error);
  }
}


============================================================


📄 Arquivo : formatDate.js
📂 Pasta   : utils
🧭 Caminho : utils/formatDate.js
--------------------------------------
📜 Conteúdo:

export function formatDateToDDMMYY(dateString) {
  if (!dateString) return "";
  const date = new Date(dateString);
  const day = String(date.getDate()).padStart(2, "0");
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const year = String(date.getFullYear());
  return `${day}/${month}/${year}`;
}

export function formatDateToLocalYYYYMMDD(date) {
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  return `${year}-${month}-${day}`;
}


============================================================


📄 Arquivo : periodicSync.js
📂 Pasta   : utils
🧭 Caminho : utils/periodicSync.js
--------------------------------------
📜 Conteúdo:

// utils/periodicSync.js
export async function initBackgroundSync() {
    if (!('serviceWorker' in navigator)) return;
  
    const reg = await navigator.serviceWorker.ready;
  
    if ('periodicSync' in reg) {
      const perm = await navigator.permissions.query({
        name: 'periodic-background-sync'
      });
  
      if (perm.state === 'granted') {
        const tags = await reg.periodicSync.getTags();
  
        if (!tags.includes('pull-updates')) {
          await reg.periodicSync.register('pull-updates', {
            minInterval: 24 * 60 * 60 * 1000 // 24h
          });
        }
  
        if (!tags.includes('push-pending')) {
          await reg.periodicSync.register('push-pending', {
            minInterval: 24 * 60 * 60 * 1000 // 24h
          });
        }
  
        console.log('[App] PeriodicSync registrado');
      }
    }
  

    if ('sync' in reg) {
      try {
        await reg.sync.register('push-pending');
        console.log('[App] SyncManager registrado');
      } catch (e) {
        console.warn('SyncManager indisponível', e);
      }
    }
  
    const trigger = () => {
      if (navigator.serviceWorker.controller) {
        navigator.serviceWorker.controller.postMessage('TRIGGER_PULL');
      }
    };
  
    window.addEventListener('online', trigger);
    setInterval(trigger, 30 * 60 * 1000); // 30 min
  }
  

============================================================


