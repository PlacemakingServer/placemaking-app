🔎 Dump de Estrutura – Projeto Next.js
Raiz do projeto : ./src
Gerado em       : Thu Apr 24 13:23:54 -03 2025
------------------------------------------------------------

📄 Arquivo : OfflineMapButton.jsx
📂 Pasta   : components
🧭 Caminho : components/OfflineMapButton.jsx
--------------------------------------
📜 Conteúdo:

import React, { useState } from "react";
import MapLeafletNoSSR from "@/components/map/MapLeafletNoSSR";
import Button from "@/components/ui/Button";
import { useLoading } from "@/context/LoadingContext";

export default function OfflineMapButton({ onLocationSelect }) {
  const [showMap, setShowMap] = useState(false);
  const { setIsLoading } = useLoading();

  function openMap() {
    setShowMap(true);
  }

  function closeMap() {
    setShowMap(false);
  }

  async function handleSaveLocation(coords) {
    const { lat, lng } = coords;

    try {
      setIsLoading("Coletando dados da localização...");
      const locationRes = await fetch(
        `https://nominatim.openstreetmap.org/reverse?format=jsonv2&lat=${lat}&lon=${lng}`
      );
      const locationData = await locationRes.json();
      setIsLoading("Obtendo dados do clima...");
      const weatherRes = await fetch(
        `https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true`
      );
      const weatherData = await weatherRes.json();
      const result = {
        lat,
        lng,
        location: locationData.display_name || "Localização não identificada",
        weather_celsius: weatherData.current_weather?.temperature ?? null,
        weather_fahrenheit:
          weatherData.current_weather?.temperature !== undefined
            ? (weatherData.current_weather.temperature * 9) / 5 + 32
            : null,
      };

      onLocationSelect?.(result);
    } catch (err) {
      console.error("Erro ao buscar dados:", err);
      alert("Erro ao buscar informações da localização.");
    } finally {
      setIsLoading(false);
      setShowMap(false);
    }
  }

  return (
    <div>
      {!showMap && (
        <Button
          type="submit"
          variant="dark"
          className="w-md text-sm py-3 active:scale-95"
          onClick={openMap}
        >
          Abrir mapa
        </Button>
      )}

      {showMap && (
        <MapLeafletNoSSR
          lat={-23.5505}
          lng={-46.6333}
          zoom={13}
          onClose={closeMap}
          onSaveLocation={handleSaveLocation}
        />
      )}
    </div>
  );
}


============================================================


📄 Arquivo : FieldActionButtons.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FieldActionButtons.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FieldActionButtons.jsx
import { ArrowUp, ArrowDown, Edit, Trash2 } from "lucide-react";

export default function FieldActionButtons({
  index,
  total,
  onMoveUp,
  onMoveDown,
  onEdit,
  onRemove,
}) {
  return (
    <div className="flex sm:flex-row flex-col justify-end gap-4 sm:items-center w-full sm:w-auto">
      <div className="flex flex-row sm:flex-col justify-center items-center gap-2">
        <button
          onClick={() => onEdit(index)}
          aria-label="Editar pergunta"
          className="p-1 bg-blue-100 hover:bg-blue-200 text-blue-600 rounded-lg transition"
        >
          <Edit size={15} />
        </button>
        <button
          onClick={() => onRemove(index)}
          aria-label="Remover pergunta"
          className="p-1 bg-red-100 hover:bg-red-200 text-red-600 rounded-lg transition"
        >
          <Trash2 size={15} />
        </button>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : FieldMoveButtons.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FieldMoveButtons.jsx
--------------------------------------
📜 Conteúdo:


import { ArrowUp, ArrowDown } from "lucide-react";

export default function FieldMoveButtons({
  index,
  total,
  onMoveUp,
  onMoveDown,
}) {
  return (
    <div className="h-full flex sm:flex-col flex-col justify-between gap-4 sm:items-center w-full sm:w-auto">
      <div className="h-full flex flex-col sm:flex-col justify-between items-center gap-2">
        <button
          onClick={() => index > 0 && onMoveUp(index)}
          aria-label="Mover para cima"
          className="p-1 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg transition"
        >
          <ArrowUp size={15} />
        </button>
        <button
          onClick={() => index < total - 1 && onMoveDown(index)}
          aria-label="Mover para baixo"
          className="p-1 bg-gray-100 hover:bg-gray-200 text-gray-600 rounded-lg transition"
        >
          <ArrowDown size={15} />
        </button>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : FormBuilder.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormBuilder.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import Button from "@/components/ui/Button";
import FormField from "@/components/forms/FormField";
import { motion, AnimatePresence } from "framer-motion";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import SelectedFormFields from "@/components/forms/SelectedFormFields";
import MultipleChoiceEditor from "@/components/forms/MultipleChoiceEditor";
import Switch from "@/components/ui/Switch";

export default function FormBuilder({ onSubmit, survey_id, survey_type }) {
  const [inputTypes, setInputTypes] = useState([]);
  const [formFields, setFormFields] = useState([]);
  const [newOptions, setNewOptions] = useState([]);
  const [editingIndex, setEditingIndex] = useState(null);
  const [showFormBuilder, setShowFormBuilder] = useState(false);
  const [newQuestion, setNewQuestion] = useState({
    title: "",
    inputType: null,
  });

  useEffect(() => {
    fetchInputTypes();
    fetchFields();
  }, []);

  useEffect(() => {
    if (inputTypes.length === 0 || formFields.length === 0) return;

    const updatedFields = formFields.map((field) => {
      const inputType = inputTypes.find((t) => t.id === field.input_type_id);
      return inputType
        ? { ...field, input_type_name: inputType.name, stored_as: inputType.stored_as }
        : field;
    });

    setFormFields(updatedFields);
  }, [inputTypes]);

  const fetchFields = async () => {
    try {
      const res = await fetch(`/api/fields?survey_id=${survey_id}&survey_type=${survey_type}`);
      const data = await res.json();
      if (data.fields) {
        const formattedFields = data.fields.map((field) => ({
          ...field,
          input_type: field.input_type_id,
          input_type_name: null,
          stored_as: null,
        }));
        setFormFields(formattedFields);
      }
    } catch (err) {
      console.error("Erro ao buscar campos:", err);
    }
  };

  const fetchInputTypes = async () => {
    try {
      const res = await fetch("/api/input_types");
      const data = await res.json();
      setInputTypes(data.input_types || []);
    } catch (err) {
      console.error("Erro ao buscar input types:", err);
    }
  };

  const handleCreateOption = async (payload) => {
    try {
      const params = new URLSearchParams(payload);
      const res = await fetch(`/api/field_options/create?${params.toString()}`, { method: "POST" });
      if (!res.ok) throw new Error("Erro ao criar opção");
      return await res.json();
    } catch (err) {
      console.error("Erro ao criar opção:", err);
    }
  };

  const handleSaveQuestion = async () => {
    if (!newQuestion.title || !newQuestion.inputType) return;

    try {
      const res = await fetch(`/api/fields/create`, {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({
          survey_id,
          survey_type,
          title: newQuestion.title,
          description: newQuestion.title,
          input_type_id: newQuestion.inputType.value,
        }),
      });

      const resData = await res.json();
      const fieldData = resData.field;

      if (!res.ok || !fieldData?.id) throw new Error("Falha ao criar a pergunta");

      if (newQuestion.inputType.stored_as === "array") {
        const createdOptions = await Promise.all(
          newOptions.map((opt) =>
            handleCreateOption({
              field_id: fieldData.id,
              option_text: "-",
              option_value: opt.option_df_value,
            })
          )
        );
        fieldData.options = createdOptions;
      }

      if (editingIndex === null) {
        setFormFields((prev) => [...prev, fieldData]);
      } else {
        const updated = [...formFields];
        updated[editingIndex] = fieldData;
        setFormFields(updated);
      }

      setNewQuestion({ title: "", inputType: null });
      setNewOptions([]);
      setEditingIndex(null);
    } catch (err) {
      console.error("Erro ao salvar a pergunta:", err);
    }
  };

  const handleRemoveQuestion = (index) => {
    const updated = [...formFields];
    updated.splice(index, 1);
    setFormFields(updated);
    if (editingIndex === index) {
      setEditingIndex(null);
      setNewQuestion({ title: "", inputType: null });
    }
  };

  const handleEditQuestion = (index) => {
    const item = formFields[index];
    if (!item) return;

    setEditingIndex(index);
    setNewQuestion({
      title: item.title,
      inputType: {
        value: item.input_type,
        label: item.input_type_name,
        stored_as: item.stored_as,
      },
    });
    setNewOptions(item.options || []);
  };

  const handleSaveForm = () => {
    const payload = {
      survey_id,
      fields: formFields,
    };
    if (onSubmit) onSubmit(payload);
  };

  return (
    <div className="space-y-8 max-w-4xl mx-auto p-6 rounded-xl">
      <div className="flex items-center justify-between">
        <div>
          <h2 className="text-xl font-bold text-gray-800">Formulário</h2>
          <p className="text-sm text-gray-600">
            Adicione perguntas e selecione os tipos de resposta.
          </p>
        </div>
        <div className="flex items-center gap-2">
          <Switch checked={showFormBuilder} onChange={setShowFormBuilder} type="arrow"/>
        </div>
      </div>

      {showFormBuilder && (
        <div className="space-y-4">
          <div className="bg-gray-100 p-5 rounded-lg border space-y-4">
            <h3 className="text-md font-semibold text-gray-700">
              {editingIndex === null ? "Adicionar Pergunta" : "Editar Pergunta"}
            </h3>

            <FormField
              legend="Enunciado da Pergunta"
              type="text"
              value={newQuestion.title}
              onChange={(e) =>
                setNewQuestion((prev) => ({ ...prev, title: e.target.value }))
              }
            />

            <div>
              <label className="block text-sm font-medium text-gray-700 mb-1">
                Tipo de Resposta
              </label>
              <MultiSelect
                options={inputTypes.map((t) => ({
                  value: t.id,
                  label: t.name,
                  stored_as: t.stored_as,
                }))}
                value={newQuestion.inputType}
                onChange={(selected) =>
                  setNewQuestion((prev) => ({
                    ...prev,
                    inputType: selected || null,
                  }))
                }
                placeholder="Selecione o tipo de resposta"
                isMulti={false}
                closeMenuOnSelect={true}
              />
            </div>

            {newQuestion.inputType?.stored_as === "array" && (
              <MultipleChoiceEditor
                options={newOptions}
                setOptions={setNewOptions}
              />
            )}

            <div className="flex justify-center">
              <Button variant="verde" onClick={handleSaveQuestion}>
                {editingIndex === null ? "Criar Pergunta" : "Salvar Edição"}
              </Button>
            </div>
          </div>

          <AnimatePresence>
            {formFields.length > 0 && (
              <motion.div
                initial={{ opacity: 0, y: 10 }}
                animate={{ opacity: 1, y: 0 }}
                exit={{ opacity: 0, y: 10 }}
                transition={{ duration: 0.3 }}
              >
                <SelectedFormFields
                  fields={formFields}
                  setFields={setFormFields}
                  onEditQuestion={handleEditQuestion}
                  onRemoveQuestion={handleRemoveQuestion}
                />
              </motion.div>
            )}
          </AnimatePresence>

          <div className="flex justify-center pt-4 pb-2">
            <Button
              variant="secondary"
              onClick={handleSaveForm}
              className="text-base px-6 py-2"
            >
              Salvar Estrutura do Formulário
            </Button>
          </div>
        </div>
      )}
    </div>
  );
}

============================================================


📄 Arquivo : FormField.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormField.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion } from "framer-motion";
import FormFieldDate from "@/components/forms/FormFieldDate";
import FormFieldText from "@/components/forms/FormFieldText";
import FormFieldNumber from "@/components/forms/FormFieldNumber";
import FormFieldTextarea from "@/components/forms/FormFieldTextarea";

export default function FormField({
  legend,
  type = "text",
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(!!value);
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      {type === "date" && (
        <FormFieldDate
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type === "number" && (
        <FormFieldNumber
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type === "textarea" && (
        <FormFieldTextarea
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}

      {type !== "date" && type !== "number" && type !== "textarea" && (
        <FormFieldText
          legend={legend}
          value={value}
          onChange={onChange}
          disabled={disabled}
          bgColor={bgColor}
          error={error}
          helperText={helperText}
          tooltip={tooltip}
        />
      )}
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldDate.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldDate.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Calendar from "react-calendar";
import "react-calendar/dist/Calendar.css";

// Converte um objeto Date para uma string no formato YYYY-MM-DD (usando valores locais)
function formatDateToLocalYYYYMMDD(date) {
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  return `${year}-${month}-${day}`;
}

// Formata uma string no formato YYYY-MM-DD para DD/MM/YYYY, sem criar novo objeto Date
function formatDateToDDMMYY(dateString) {
  if (!dateString) return "";
  const [year, month, day] = dateString.split("-");
  return `${day}/${month}/${year}`;
}

// Converte a string "YYYY-MM-DD" em um objeto Date usando os componentes locais
function parseDateString(dateString) {
  if (!dateString) return new Date();
  const [year, month, day] = dateString.split("-").map(Number);
  return new Date(year, month - 1, day);
}

export default function FormFieldDate({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [calendarOpen, setCalendarOpen] = useState(false);
  const ref = useRef(null);

  // Fecha o calendário ao clicar fora do componente
  useEffect(() => {
    const handleClickOutside = (e) => {
      if (ref.current && !ref.current.contains(e.target)) {
        setCalendarOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  // Exibe a data no formato DD/MM/YYYY
  const displayValue = value ? formatDateToDDMMYY(value) : "__/__/__";

  return (
    <motion.div
      className="relative w-fit"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative" ref={ref}>
        {/* Label */}
        <div className="flex items-center gap-1 mb-1">
          <label className="text-sm font-medium text-gray-700">{legend}</label>
          {tooltip && (
            <span className="text-gray-400 text-xs cursor-help" title={tooltip}>
              ⓘ
            </span>
          )}
        </div>

        {/* Botão que exibe a data e abre o calendário */}
        <button
          type="button"
          onClick={() => setCalendarOpen((prev) => !prev)}
          disabled={disabled}
          className={`w-40 px-4 py-2 border ${
            error
              ? "border-red-500"
              : disabled
              ? "border-gray-200"
              : "border-gray-400"
          } rounded-md text-sm flex justify-between items-center ${bgColor} ${
            disabled ? "cursor-not-allowed text-gray-400" : "hover:border-black"
          }`}
        >
          <span className="text-left">{displayValue}</span>
          <span className="material-symbols-outlined text-base text-gray-500 ml-2">
            calendar_month
          </span>
        </button>

        {/* Popover do calendário */}
        <AnimatePresence>
          {calendarOpen && !disabled && (
            <motion.div
              initial={{ opacity: 0, y: -10 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -10 }}
              transition={{ duration: 0.2 }}
              className="absolute z-50 mt-2 rounded-lg shadow-xl bg-white border border-gray-200"
            >
              <Calendar
                onChange={(date) => {
                  // Cria um objeto Date a partir dos valores locais (ano, mês e dia)
                  const localDate = new Date(
                    date.getFullYear(),
                    date.getMonth(),
                    date.getDate()
                  );
                  const formatted = formatDateToLocalYYYYMMDD(localDate);
                  onChange({ target: { value: formatted } });
                  setCalendarOpen(false);
                }}
                // Converte a string de valor para um objeto Date com a função parseDateString
                value={value ? parseDateString(value) : new Date()}
                className="rounded-lg p-2 [&_.react-calendar__tile--active]:!bg-black [&_.react-calendar__tile--active]:text-white"
              />
            </motion.div>
          )}
        </AnimatePresence>

        {/* Exibe mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldNumber.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldNumber.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FormFieldNumber.jsx
import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldNumber({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(value !== null && value !== "");
  }, [value]);

  return (
    <motion.div
      className="relative w-full max-w-xs" // <-- menor largura
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        {/* Label flutuante */}
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {/* Tooltip opcional */}
        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        {/* Input */}
        <input
          type="number"
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />

        {/* Mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldText.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldText.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldText({
  legend,
  value,
  onChange,
  disabled = false,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(!!value);
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        {/* Label flutuante */}
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {/* Tooltip opcional */}
        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        {/* Input */}
        <input
          type="text"
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />
        {/* Mensagem de erro ou helper */}
        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : FormFieldTextarea.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/FormFieldTextarea.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/FormFieldTextarea.jsx
import { useEffect, useState } from "react";
import { motion } from "framer-motion";

export default function FormFieldTextarea({
  legend,
  value,
  onChange,
  disabled = false,
  rows = 4,
  bgColor = "bg-white",
  error = false,
  helperText = "",
  tooltip = "",
}) {
  const [filled, setFilled] = useState(false);

  useEffect(() => {
    setFilled(value !== null && value !== "");
  }, [value]);

  return (
    <motion.div
      className="relative w-full"
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
    >
      <div className="relative">
        <label
          className={`absolute left-3 top-3 px-1 text-sm text-gray-500 transition-all ${bgColor} rounded-md pointer-events-none ${
            filled ? "-top-2 text-xs text-blue-500" : ""
          }`}
        >
          {legend}
        </label>

        {tooltip && (
          <span
            className="absolute right-3 top-3 text-gray-400 text-sm cursor-help"
            title={tooltip}
          >
            ⓘ
          </span>
        )}

        <textarea
          rows={rows}
          value={value}
          onChange={onChange}
          placeholder=" "
          disabled={disabled}
          className={`peer w-full px-4 py-3 mt-5 text-sm text-gray-900 ${bgColor} border ${
            error ? "border-red-500" : "border-gray-300"
          } rounded-md shadow-sm focus:outline-none focus:ring-0 focus:border-black transition-all resize-y ${
            disabled ? "bg-gray-100 cursor-not-allowed" : ""
          }`}
        />

        {(helperText || error) && (
          <p
            className={`mt-1 text-xs ${
              error ? "text-red-500" : "text-gray-500"
            }`}
          >
            {error || helperText}
          </p>
        )}
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : MultipleChoiceEditor.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/MultipleChoiceEditor.jsx
--------------------------------------
📜 Conteúdo:

// components/forms/MultipleChoiceEditor.jsx
import { useState } from "react";
import { Trash2, Plus } from "lucide-react";
import Button from "@/components/ui/Button";
import FormField from "@/components/forms/FormField";
import { motion, AnimatePresence } from "framer-motion";

export default function MultipleChoiceEditor({ options = [], setOptions }) {
  const [draft, setDraft] = useState({ option_text: "-", option_df_value: "" });

  const handleAdd = () => {
    if (!draft.option_text.trim() || !draft.option_df_value.trim()) return;
    setOptions((prev) => [...prev, draft]);
    setDraft({ option_text: "-", option_df_value: "" });
  };

  const handleRemove = (index) => {
    setOptions((prev) => prev.filter((_, i) => i !== index));
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 10 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.3 }}
      className="space-y-4 p-5 rounded-xl bg-gray-100"
    >
      <h4 className="text-base font-semibold text-gray-800">Opções da pergunta:</h4>

      {/* Campos de entrada */}
      <div className="flex flex-col sm:flex-row gap-3">
        {/* <div className="w-full sm:w-1/5">
          <FormField
            legend="Letra da opção"
            type="text"
            value={draft.option_text}
            onChange={(e) =>
              setDraft((prev) => ({ ...prev, option_text: e.target.value }))
            }
            placeholder="a."
          />
        </div> */}
        <div className="flex-1">
          <FormField
            legend="Valor da opção"
            type="text"
            value={draft.option_df_value}
            onChange={(e) =>
              setDraft((prev) => ({ ...prev, option_df_value: e.target.value }))
            }
            placeholder="Ex: Casa, Apartamento, etc."
          />
        </div>

        <div className="flex items-end">
          <Button
            variant="azul_escuro"
            onClick={handleAdd}
            className="flex items-center gap-2 h-[42px]"
          >
            <Plus size={18} /> Adicionar
          </Button>
        </div>
      </div>

      {/* Lista de opções adicionadas */}
      <div className="space-y-2">
        <AnimatePresence>
          {options.map((opt, idx) => (
            <motion.div
              key={idx}
              initial={{ opacity: 0, y: 5 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -5 }}
              transition={{ duration: 0.2 }}
              className="flex items-center justify-between bg-white border rounded-lg p-3 shadow-sm"
            >
              <div className="text-sm text-gray-700 font-medium">
                <span className="text-gray-500 mr-1">{opt.option_text}</span>
                {opt.option_df_value}
              </div>
              <button
                onClick={() => handleRemove(idx)}
                className="text-red-500 hover:text-red-600 text-xs flex items-center gap-1"
              >
                <Trash2 size={16} /> Remover
              </button>
            </motion.div>
          ))}
        </AnimatePresence>
      </div>
    </motion.div>
  );
}

============================================================


📄 Arquivo : SelectedFormFieldCard.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/SelectedFormFieldCard.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";
import FieldActionButtons from "./FieldActionButtons";

export default function SelectedFormFieldCard({
  field,
  index,
  total,
  onEdit,
  onRemove
}) {
  return (
    <motion.div
      layout
      className="flex flex-col sm:flex-row sm:justify-between sm:items-center gap-4"
    >
      <div className="flex-1 min-w-0 space-y-1">
        <span>
          <span className="text-sm text-gray-500">Pergunta {index + 1} </span>
        </span>
        <p className="font-semibold text-gray-900 text-base sm:text-md break-words">
          {field.title}
        </p>
        <p className="text-sm text-gray-500">
          Respostas do tipo:{" "}
          <span className="font-medium text-gray-700">
            {field.input_type_name}
          </span>
        </p>
      </div>

      <div className="flex sm:flex-col gap-2 justify-end">
        <FieldActionButtons
          index={index}
          total={total}
          onEdit={onEdit}
          onRemove={onRemove}
        />
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : SelectedFormFields.jsx
📂 Pasta   : components/forms
🧭 Caminho : components/forms/SelectedFormFields.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import SelectedFormFieldCard from "./SelectedFormFieldCard";
import FieldMoveButtons from "./FieldMoveButtons";
import { useEffect } from "react";

export default function SelectedFormFields({
  fields = [],
  setFields,
  onEditQuestion,
  onRemoveQuestion,
}) {
  const moveItem = (fromIndex, toIndex) => {
    if (toIndex < 0 || toIndex >= fields.length) return;
    const newArr = [...fields];
    [newArr[toIndex], newArr[fromIndex]] = [newArr[fromIndex], newArr[toIndex]];
    setFields(newArr);
  };


  return (
    <div className="mt-8 max-w-4xl mx-auto space-y-6 px-4">
      <h3 className="text-lg font-semibold text-gray-800">Perguntas:</h3>
      <AnimatePresence>
        {fields.map((field, index) => (
          <motion.div
            key={field.id}
            layout
            initial={{ opacity: 0, y: -10 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            transition={{ type: "spring", bounce: 0.3 }}
            className="flex gap-3 items-center justify-between"
          >
            <div className="flex-1 rounded-xl bg-white border shadow-sm p-5 flex flex-col justify-between">
              <SelectedFormFieldCard
                field={field}
                index={index}
                total={fields.length}
                onEdit={onEditQuestion}
                onRemove={onRemoveQuestion}
                onMoveUp={() => moveItem(index, index - 1)}
                onMoveDown={() => moveItem(index, index + 1)}
              />
            </div>

            <div className="flex flex-col sm:flex-col gap-2 justify-between h-full sm:h-auto sm:justify-between">
              <FieldMoveButtons
                index={index}
                total={fields.length}
                onMoveUp={() => moveItem(index, index - 1)}
                onMoveDown={() => moveItem(index, index + 1)}
              />
            </div>
          </motion.div>
        ))}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : PrivateLayout.jsx
📂 Pasta   : components/layouts
🧭 Caminho : components/layouts/PrivateLayout.jsx
--------------------------------------
📜 Conteúdo:

// src/components/PrivateLayout.jsx
import { useState } from "react";
import Head from "next/head";
import SidebarDesktop from "./nav/SidebarDesktop";
import SidebarMobile from "./nav/SidebarMobile";
import TopBar from "./nav/TopBar";
import { useAuth } from "@/context/AuthContext";

export default function PrivateLayout({ children, pageName}) {
  const [sidebarOpen, setSidebarOpen] = useState(false);
  const { userData } = useAuth();

  return (
    <>
      <Head>
        <title>{pageName || "Área Logada"}</title>
      </Head>
      <div className="flex h-screen overflow-hidden">
        {/* Sidebar para desktop */}
        <SidebarDesktop userRole={userData?.role} />
        {/* Sidebar para mobile */}
        <SidebarMobile userRole={userData?.role} sidebarOpen={sidebarOpen} setSidebarOpen={setSidebarOpen} />
        {/* Conteúdo principal */}
        <div className="flex flex-col flex-1 overflow-hidden">
          <TopBar setSidebarOpen={setSidebarOpen} pageName={pageName} />
          <main className="flex-1 overflow-y-auto bg-gradient-to-br from-white to-gray-200">
            {children}
          </main>
        </div>
      </div>
    </>
  );
}


============================================================


📄 Arquivo : PublicLayout.jsx
📂 Pasta   : components/layouts
🧭 Caminho : components/layouts/PublicLayout.jsx
--------------------------------------
📜 Conteúdo:

import Head from "next/head";

export default function PublicLayout({ children, pageName }) {
  return (
    <>
      <Head>
        <title>{pageName ? `${pageName}` : "Minha Aplicação"}</title>
      </Head>
      <main className="min-h-screen bg-white">
        {children}
      </main>
    </>
  );
}


============================================================


📄 Arquivo : SidebarDesktop.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/SidebarDesktop.jsx
--------------------------------------
📜 Conteúdo:

import Link from "next/link";
import Image from "next/image";
import { TABS, PERMISSION_TABS, TABSTYLES } from "@/config/tabs";
import { useRouter } from "next/router";
import { useState, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Button from "@/components/ui/Button";
import { initAuthDB } from "@/lib/db";
import FullscreenButton from "@/components/ui/FullscreenButton";

function getAllowedTabs(userRole) {
  const isAllowed = (name) => {
    let restrictedRoles = [];
    for (const role in PERMISSION_TABS) {
      if (PERMISSION_TABS[role].includes(name)) {
        restrictedRoles.push(role);
      }
    }
    return restrictedRoles.length === 0 || restrictedRoles.includes(userRole);
  };

  return Object.entries(TABS)
    .map(([tabName, tabData]) => {
      if (tabData.subTabs) {
        const allowedSubTabs = Object.entries(tabData.subTabs).filter(
          ([subTabName]) => isAllowed(subTabName)
        );
        if (allowedSubTabs.length > 0) {
          return [tabName, { ...tabData, allowedSubTabs }];
        }
        return null;
      } else {
        return isAllowed(tabName) ? [tabName, tabData] : null;
      }
    })
    .filter(Boolean);
}

export default function SidebarDesktop({ userRole }) {
  const [expanded, setExpanded] = useState(true);
  const [hoveredTab, setHoveredTab] = useState(null);
  const [openDropdown, setOpenDropdown] = useState(null);
  const router = useRouter();
  const allowedTabs = getAllowedTabs(userRole);

  useEffect(() => {
    if (expanded) {
      setHoveredTab(null);
    }
  }, [expanded]);

  const handleLogout = async () => {
    await fetch("/api/auth/logout", { method: "POST" });
    try {
      const db = await initAuthDB();
      await db.clear("user-data");
      await db.clear("user-creds");
    } catch (err) {
      console.error("Erro ao limpar IndexedDB:", err);
    }
    window.location.href = "/login";
  };

  const handleTabClick = (name, link, hasSubTabs) => {
    if (hasSubTabs) {
      setOpenDropdown(openDropdown === name ? null : name);
    } else {
      router.push(link);
    }
  };

  return (
    <motion.div
      initial={{ width: 256 }}
      animate={{ width: expanded ? 256 : 72 }}
      transition={{ duration: 0.3, ease: "easeInOut" }}
      className="hidden md:flex md:flex-shrink-0 bg-white border-r border-gray-200 p-4"
    >
      <div className="flex flex-col h-full w-full justify-between">
        {/* Header */}
        <div className="flex items-center justify-between px-4 h-16 border-b">
          {expanded && (
            <Link href="/" onClick={(e) => e.stopPropagation()}>
              <Image
                src="/img/placemaking.png"
                alt="Logo"
                width={100}
                height={40}
                className="object-contain transition-all duration-300"
                priority
              />
            </Link>
          )}
          <button
            onClick={(e) => {
              e.stopPropagation();
              setExpanded((prev) => !prev);
            }}
            className="text-gray-500 hover:text-gray-800"
          >
            <span className="material-symbols-outlined text-xl">
              {expanded ? "chevron_left" : "chevron_right"}
            </span>
          </button>
        </div>

        {/* Navegação (tabs) */}
        <nav className="flex-1 overflow-y-auto py-4 space-y-1">
          {allowedTabs.map(([name, data]) => {
            const hasSubTabs = data.allowedSubTabs;
            const isActive =
              router.pathname === data.link ||
              (hasSubTabs &&
                data.allowedSubTabs.some(
                  ([, subData]) => subData.link === router.pathname
                ));
            return (
              <div key={name} className="relative">
                <div
                  onMouseEnter={() => {
                    if (!expanded) setHoveredTab(name);
                  }}
                  onMouseLeave={() => {
                    if (!expanded) setHoveredTab(null);
                  }}
                >
                  <button
                    onClick={(e) => {
                      e.stopPropagation();
                      handleTabClick(name, data.link, hasSubTabs);
                    }}
                    className={`group flex items-center gap-3 px-4 py-2 rounded-md transition-all w-full ${
                      isActive ? TABSTYLES.active : TABSTYLES.inactive
                    } ${!expanded ? "justify-center" : ""}`}
                  >
                    <span className="material-symbols-outlined text-xl">
                      {data.icon}
                    </span>
                    {expanded && (
                      <span className="text-sm font-medium whitespace-nowrap">
                        {name}
                      </span>
                    )}
                    {hasSubTabs && expanded && (
                      <span className="ml-auto material-symbols-outlined">
                        {openDropdown === name ? "expand_less" : "expand_more"}
                      </span>
                    )}
                  </button>
                  {!expanded && hoveredTab === name && (
                    <AnimatePresence>
                      <motion.div
                        initial={{ opacity: 0, x: 10 }}
                        animate={{ opacity: 1, x: 0 }}
                        exit={{ opacity: 0, x: 10 }}
                        transition={{ duration: 0.2 }}
                        className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
                      >
                        {name}
                      </motion.div>
                    </AnimatePresence>
                  )}
                </div>
                {hasSubTabs && openDropdown === name && expanded && (
                  <motion.div
                    initial={{ opacity: 0, height: 0, y: -10 }}
                    animate={{ opacity: 1, height: "auto", y: 0 }}
                    exit={{ opacity: 0, height: 0, y: -10 }}
                    transition={{ duration: 0.3 }}
                    className="ml-3 mt-1 space-y-1 bg-white rounded-md"
                  >
                    {data.allowedSubTabs.map(([subName, subData]) => {
                      const isSubActive = router.pathname === subData.link;
                      return (
                        <Link
                          key={subName}
                          href={subData.link}
                          onClick={(e) => e.stopPropagation()}
                          className={`flex items-center gap-2 px-4 py-2 transition-all rounded-md ${
                            isSubActive
                              ? "bg-black text-white"
                              : "bg-white text-gray-700 hover:bg-gray-50"
                          }`}
                        >
                          <span className="material-symbols-outlined text-sm">
                            {subData.icon}
                          </span>
                          <span className="text-sm font-medium">{subName}</span>
                        </Link>
                      );
                    })}
                  </motion.div>
                )}
              </div>
            );
          })}
        </nav>

        {/* Footer (Logout) */}
        {/* Footer (Fullscreen + Logout) */}
        <div className="space-y-1">
          <FullscreenButton
            expanded={expanded}
            hovered={hoveredTab}
            setHovered={setHoveredTab}
          />

          <div
            className="relative"
            onMouseEnter={() => {
              if (!expanded) setHoveredTab("Logout");
            }}
            onMouseLeave={() => {
              if (!expanded) setHoveredTab(null);
            }}
          >
            <Button
              onClick={handleLogout}
              variant="transparent_vermelho"
              className={`w-full flex items-center gap-2 px-4 py-2 rounded transition ${
                !expanded ? "justify-center" : ""
              }`}
            >
              <span className="material-symbols-outlined text-xl">logout</span>
              {expanded && (
                <span className="text-sm font-medium whitespace-nowrap">
                  Logout
                </span>
              )}
            </Button>

            {!expanded && hoveredTab === "Logout" && (
              <AnimatePresence>
                <motion.div
                  initial={{ opacity: 0, x: 10 }}
                  animate={{ opacity: 1, x: 0 }}
                  exit={{ opacity: 0, x: 10 }}
                  transition={{ duration: 0.2 }}
                  className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
                >
                  Logout
                </motion.div>
              </AnimatePresence>
            )}
          </div>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : SidebarMobile.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/SidebarMobile.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";
import Link from "next/link";
import Image from "next/image";
import { TABS, PERMISSION_TABS, TABSTYLES } from "@/config/tabs";
import { useRouter } from "next/router";
import { useState } from "react";
import { initAuthDB } from "@/lib/db";
import Button from "@/components/ui/Button";

function getAllowedTabs(userRole) {
  const isAllowed = (name) => {
    let restrictedRoles = [];
    for (const role in PERMISSION_TABS) {
      if (PERMISSION_TABS[role].includes(name)) {
        restrictedRoles.push(role);
      }
    }
    return restrictedRoles.length === 0 || restrictedRoles.includes(userRole);
  };

  return Object.entries(TABS)
    .map(([tabName, tabData]) => {
      if (tabData.subTabs) {
        const allowedSubTabs = Object.entries(tabData.subTabs).filter(
          ([subTabName]) => isAllowed(subTabName)
        );
        if (allowedSubTabs.length > 0) {
          return [tabName, { ...tabData, allowedSubTabs }];
        }
        return null;
      } else {
        return isAllowed(tabName) ? [tabName, tabData] : null;
      }
    })
    .filter(Boolean);
}

export default function SidebarMobile({
  userRole,
  sidebarOpen,
  setSidebarOpen,
}) {
  const allowedTabs = getAllowedTabs(userRole);
  const router = useRouter();
  const [openDropdown, setOpenDropdown] = useState(null);

  const sidebarVariants = {
    hidden: { x: "-100%" },
    visible: { x: 0 },
  };

  const handleLogout = async () => {
    await fetch("/api/auth/logout", { method: "POST" });
    try {
      const db = await initAuthDB();
      await db.clear("user-data");
      await db.clear("user-creds");
    } catch (err) {
      console.error("Erro ao limpar IndexedDB:", err);
    }
    window.location.href = "/login";
  };

  const handleTabClick = (name, link, hasSubTabs) => {
    if (hasSubTabs) {
      setOpenDropdown(openDropdown === name ? null : name);
    } else {
      router.push(link);
      setSidebarOpen(false);
    }
  };

  return (
    <>
      {sidebarOpen && (
        <div className="fixed inset-0 z-40 flex md:hidden">
          {/* Overlay */}
          <motion.div
            className="fixed inset-0 bg-gray-600 bg-opacity-75"
            onClick={() => setSidebarOpen(false)}
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />

          {/* Sidebar principal */}
          <motion.div
            className="relative flex flex-col max-w-xs w-full bg-white"
            initial="hidden"
            animate="visible"
            exit="hidden"
            variants={sidebarVariants}
            drag="x"
            dragConstraints={{ left: 0, right: 300 }}
            onDragEnd={(event, info) => {
              if (info.point.x < 50) {
                setSidebarOpen(false);
              }
            }}
          >
            {/* Botão de fechar */}
            <div className="absolute top-0 right-0 -mr-12 pt-2">
              <button
                type="button"
                className="ml-1 flex items-center justify-center h-10 w-10 rounded-full focus:outline-none focus:bg-gray-600"
                onClick={() => setSidebarOpen(false)}
              >
                <span className="sr-only">Fechar menu</span>
                <svg
                  className="h-6 w-6 text-white"
                  xmlns="http://www.w3.org/2000/svg"
                  fill="none"
                  viewBox="0 0 24 24"
                  stroke="currentColor"
                >
                  <path
                    strokeLinecap="round"
                    strokeLinejoin="round"
                    strokeWidth={2}
                    d="M6 18L18 6M6 6l12 12"
                  />
                </svg>
              </button>
            </div>

            {/* Logo */}
            <div className="flex items-center h-16 px-4 bg-white border-b">
              <Link href="/" onClick={() => setSidebarOpen(false)}>
                <Image
                  src="/img/placemaking.png"
                  alt="Logo"
                  width={100}
                  height={40}
                  className="object-contain"
                  priority
                />
              </Link>
            </div>

            {/* Tabs */}
            <nav className="flex-1 px-2 py-4 space-y-2 overflow-y-auto">
              {allowedTabs.map(([name, data]) => {
                const hasSubTabs = data.allowedSubTabs;
                const isActive =
                  router.pathname === data.link ||
                  (hasSubTabs &&
                    data.allowedSubTabs.some(
                      ([, subData]) => subData.link === router.pathname
                    ));
                return (
                  <div key={name} className="space-y-1">
                    <button
                      onClick={() =>
                        handleTabClick(name, data.link, hasSubTabs)
                      }
                      className={`flex items-center gap-2 px-4 py-2 rounded w-full transition-all ${
                        isActive ? TABSTYLES.active : TABSTYLES.inactive
                      }`}
                    >
                      <span className="material-symbols-outlined text-base">
                        {data.icon}
                      </span>
                      <span className="text-sm font-medium">{name}</span>
                      {hasSubTabs && (
                        <span className="ml-auto material-symbols-outlined">
                          {openDropdown === name
                            ? "expand_less"
                            : "expand_more"}
                        </span>
                      )}
                    </button>
                    {hasSubTabs && openDropdown === name && (
                      <motion.div
                        initial={{ opacity: 0, height: 0, y: -10 }}
                        animate={{ opacity: 1, height: "auto", y: 0 }}
                        exit={{ opacity: 0, height: 0, y: -10 }}
                        transition={{ duration: 0.3 }}
                        className="ml-4 mt-1 space-y-1 bg-white rounded-md"
                      >
                        {data.allowedSubTabs.map(([subName, subData]) => {
                          const isSubActive = router.pathname === subData.link;
                          return (
                            <Link
                              key={subName}
                              href={subData.link}
                              onClick={() => setSidebarOpen(false)}
                              className={`flex items-center gap-2 px-4 py-2 transition-all rounded-md ${
                                isSubActive
                                  ? "bg-black text-white"
                                  : "bg-white text-gray-700 hover:bg-gray-50"
                              }`}
                            >
                              <span className="material-symbols-outlined text-sm">
                                {subData.icon}
                              </span>
                              <span className="text-sm font-medium">
                                {subName}
                              </span>
                            </Link>
                          );
                        })}
                      </motion.div>
                    )}
                  </div>
                );
              })}
            </nav>

            <div className="border-t px-4 py-3">
              <Button
                onClick={async () => {
                  await handleLogout();
                  setSidebarOpen(false);
                }}
                variant="transparent_vermelho"
                className="w-full flex items-center gap-2"
              >
                <span className="material-symbols-outlined text-base">
                  logout
                </span>
                <span className="text-sm font-medium">Logout</span>
              </Button>
            </div>
          </motion.div>

          {/* Spacer para evitar scroll no fundo */}
          <div className="flex-shrink-0 w-14" aria-hidden="true" />
        </div>
      )}
    </>
  );
}


============================================================


📄 Arquivo : TopBar.jsx
📂 Pasta   : components/layouts/nav
🧭 Caminho : components/layouts/nav/TopBar.jsx
--------------------------------------
📜 Conteúdo:

// src/components/TopBar.jsx
import { motion } from "framer-motion";
import Link from "next/link";
import { useAuth } from "@/context/AuthContext";
import { useNetworkStatus } from "@/lib/network";

export default function TopBar({ setSidebarOpen, pageName }) {
  const { userData } = useAuth();
  const isOnline = useNetworkStatus();
  return (
    <header className="flex items-center justify-between px-4 py-2 bg-white border-b border-gray-100">
      <div className="flex items-center">
        <button
          type="button"
          className="md:hidden p-2 rounded-md text-gray-500 hover:text-gray-900 hover:bg-gray-100 focus:outline-none"
          onClick={() => setSidebarOpen(true)}
        >
          <span className="sr-only">Abrir menu</span>
          <motion.svg
            className="h-6 w-6"
            xmlns="http://www.w3.org/2000/svg"
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
            whileHover={{ scale: 1.1 }}
          >
            <path
              strokeLinecap="round"
              strokeLinejoin="round"
              strokeWidth={2}
              d="M4 6h16M4 12h16M4 18h16"
            />
          </motion.svg>
        </button>
        <h2 className="text-xl font-semibold ml-2">
          {pageName || "Área Logada"}
        </h2>
        <p
          className={`text-xs flex items-center justify-center gap-2 rounded-md px-3 py-2 ml-2 font-medium transition-all
    ${isOnline ? "bg-emerald-50 text-emerald-700" : "bg-rose-50 text-rose-700"}
  `}
        >
          <span
            className={`w-2 h-2 rounded-full inline-block 
      ${isOnline ? "bg-emerald-500" : "bg-rose-500"}
    `}
          />
          {isOnline ? "Conectado" : "Sem conexão"}
        </p>
      </div>
      <div>
        <Link
          href={`/users/${userData?.id}`}
          className="text-gray-600 hover:text-gray-800"
        >
          <span className="sr-only">Perfil</span>
          <motion.svg
            className="h-8 w-8 rounded-full border border-gray-300"
            fill="currentColor"
            viewBox="0 0 24 24"
            whileHover={{ scale: 1.05 }}
          >
            <path d="M12 12c2.7 0 4-1.3 4-4s-1.3-4-4-4-4 1.3-4 4 1.3 4 4 4zm0 2c-2.7 0-8 1.3-8 4v2h16v-2c0-2.7-5.3-4-8-4z" />
          </motion.svg>
        </Link>
      </div>
    </header>
  );
}


============================================================


📄 Arquivo : LocationMarker.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/LocationMarker.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect } from 'react';
import { Marker, Popup, useMapEvents } from 'react-leaflet';

export default function LocationMarker({ location, setLocation }) {
  const map = useMapEvents({
    click(e) {
      setLocation(e.latlng);
    },
  });

  useEffect(() => {
    if (location) {
      setTimeout(() => {
        map.flyTo([location.lat, location.lng], 16);
      }, 100);
    }
  }, [location, map]);

  return location ? (
    <Marker position={location}>
      <Popup>
        Latitude: {location.lat.toFixed(4)}, Longitude: {location.lng.toFixed(4)}
      </Popup>
    </Marker>
  ) : null;
}


============================================================


📄 Arquivo : MapLeafletComponent.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapLeafletComponent.jsx
--------------------------------------
📜 Conteúdo:

// /components/map/MapLeafletComponent.js
import React, { useState, useRef } from "react";
import {
  MapContainer,
  TileLayer,
  LayersControl,
  ZoomControl,
} from "react-leaflet";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import Button from "@/components/ui/Button";
import SearchControl from "@/components/map/SearchControl";
import LocationMarker from "@/components/map/LocationMarker";

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: "/maps/marker-icon.png",
  iconUrl: "/maps/marker-icon.png",
  shadowUrl: "/maps/marker-shadow.png",
});

const { BaseLayer } = LayersControl;

export default function MapLeafletComponent({
  lat = -23.5505,
  lng = -46.6333,
  zoom = 13,
  onClose,
  onSaveLocation,
}) {
  const [location, setLocation] = useState(null);
  const mapRef = useRef();

  const handleSaveLocation = () => {
    if (location) {
      onSaveLocation?.(location); // Envia a posição exata do pin para o pai
    } else {
      alert("Nenhuma localização selecionada.");
    }
  };

  return (
    <div className="fixed inset-0 z-50 flex items-center justify-center bg-black bg-opacity-70">
      <div className="relative w-full max-w-5xl mx-4 bg-transparent rounded-lg shadow-lg overflow-hidden">
        <SearchControl
          onNavigate={(coords) => {
            setLocation({ lat: coords[0], lng: coords[1] });
          }}
        />

        <div className="w-full h-[70vh] md:h-[80vh] rounded-lg overflow-hidden">
          <MapContainer
            center={[lat, lng]}
            zoom={zoom}
            scrollWheelZoom={true}
            className="w-full h-full"
            zoomControl={false}
            whenCreated={(mapInstance) => {
              mapRef.current = mapInstance;
            }}
          >
            <ZoomControl position="bottomleft" />
            <LayersControl position="bottomright">
              <BaseLayer name="Default">
                <TileLayer
                  attribution='&copy; <a href="https://www.openstreetmap.org/copyright">
                    OpenStreetMap</a> contributors'
                  url="https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png"
                />
              </BaseLayer>
              <BaseLayer checked name="Carto Voyager">
                <TileLayer
                  attribution='&copy; <a href="https://carto.com/attributions">CARTO</a> &copy; 
                    <a href="https://www.openstreetmap.org/copyright">
                    OpenStreetMap</a> contributors'
                  url="https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
                />
              </BaseLayer>
            </LayersControl>

            <LocationMarker location={location} setLocation={setLocation} />
          </MapContainer>
        </div>

        <div className="bg-transparent p-4 flex justify-center gap-4">
          <Button
            onClick={handleSaveLocation}
            className="px-4 py-2 transition flex justify-evenly items-center gap-2"
            variant="azul_escuro"
          >
            <span className="material-symbols-outlined text-xl">place</span>
            <span>Salvar</span>
          </Button>

          <Button
            onClick={onClose}
            className="px-4 py-2 transition flex justify-evenly items-center gap-2"
            variant="vermelho"
          >
            <span className="material-symbols-outlined text-xl">close</span>
            <span>Fechar</span>
          </Button>
        </div>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : MapLeafletNoSSR.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapLeafletNoSSR.jsx
--------------------------------------
📜 Conteúdo:

// /components/map/MapLeafletNoSSR.tsx

import dynamic from 'next/dynamic';
import React from 'react';

// Faz import dinâmico do seu componente real de mapa
const MapLeafletComponent = dynamic(() => import('@/components/map/MapLeafletComponent'), {
  ssr: false, // Desativa SSR para o Leaflet não quebrar
});

export default function MapLeafletNoSSR(props) {
  return <MapLeafletComponent {...props} />;
}


============================================================


📄 Arquivo : MapPreview.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapPreview.jsx
--------------------------------------
📜 Conteúdo:

// components/map/MapPreview.jsx
import { MapContainer, TileLayer, Marker, Popup } from "react-leaflet";
import "leaflet/dist/leaflet.css";
import L from "leaflet";
import React from "react";

delete L.Icon.Default.prototype._getIconUrl;
L.Icon.Default.mergeOptions({
  iconRetinaUrl: "/maps/marker-icon.png",
  iconUrl: "/maps/marker-icon.png",
  shadowUrl: "/maps/marker-shadow.png",
});

export default function MapPreview({
  lat,
  lng,
  width = "100%",
  height = "200px",
  zoom = 16,
}) {
  if (!lat || !lng) return null;

  return (
    <div
      style={{ width, height }}
      className="rounded-md overflow-hidden shadow-sm"
    >
      <MapContainer
        center={[lat, lng]}
        zoom={zoom}
        scrollWheelZoom={false}
        dragging={false}
        doubleClickZoom={false}
        zoomControl={false}
        attributionControl={false}
        className="w-full h-full z-0"
      >
        <TileLayer
          attribution='&copy; <a href="https://carto.com/attributions">CARTO</a> &copy; 
                           <a href="https://www.openstreetmap.org/copyright">
                           OpenStreetMap</a> contributors'
          url="https://{s}.basemaps.cartocdn.com/rastertiles/voyager/{z}/{x}/{y}{r}.png"
        />
        <Marker position={[lat, lng]}>
          <Popup>Localização selecionada</Popup>
        </Marker>
      </MapContainer>
    </div>
  );
}


============================================================


📄 Arquivo : MapPreviewNoSSR.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/MapPreviewNoSSR.jsx
--------------------------------------
📜 Conteúdo:


import dynamic from "next/dynamic";

const MapPreview = dynamic(() => import("./MapPreview"), {
  ssr: false,
});

export default MapPreview;


============================================================


📄 Arquivo : SearchControl.jsx
📂 Pasta   : components/map
🧭 Caminho : components/map/SearchControl.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import { useEffect, useRef, useState } from "react";
import Button from "@/components/ui/Button";

let debounceTimer;

export default function SearchControl({ onNavigate }) {
  const [query, setQuery] = useState('');
  const [loading, setLoading] = useState(false);
  const [expanded, setExpanded] = useState(false);
  const [results, setResults] = useState([]);
  const [hasSearched, setHasSearched] = useState(false);
  const inputRef = useRef(null);

  const fetchResults = async (searchQuery) => {
    if (!searchQuery) {
      setResults([]);
      setHasSearched(false);
      return;
    }

    setLoading(true);
    setHasSearched(true);

    try {
      const response = await fetch(
        `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(searchQuery)}`
      );
      const data = await response.json();
      setResults(data);
    } catch (error) {
      console.error("Erro na busca:", error);
    } finally {
      setLoading(false);
    }
  };

  const handleSelectResult = (place) => {
    setQuery('');
    setResults([]);
    setExpanded(false);
    setHasSearched(false);
    onNavigate([parseFloat(place.lat), parseFloat(place.lon)]);

  };

  // Busca com debounce enquanto digita
  useEffect(() => {
    if (!expanded) return;

    clearTimeout(debounceTimer);
    debounceTimer = setTimeout(() => {
      fetchResults(query);
    }, 500);

    return () => clearTimeout(debounceTimer);
  }, [query]);

  useEffect(() => {
    if (expanded && inputRef.current) {
      setTimeout(() => {
        inputRef.current.focus();
      }, 300);
    }
  }, [expanded]);

  const closeSearch = () => {
    setExpanded(false);
    setQuery('');
    setResults([]);
    setHasSearched(false);
  };

  return (
    <div className="absolute z-[999] top-4 w-full max-w-md px-4">
      <AnimatePresence mode="wait">
        {!expanded ? (
          <motion.div
            key="icon"
            initial={{ scale: 0.8, opacity: 0 }}
            animate={{ scale: 1, opacity: 1 }}
            exit={{ scale: 0.8, opacity: 0 }}
            transition={{ duration: 0.3, ease: "easeInOut" }}
          >
            <Button
              onClick={() => setExpanded(true)}
              className="px-3.5 shadow-md rounded-full bg-white"
              variant="transparent_cinza"
            >
              <span className="material-symbols-outlined text-2xl">search</span>
            </Button>
          </motion.div>
        ) : (
          <motion.div
            key="form"
            initial={{ opacity: 0, y: -10, scale: 0.95 }}
            animate={{ opacity: 1, y: 0, scale: 1 }}
            exit={{ opacity: 0, y: -10, scale: 0.95 }}
            transition={{ duration: 0.25, ease: "easeInOut" }}
            className="bg-white shadow-lg rounded-lg overflow-hidden"
          >
            <div className="flex gap-2 p-3 items-center">
              <button
                type="button"
                onClick={closeSearch}
                className="text-gray-600 hover:text-gray-800 transition"
              >
                <span className="material-symbols-outlined text-2xl">arrow_back</span>
              </button>
              <input
                ref={inputRef}
                type="text"
                placeholder="Buscar local..."
                value={query}
                onChange={(e) => setQuery(e.target.value)}
                className="flex-1 px-3 py-2 border border-gray-300 rounded-md focus:outline-none"
              />
              {loading && (
                <span className="material-symbols-outlined animate-spin text-gray-500">refresh</span>
              )}
            </div>

            <AnimatePresence>
              {(results.length > 0 || hasSearched) && (
                <motion.div
                  initial={{ opacity: 0, y: -6 }}
                  animate={{ opacity: 1, y: 0 }}
                  exit={{ opacity: 0, y: -6 }}
                  transition={{ duration: 0.2 }}
                >
                  {results.length > 0 ? (
                    <>
                      <p className="text-xs text-gray-500 px-4 pt-2 pb-1">
                        Resultados para busca: <span className="font-medium italic">"{query}"</span>
                      </p>
                      <ul className="max-h-64 overflow-y-auto border-t border-gray-200">
                        {results.map((place, index) => (
                          <li
                            key={`${place.place_id}-${index}`}
                            onClick={() => handleSelectResult(place)}
                            className="px-4 py-3 text-sm text-gray-800 cursor-pointer hover:bg-blue-50 hover:text-blue-700 transition-all border-b border-gray-100"
                          >
                            {place.display_name}
                          </li>
                        ))}
                      </ul>
                    </>
                  ) : (
                    <div className="flex flex-col items-center justify-center py-6 px-4 text-gray-400 text-sm">
                      <span className="material-symbols-outlined text-5xl mb-2">search_off</span>
                      Nenhum resultado encontrado para "{query}"
                    </div>
                  )}
                </motion.div>
              )}
            </AnimatePresence>
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : ResearchForm.jsx
📂 Pasta   : components/research
🧭 Caminho : components/research/ResearchForm.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, use } from "react";
import { motion } from "framer-motion";
import dynamic from "next/dynamic";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";
import MapPreview from "@/components/map/MapPreviewNoSSR";
import Switch from "@/components/ui/Switch";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import UserCardCompact from "@/components/ui/UserCardCompact";

const OfflineMapButton = dynamic(
  () => import("@/components/OfflineMapButton"),
  {
    ssr: false,
  }
);

/**
 * ResearchForm
 * - isEdit (boolean): true -> edição, false -> criação
 * - initialData (obj): valores iniciais da pesquisa
 * - onSubmit (função): callback para enviar payload final
 */
export default function ResearchForm({
  initialData = {},
  contributorsData = [],
  onSubmit,
  isEdit = false,
  users = [],
}) {
  const [form, setForm] = useState({
    title: "",
    description: "",
    release_date: "",
    end_date: "",
    lat: "",
    long: "",
    location_title: "",
    weather_celsius: null,
    weather_fahrenheit: null,
    selectedCollaborators: contributorsData || [],
    collaboratorsToAdd: [],
    collaboratorsToRemove: [],
    ...initialData,
  });

  const [showBasicInfo, setShowBasicInfo] = useState(false);
  const [showDates, setShowDates] = useState(false);
  const [showLocation, setShowLocation] = useState(false);
  const [showLocationInfo, setShowLocationInfo] = useState(true);
  const [showCollaborators, setShowCollaborators] = useState(false);
  const [originalCollaborators, setOriginalCollaborators] = useState([]);

  
  const [allCollaborators, setAllCollaborators] = useState([]);
  const [imageUrl, setImageUrl] = useState("");
  
  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  // useEffect(() => {
  //   console.log("Form data:", form);
  // }, []);

  
  const handleLocationSelect = (data) => {
    setForm((prev) => ({
      ...prev,
      lat: data.lat,
      long: data.lng,
      location_title: data.location || "",
      weather_celsius: data.weather_celsius ?? null,
      weather_fahrenheit: data.weather_fahrenheit ?? null,
    }));
  };

  
  const handleDiscard = () => {
    setForm({
      ...initialData,
      selectedCollaborators: originalCollaborators,
      collaboratorsToAdd: [],
      collaboratorsToRemove: [],
    });
  };

  function refreshCollaboratorsDiff(newSelected) {
    const originalArray = Array.isArray(originalCollaborators)
      ? originalCollaborators
      : [];
  
    const originalIds = new Set(originalArray.map((c) => c.value));
    const newIds = new Set(newSelected.map((c) => c.value));
  
    const toAdd = newSelected.filter((c) => !originalIds.has(c.value));
    const toRemove = originalArray.filter((c) => !newIds.has(c.value));
  
    setForm((prev) => ({
      ...prev,
      selectedCollaborators: newSelected,
      collaboratorsToAdd: toAdd,
      collaboratorsToRemove: toRemove,
    }));
  }
  

  const handleSelectChange = (newValue) => {
    if (!isEdit) {
      setForm((prev) => ({ ...prev, selectedCollaborators: newValue }));
    } else {
      refreshCollaboratorsDiff(newValue);
    }
  };


  const handleRemoveAdd = (user) => {
    const newSelected = form.selectedCollaborators.filter(
      (u) => u.value !== user.value
    );
    refreshCollaboratorsDiff(newSelected);
  };


  const handleUndoRemove = (user) => {
    const newSelected = [...form.selectedCollaborators, user];
    refreshCollaboratorsDiff(newSelected);
  };


  const handleSubmit = () => {
    const selected = form.selectedCollaborators.map((c) => ({
      id: c.value,
      name: c.label,
      role: c.role,
      status: c.status,
      email: c.email,
    }));
    const toAdd = form.collaboratorsToAdd.map((c) => ({
      id: c.value,
      name: c.label,
      role: c.role,
      status: c.status,
      email: c.email,
    }));
    const toRemove = form.collaboratorsToRemove.map((c) => ({
      id: c.value,
      name: c.label,
      role: c.role,
      status: c.status,
      email: c.email,
    }));

    const payload = {
      ...(form.id && { id: form.id }),
      title: form.title,
      description: form.description,
      release_date: form.release_date || null,
      end_date: form.end_date || null,
      lat: form.lat,
      long: form.long,
      location_title: form.location_title,
      weather_celsius: form.weather_celsius,
      weather_fahrenheit: form.weather_fahrenheit,
      selectedCollaborators: selected,
      collaboratorsToAdd: toAdd,
      collaboratorsToRemove: toRemove,
    };

    onSubmit?.(payload);
  };
  useEffect(() => {
    if (users) {
      setAllCollaborators(users);
    }
  
    if (contributorsData && isEdit) {
      setOriginalCollaborators(contributorsData || []);
      setForm((prev) => ({
        ...prev,
        selectedCollaborators: contributorsData,
      }));
    }
  }, [users, contributorsData, isEdit]);

  useEffect(() => {
    const idx = Math.floor(Math.random() * 5);
    setImageUrl(`/img/cards/img-${idx}.jpg`);
  }, []);
  

  return (
    <div className="max-w-4xl mx-auto mt-6 bg-white rounded-2xl shadow-md">
      <motion.div
        initial={{ opacity: 0, y: -10 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.5 }}
        className="rounded-t-lg"
        style={{
          backgroundImage: `url('${imageUrl}')`,
          backgroundSize: "cover",
          backgroundPosition: "center",
        }}
      >
        <div className="bg-black/50 px-6 py-8 sm:px-8 sm:py-10">
          <h1 className="text-2xl font-bold text-white drop-shadow">
            {isEdit ? "Editar Pesquisa" : "Criar Pesquisa"}
          </h1>
          <p className="text-sm text-gray-200 mt-1">
            {isEdit
              ? "Atualize os campos abaixo para editar a pesquisa."
              : "Preencha os campos abaixo para iniciar uma nova pesquisa."}
          </p>
        </div>
      </motion.div>

      <div className="p-6 space-y-6">
        <SectionToggle
          title="Informações Básicas"
          isChecked={showBasicInfo}
          onChange={setShowBasicInfo}
        />
        {showBasicInfo && (
          <div className="space-y-4">
            <FormField
              legend="Título"
              type="text"
              value={form.title}
              onChange={handleChange("title")}
            />
            <FormField
              legend="Descrição"
              type="textarea"
              value={form.description}
              onChange={handleChange("description")}
            />
          </div>
        )}

        <hr className="my-6 border-gray-200" />

        <SectionToggle
          title="Período da Pesquisa"
          isChecked={showDates}
          onChange={setShowDates}
        />
        {showDates && (
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <FormField
              legend="Data de Início"
              type="date"
              value={form.release_date || ""}
              onChange={handleChange("release_date")}
            />
            <FormField
              legend="Data de Fim"
              type="date"
              value={form.end_date || ""}
              onChange={handleChange("end_date")}
            />
          </div>
        )}

        <hr className="my-6 border-gray-200" />

        <SectionToggle
          title="Localização"
          isChecked={showLocation}
          onChange={setShowLocation}
        />
        {showLocation && (
          <>
            <div className="p-4 rounded-lg space-y-4 bg-gray-50 border">
              <p className="text-sm text-gray-600">
                Defina manualmente ou pelo mapa interativo.
              </p>
              <div className="grid grid-cols-2 gap-4">
                <FormField
                  legend="Latitude"
                  type="text"
                  value={form.lat}
                  onChange={handleChange("lat")}
                  disabled
                />
                <FormField
                  legend="Longitude"
                  type="text"
                  value={form.long}
                  onChange={handleChange("long")}
                  disabled
                />
              </div>

              <FormField
                legend="Localização (Título)"
                type="text"
                value={form.location_title}
                onChange={handleChange("location_title")}
              />

              <div className="flex flex-col items-center border-t pt-4 gap-2">
                <OfflineMapButton onLocationSelect={handleLocationSelect} />
                <p className="text-xs text-gray-500 text-center">
                  Para obter a localização automaticamente, clique em{" "}
                  <strong>“Abrir mapa”</strong>.
                </p>
              </div>
            </div>

            {!!form.lat && !!form.long && (
              <>
                <div className="flex items-center justify-between border-b pb-2 mt-4">
                  <p className="text-sm text-gray-700 font-medium">
                    Exibir Informações da localização
                  </p>
                  <Switch
                    checked={showLocationInfo}
                    onChange={setShowLocationInfo}
                  />
                </div>
                {showLocationInfo && (
                  <div className="mt-4 text-sm text-gray-700 border rounded-md p-4 bg-gray-50 space-y-4">
                    <div>
                      <strong className="block mb-1">
                        Resumo da Localização:
                      </strong>
                      <p>{form.location_title}</p>
                      <p>Lat: {Number(form.lat).toFixed(6)}</p>
                      <p>Long: {Number(form.long).toFixed(6)}</p>
                      {form.weather_celsius && form.weather_fahrenheit && (
                        <p>
                          Clima: {form.weather_celsius}°C /{" "}
                          {Number(form.weather_fahrenheit).toFixed(1)}°F
                        </p>
                      )}
                    </div>
                    <MapPreview
                      lat={Number(form.lat)}
                      lng={Number(form.long)}
                      height="200px"
                      width="100%"
                    />
                  </div>
                )}
              </>
            )}
          </>
        )}

        <hr className="my-6 border-gray-200" />

        <SectionToggle
          title="Colaboradores"
          isChecked={showCollaborators}
          onChange={setShowCollaborators}
        />
        {showCollaborators && (
          <>
            <MultiSelect
              options={allCollaborators}
              value={form.selectedCollaborators}
              onChange={handleSelectChange}
              placeholder="Selecione colaboradores"
            />
            <p className="text-xs text-gray-500">
              Você pode escolher múltiplos colaboradores para participar.
            </p>

            {/* Em modo edição, exibimos "adicionados" e "removidos" */}
            {isEdit && (
              <div className="mt-6 space-y-6">
                {form.collaboratorsToAdd?.length > 0 && (
                  <div>
                    <h3 className="text-sm font-semibold text-gray-700 mb-2">
                      Colaboradores que serão adicionados
                    </h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                      {form.collaboratorsToAdd.map((usr) => (
                        <UserCardCompact
                          key={usr.value}
                          user={{
                            id: usr.value,
                            name: usr.label,
                            role: usr.role,
                            status: usr.status,
                            email: usr.email,
                          }}
                          borderColor="border-green-500"
                          showRemoveButton={true}
                          onRemove={() => handleRemoveAdd(usr)}
                        />
                      ))}
                    </div>
                  </div>
                )}

                {form.collaboratorsToRemove?.length > 0 && (
                  <div>
                    <h3 className="text-sm font-semibold text-gray-700 mb-2">
                      Colaboradores que serão removidos
                    </h3>
                    <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                      {form.collaboratorsToRemove.map((user) => (
                        <UserCardCompact
                          key={user.value}
                          user={{
                            id: user.value,
                            name: user.label,
                            role: user.role,
                            status: user.status,
                            email: user.email,
                          }}
                          borderColor="border-red-500"
                          showRemoveButton={true}
                          onRemove={() => handleUndoRemove(user)}
                        />
                      ))}
                    </div>
                  </div>
                )}
              </div>
            )}

            {form.selectedCollaborators?.length > 0 && (
              <div className="mt-6 border-t pt-4 space-y-2">
                <h3 className="text-sm font-semibold text-gray-700 mb-2">
                  Colaboradores Selecionados (Estado Final)
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-[14rem] overflow-y-auto">
                  {form.selectedCollaborators.map((user) => (
                    <UserCardCompact
                      key={user.value}
                      user={{
                        id: user.id,
                        name: user.label,
                        role: user.role,
                        status: user.status,
                        email: user.email,
                      }}
                    />
                  ))}
                </div>
              </div>
            )}
          </>
        )}

        {/* Botões finais */}
        <div className="flex justify-center pt-4 gap-6">
          <Button
            type="submit"
            variant="dark"
            className="text-lg py-3 active:scale-95"
            onClick={handleSubmit}
          >
            {isEdit ? "Salvar Alterações" : "Criar Pesquisa"}
          </Button>

          {isEdit && (
            <Button
              variant="warning"
              onClick={handleDiscard}
              className="active:scale-95"
            >
              Descartar Alterações
            </Button>
          )}
        </div>
      </div>
    </div>
  );
}

// Subcomponente para mostrar título + switch
function SectionToggle({ title, isChecked, onChange }) {
  return (
    <div className="flex justify-between items-center">
      <h2 className="text-lg font-semibold text-gray-800">{title}</h2>
      <Switch type="arrow" checked={isChecked} onChange={onChange} />
    </div>
  );
}


============================================================


📄 Arquivo : ResearchLoadingSkeleton.jsx
📂 Pasta   : components/research
🧭 Caminho : components/research/ResearchLoadingSkeleton.jsx
--------------------------------------
📜 Conteúdo:

export default function ResearchLoadingSkeleton() {
  return (
    <div className="max-w-4xl mx-auto mt-6 bg-white rounded-lg shadow-md overflow-hidden animate-pulse">
      {/* Cabeçalho (imagem / título) */}
      <div className="rounded-t-lg bg-gray-200 h-28" />

      {/* Conteúdo */}
      <div className="p-6 space-y-8">
        {/* Seção: Informações Básicas */}
        <div className="space-y-2">
          {/* Título da Seção e Switch */}
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/3" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          {/* Campos */}
          <div className="space-y-3">
            <div className="h-4 bg-gray-200 rounded w-2/3" />
            <div className="h-4 bg-gray-200 rounded w-1/2" />
          </div>
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Datas */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4 mt-2">
            <div className="h-4 bg-gray-200 rounded w-full" />
            <div className="h-4 bg-gray-200 rounded w-full" />
          </div>
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Localização */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="space-y-3 mt-2">
            <div className="h-4 bg-gray-200 rounded w-1/2" />
            <div className="h-4 bg-gray-200 rounded w-3/4" />
          </div>
          <div className="h-4 bg-gray-200 rounded w-1/3" />
          <div className="h-4 bg-gray-200 rounded w-2/3" />
          {/* Mapa preview placeholder */}
          <div className="w-full h-32 bg-gray-200 rounded" />
        </div>

        <hr className="border-gray-200" />

        {/* Seção: Colaboradores */}
        <div className="space-y-2">
          <div className="flex justify-between items-center">
            <div className="h-4 bg-gray-200 rounded w-1/4" />
            <div className="h-5 w-10 bg-gray-200 rounded-full" />
          </div>
          <div className="space-y-2 mt-2">
            {/* Linha do MultiSelect */}
            <div className="h-4 bg-gray-200 rounded w-2/3" />
            {/* Cards placeholder */}
            <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
              <div className="h-16 bg-gray-200 rounded" />
              <div className="h-16 bg-gray-200 rounded" />
              <div className="h-16 bg-gray-200 rounded" />
            </div>
          </div>
        </div>

        {/* Botões de ação final */}
        <div className="flex justify-center gap-6 pt-4">
          <div className="h-10 bg-gray-200 rounded w-1/3" />
          <div className="h-10 bg-gray-200 rounded w-1/3" />
        </div>
      </div>
    </div>
  );
}


============================================================


📄 Arquivo : AddSurveyPrompt.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/AddSurveyPrompt.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Button from "@/components/ui/Button";
import DropdownSelect from "@/components/ui/Multiselect/DropdownSelect";
import Switch from "@/components/ui/Switch"; 
import { set } from "zod";

export default function AddSurveyPrompt({ onContinue }) {
  const surveyOptions = [
    { value: "estatica", label: "Coleta Estática" },
    { value: "dinamica", label: "Coleta Dinâmica" },
    { value: "formulario", label: "Coleta de Entrevistas" },
  ];

  const [showSelect, setShowSelect] = useState(false);
  const [selectedSurvey, setSelectedSurvey] = useState(null);

  const handleSubmit = () => {
    if (!selectedSurvey) return;
    setShowSelect(false);
    setSelectedSurvey(null);
    onContinue(selectedSurvey);
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 40 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="max-w-4xl mx-auto bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-800 p-6 sm:p-8 rounded-2xl space-y-8 shadow-md"
    >
      <div className="flex flex-col sm:flex-row items-center justify-between gap-4">
        <h3 className="text-xl sm:text-2xl font-bold text-zinc-800 dark:text-zinc-100 text-center sm:text-left">
          Deseja adicionar uma coleta para esta pesquisa?
        </h3>

        <Switch checked={showSelect} onChange={setShowSelect} />
      </div>

      <AnimatePresence>
        {showSelect && (
          <motion.div
            key="select-area"
            initial={{ opacity: 0, y: 20 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: 10 }}
            transition={{ duration: 0.3 }}
            className="flex flex-col md:flex-row md:items-end gap-4 justify-center"
          >
            <div className="w-full md:w-2/3">
              <DropdownSelect
                label="Tipo de Coleta"
                options={surveyOptions}
                selected={selectedSurvey}
                onChange={setSelectedSurvey}
                placeholder="Selecione o tipo"
              />
            </div>

            <div className="w-full md:w-auto">
              <Button
                className="w-full md:w-fit px-6 py-2"
                variant="dark"
                onClick={handleSubmit}
                disabled={!selectedSurvey}
              >
                Continuar
              </Button>
            </div>
          </motion.div>
        )}
      </AnimatePresence>
    </motion.div>
  );
}


============================================================


📄 Arquivo : BasicInformation.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/BasicInformation.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import FormField from "@/components/forms/FormField";
import Switch from "@/components/ui/Switch";
import { Info } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";



export default function BasicInformation({
  form,
  setForm,
  showSurveyInformation,
  setShowSurveyInformation,
}) {
  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  return (
    <div className="rounded-lg space-y-4">
      <div className="flex items-center justify-between px-4 py-3 bg-transparent">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Informações da Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <Info
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Adicione um título e descrição para identificar esta coleta.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Informações como título e descrição para identificar essa coleta.
          </p>
        </div>
        <Switch
          checked={showSurveyInformation}
          onChange={setShowSurveyInformation}
          type="arrow"
        />
      </div>

      {showSurveyInformation && (
        <div className="bg-transparent px-4 py-5 mt-2 space-y-5">
          <div className="flex flex-col gap-4">
            <FormField
              legend="Título do Formulário"
              type="text"
              value={form.title}
              onChange={handleChange("title")}
              placeholder="Ex: Coleta de Entrevistas - Praça Roosevelt"
            />
            <FormField
              legend="Descrição"
              type="textarea"
              value={form.description}
              onChange={handleChange("description")}
              placeholder="Breve descrição sobre o objetivo da coleta..."
            />
          </div>

          <p className="text-xs text-gray-500 text-right">
            * Essas informações serão exibidas aos pesquisadores durante a coleta.
          </p>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : CollaboratorSelector.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollaboratorSelector.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import MultiSelect from "@/components/ui/Multiselect/Multiselect";
import UserCardCompact from "@/components/ui/UserCardCompact";
import { HelpCircle } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";

export default function CollaboratorSelector({
  form,
  setForm,
  isEdit,
  availableCollaborators = [],
}) {
  const [useAllFromResearch, setUseAllFromResearch] = useState(true);

  const refreshCollaboratorsDiff = (newSelected) => {
    const original = form.originalCollaborators || [];

    const originalIds = new Set(original.map((c) => c.value));
    const newIds = new Set(newSelected.map((c) => c.value));

    const toAdd = newSelected.filter((c) => !originalIds.has(c.value));
    const toRemove = original.filter((c) => !newIds.has(c.value));

    setForm((prev) => ({
      ...prev,
      selectedCollaborators: newSelected,
      collaboratorsToAdd: toAdd,
      collaboratorsToRemove: toRemove,
    }));
  };

  const handleSelectChange = (newSelected) => {
    if (!isEdit) {
      setForm((prev) => ({
        ...prev,
        selectedCollaborators: newSelected,
      }));
    } else {
      refreshCollaboratorsDiff(newSelected);
    }
  };

  const handleRemoveAdd = (user) => {
    const newSelected = form.selectedCollaborators.filter(
      (u) => u.value !== user.value
    );
    refreshCollaboratorsDiff(newSelected);
  };

  const handleUndoRemove = (user) => {
    const newSelected = [...form.selectedCollaborators, user];
    refreshCollaboratorsDiff(newSelected);
  };

  const handleToggleAll = (checked) => {
    setUseAllFromResearch(checked);
    if (checked) {
      setForm((prev) => ({
        ...prev,
        selectedCollaborators: [],
        collaboratorsToAdd: [],
        collaboratorsToRemove: [],
        use_all_contributors: true,
      }));
    } else {
      setForm((prev) => ({
        ...prev,
        use_all_contributors: false,
      }));
    }
  };

  return (
    <div className="rounded-lg space-y-4">
      <div className="flex items-center justify-between bg-transparent px-4 py-3 transition-all">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Colaboradores da Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <HelpCircle
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Defina manualmente os colaboradores ou use todos os que já fazem parte da pesquisa.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Escolha entre todos os da pesquisa ou selecione individualmente.
          </p>
        </div>
        <div className="flex items-center gap-2">
        <span className="text-sm text-gray-700 whitespace-nowrap">Todos da Pesquisa</span>
          <Switch
            checked={useAllFromResearch}
            onChange={handleToggleAll}
            type="checkbox"
          />
        </div>
      </div>

      <AnimatePresence>
        {!useAllFromResearch && (
          <motion.div
            key="manual-collaborator-select"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.2 }}
            className="space-y-6 bg-transparent px-4 py-5"
          >
            <MultiSelect
              options={availableCollaborators}
              value={form.selectedCollaborators || []}
              onChange={handleSelectChange}
              placeholder="Selecione colaboradores"
            />
            <p className="text-xs text-gray-500">
              Você pode escolher múltiplos colaboradores para essa coleta.
            </p>

            {isEdit && form.collaboratorsToAdd?.length > 0 && (
              <div>
                <h3 className="text-sm font-semibold text-gray-700 mb-2">
                  Colaboradores que serão adicionados
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {form.collaboratorsToAdd.map((usr) => (
                    <UserCardCompact
                      key={usr.value}
                      user={{
                        id: usr.value,
                        name: usr.label,
                        role: usr.role,
                        status: usr.status,
                        email: usr.email,
                      }}
                      borderColor="border-green-500"
                      showRemoveButton={true}
                      onRemove={() => handleRemoveAdd(usr)}
                    />
                  ))}
                </div>
              </div>
            )}

            {isEdit && form.collaboratorsToRemove?.length > 0 && (
              <div>
                <h3 className="text-sm font-semibold text-gray-700 mb-2">
                  Colaboradores que serão removidos
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3">
                  {form.collaboratorsToRemove.map((user) => (
                    <UserCardCompact
                      key={user.value}
                      user={{
                        id: user.value,
                        name: user.label,
                        role: user.role,
                        status: user.status,
                        email: user.email,
                      }}
                      borderColor="border-red-500"
                      showRemoveButton={true}
                      onRemove={() => handleUndoRemove(user)}
                    />
                  ))}
                </div>
              </div>
            )}

            {form.selectedCollaborators?.length > 0 && (
              <div className="mt-6 border-t pt-4 space-y-2">
                <h3 className="text-sm font-semibold text-gray-700 mb-2">
                  Colaboradores Selecionados (Estado Final)
                </h3>
                <div className="grid grid-cols-1 sm:grid-cols-2 lg:grid-cols-3 gap-3 max-h-[14rem] overflow-y-auto">
                  {form.selectedCollaborators.map((user) => (
                    <UserCardCompact
                      key={user.value}
                      user={{
                        id: user.id,
                        name: user.label,
                        role: user.role,
                        status: user.status,
                        email: user.email,
                      }}
                    />
                  ))}
                </div>
              </div>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : CollectionFormSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/CollectionFormSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ClipboardList } from "lucide-react";

import Switch from "@/components/ui/Switch";
import Button from "@/components/ui/Button";
import FormBuilder from "@/components/forms/FormBuilder";
import MicroRegionEditor from "@/components/surveys/MicroRegionEditor";
import LocationForm from "@/components/surveys/LocationForm";
import BasicInformation from "@/components/surveys/BasicInformation";
import CollaboratorSelector from "@/components/surveys/CollaboratorSelector";
import TimeRanges from "@/components/surveys/TimeRanges";

export default function CollectionFormSection({
  initialData = {},
  survey_type,
  research_id,
  handleCancelCreateSurvey,
  handleCreateSurvey,
}) {
  const [enabled, setEnabled] = useState(false);
  const [form, setForm] = useState({
    id: "",
    title: "",
    description: "",
    survey_type: survey_type,
    research_id: research_id,
    ...initialData,
  });
  const [isEdit, setIsEdit] = useState(false);
  const initialDataRef = useRef(JSON.stringify(initialData));
  const [showLocationForm, setShowLocationForm] = useState(false);
  const [showSurveyInformation, setShowSurveyInformation] = useState(false);
  const [microRegions, setMicroRegions] = useState([]);
  const [timeRanges, setTimeRanges] = useState([]);
  const [formStructure, setFormStructure] = useState(
    initialData?.structure || {}
  );

  useEffect(() => {
    console.log("Survey:", initialData);
  }, []);


  useEffect(() => {
    const hasInitialData = initialData && initialData.id;
    const serializedInitial = JSON.stringify(initialData);

    if (initialDataRef.current !== serializedInitial) {
      initialDataRef.current = serializedInitial;
      setForm((prev) => ({ ...prev, ...initialData }));
    }
    if (hasInitialData) {
      setEnabled(false);
    }
    setIsEdit(hasInitialData);
    setEnableFormBuilder(hasInitialData);
  }, [initialData]);

  const [enableFormBuilder, setEnableFormBuilder] = useState(isEdit);

  useEffect(() => {
    setEnableFormBuilder(enabled);
  }, [enabled]);

  const handleSave = async () => {
    const data = await handleCreateSurvey({
      ...form,
      micro_regions: microRegions,
      time_ranges: timeRanges,
    });
    if (data && data.id) {
      setIsEdit(true);
      setEnabled(true);
      setForm((prev) => ({
        ...prev,
        ...data,
      }));
      if (data.structure) {
        setFormStructure(data.structure);
      }
      setEnableFormBuilder(true);
    }
  };

  return (
    <motion.div
      initial={{ opacity: 0, y: 6 }}
      animate={{ opacity: 1, y: 0 }}
      transition={{ duration: 0.4 }}
      className="bg-gray-50 border border-gray-200 rounded-2xl shadow-md p-6 sm:p-8 max-w-4xl mx-auto w-full space-y-6 transition-all"
    >
      <div className="w-full flex items-center justify-between gap-4 flex-wrap sm:flex-nowrap">
        <div className="flex items-center gap-2 text-gray-800">
          <ClipboardList size={20} className="text-green-500" />
          <h2 className="text-xl font-bold">
            {isEdit ? `Entrevista: ${form.title}` : "Nova - Entrevista"}
          </h2>
        </div>
        <div className="flex items-center gap-2 ml-auto">
          <Switch type="arrow" checked={enabled} onChange={setEnabled} />
        </div>
      </div>

      <div className="text-sm text-gray-500 space-y-1">
        <p>
          <strong>ID da Pesquisa:</strong> {research_id || "—"}
        </p>
        <p>
          <strong>ID do Tipo de Coleta:</strong> {survey_type || "—"}
        </p>
      </div>

      <AnimatePresence>
        {enabled && (
          <motion.div
            key="form-content"
            initial={{ opacity: 0, y: 6 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -6 }}
            transition={{ duration: 0.25 }}
            className="space-y-6"
          >
            <BasicInformation
              form={form}
              setForm={setForm}
              showSurveyInformation={showSurveyInformation}
              setShowSurveyInformation={setShowSurveyInformation}
            />

            <div className="h-px bg-gray-200 my-4" />

            <LocationForm
              form={form}
              setForm={setForm}
              showLocationForm={showLocationForm}
              setShowLocationForm={setShowLocationForm}
            />

            <div className="h-px bg-gray-200 my-4" />

            <MicroRegionEditor
              regions={microRegions}
              setRegions={setMicroRegions}
              form={form}
              setForm={setForm}
            />
            <div className="h-px bg-gray-200 my-4" />

            <TimeRanges timeRanges={timeRanges} setTimeRanges={setTimeRanges} />

            <div className="h-px bg-gray-200 my-4" />

            <CollaboratorSelector
              form={form}
              setForm={setForm}
              isEdit={isEdit}
              availableCollaborators={initialData?.available_collaborators || []}
            />

            <div className="h-px bg-gray-200 my-4" />

            <div className="pt-6 flex justify-center gap-4">
              <motion.div whileTap={{ scale: 0.95 }} whileHover={{ scale: 1.02 }}>
                <Button variant="verde" onClick={handleSave} className="transition-all">
                  {isEdit ? "Salvar Alterações" : "Criar Coleta"}
                </Button>
              </motion.div>

              {!isEdit && (
                <motion.div whileTap={{ scale: 0.95 }} whileHover={{ scale: 1.02 }}>
                  <Button
                    variant="vermelho"
                    className="transition-all"
                    onClick={handleCancelCreateSurvey}
                  >
                    Cancelar
                  </Button>
                </motion.div>
              )}
            </div>
          </motion.div>
        )}
      </AnimatePresence>

      {enableFormBuilder && (
        <div>
          <div className="h-px bg-gray-200 my-4" />
          <FormBuilder
            survey_id={form.id}
            survey_type={form.survey_type}
            onChange={(updated) => setFormStructure(updated)}
          />
        </div>
      )}
    </motion.div>
  );
}


============================================================


📄 Arquivo : DynamicCollectionSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/DynamicCollectionSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";
import Switch from "@/components/ui/Switch";

/**
 * DynamicCollectionSection
 * Componente reutilizável para criar ou editar uma coleta dinâmica.
 * Props:
 * - initialData: dados iniciais da coleta (em edição)
 * - onSubmit: função chamada ao salvar
 * - isEdit: booleano, se é modo de edição
 */
export default function DynamicCollectionSection({
  initialData = {},
  onSubmit,
  isEdit = false,
}) {
  const [enabled, setEnabled] = useState(false);
  const [form, setForm] = useState({
    title: "",
    description: "",
    logic_enabled: false,
    conditions: "",
    ...initialData,
  });

  const initialDataRef = useRef(JSON.stringify(initialData));

  useEffect(() => {
    if (!isEdit) return;

    const newInitial = JSON.stringify(initialData);

    // Só atualiza se o conteúdo for diferente
    if (initialDataRef.current !== newInitial) {
      initialDataRef.current = newInitial;
      setForm((prev) => ({ ...prev, ...initialData }));
    }
  }, [initialData, isEdit]);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({
      ...prev,
      [field]: e.target.value,
    }));
  };

  const handleSubmit = () => {
    const payload = {
      ...form,
      type: "dynamic",
    };
    onSubmit?.(payload);
  };

  const handleDiscard = () => {
    setForm({ ...initialData });
  };

  return (
    <div className="border rounded-xl p-6 bg-white shadow max-w-4xl mx-auto w-full space-y-6">
      {/* Header com toggle */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 className="text-lg font-semibold text-gray-800">
          {isEdit ? "Editar Coleta Dinâmica" : "Nova Coleta Dinâmica"}
        </h2>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-600">Ativar coleta</span>
          <Switch checked={enabled} onChange={setEnabled} />
        </div>
      </div>

      {enabled && (
        <>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
            <FormField
              legend="Título da Coleta"
              type="text"
              value={form.title}
              onChange={handleChange("title")}
              placeholder="Ex: Preferências de transporte"
            />

            <FormField
              legend="Descrição"
              type="text"
              value={form.description}
              onChange={handleChange("description")}
              placeholder="Explique o objetivo da coleta dinâmica"
            />
          </div>

          <div className="flex items-center justify-between border-t pt-4">
            <span className="text-sm font-medium text-gray-700">
              Habilitar lógica condicional
            </span>
            <Switch
              checked={form.logic_enabled}
              onChange={(checked) =>
                setForm((prev) => ({ ...prev, logic_enabled: checked }))
              }
            />
          </div>

          {form.logic_enabled && (
            <FormField
              legend="Condições Lógicas"
              type="text"
              value={form.conditions}
              onChange={handleChange("conditions")}
              placeholder="Ex: mostrar campo X se idade > 18"
            />
          )}

          <div className="flex justify-end gap-4 pt-6">
            {isEdit && (
              <Button
                variant="transparent_vermelho"
                onClick={handleDiscard}
                className="active:scale-95"
              >
                Descartar Alterações
              </Button>
            )}
            <Button
              variant="secondary"
              onClick={handleSubmit}
              className="active:scale-95"
            >
              {isEdit ? "Salvar Coleta" : "Criar Coleta"}
            </Button>
          </div>
        </>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : LocationForm.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/LocationForm.jsx
--------------------------------------
📜 Conteúdo:

"use client";

import { useState } from "react";
import dynamic from "next/dynamic";
import { MapPin } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";
import FormField from "@/components/forms/FormField";
import Switch from "@/components/ui/Switch";
import MapPreview from "@/components/map/MapPreviewNoSSR";

const OfflineMapButton = dynamic(
  () => import("@/components/OfflineMapButton"),
  { ssr: false }
);

export default function LocationForm({
  form,
  setForm,
  showLocationForm,
  setShowLocationForm,
}) {
  const [showFormInputLocation, setShowFormInputLocation] = useState(false);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleLocationSelect = (data) => {
    setForm((prev) => ({
      ...prev,
      lat: data.lat,
      long: data.lng,
      location_title: data.location || "",
      weather_celsius: data.weather_celsius ?? null,
      weather_fahrenheit: data.weather_fahrenheit ?? null,
    }));
    setShowFormInputLocation(true);
  };

  return (
    <div className="rounded-lg space-y-4">
      {/* Header com tooltip */}
      <div className="flex items-center justify-between bg-transparent transition-all px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Informações de Localização
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <MapPin
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Use o mapa para capturar a latitude, longitude e o clima da localização.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Defina a posição geográfica exata e visualize o local no mapa.
          </p>
        </div>
        <Switch
          type="arrow"
          checked={showLocationForm}
          onChange={setShowLocationForm}
        />
      </div>

      {showLocationForm && (
        <div className="bg-transparent px-4 py-5 mt-2 space-y-5">
          <div className="grid grid-cols-1 sm:grid-cols-2 gap-4">
            <FormField
              legend="Latitude"
              type="text"
              value={form.lat}
              onChange={handleChange("lat")}
              disabled
            />
            <FormField
              legend="Longitude"
              type="text"
              value={form.long}
              onChange={handleChange("long")}
              disabled
            />
          </div>

          <FormField
            legend="Localização (Título)"
            type="text"
            value={form.location_title}
            onChange={handleChange("location_title")}
            placeholder="Ex: Praça Roosevelt, SP"
          />

          {!!form.lat && !!form.long && (
            <div className="border rounded-md p-4 bg-gray-50 space-y-4">
              <div className="text-sm text-gray-700">
                <strong className="block mb-1">Resumo da Localização:</strong>
                <p>{form.location_title}</p>
                <p>Lat: {Number(form.lat).toFixed(6)}</p>
                <p>Long: {Number(form.long).toFixed(6)}</p>
                {form.weather_celsius && form.weather_fahrenheit && (
                  <p>
                    Clima: {form.weather_celsius}°C /{" "}
                    {Number(form.weather_fahrenheit).toFixed(1)}°F
                  </p>
                )}
              </div>
              <MapPreview
                lat={Number(form.lat)}
                lng={Number(form.long)}
                height="200px"
                width="100%"
              />
            </div>
          )}

          <div className="flex flex-col items-center pt-2 gap-2">
            <OfflineMapButton onLocationSelect={handleLocationSelect} />
            <p className="text-xs text-gray-500 text-center">
              Para obter a localização automaticamente, clique em{" "}
              <strong>“Abrir mapa”</strong>.
            </p>
          </div>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : MicroRegionEditor.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/MicroRegionEditor.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import FormField from "@/components/forms/FormField";
import { Trash2, Plus, MapPin } from "lucide-react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import * as Tooltip from "@radix-ui/react-tooltip";

export default function MicroRegionEditor({
  regions = [],
  setRegions,
  form,
  setForm,
}) {
  const [showMicroRegions, setShowMicroRegions] = useState(false);

  const handleAdd = () => {
    if (!form.new_region?.trim()) return;
    setRegions((prev) => [...prev, form.new_region.trim()]);
    setForm((prev) => ({ ...prev, new_region: "" }));
  };

  const handleDelete = (indexToRemove) => {
    setRegions((prev) => prev.filter((_, i) => i !== indexToRemove));
  };

  const toggleUseMicroRegions = () => {
    setForm((prev) => ({
      ...prev,
      use_micro_regions: !prev.use_micro_regions,
    }));
  };

  return (
    <div className="rounded-lg space-y-4">
      {/* Cabeçalho com tooltip e switch */}
      <div className="flex items-center justify-between px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Micro-regiões
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <MapPin
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Divida a coleta em regiões como “Entrada Leste”, “Praça Central”, etc.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Organize a coleta por áreas específicas da localização observada.
          </p>
        </div>
        <Switch
          checked={showMicroRegions}
          onChange={setShowMicroRegions}
          type="arrow"
        />
      </div>

      <AnimatePresence>
        {showMicroRegions && (
          <motion.div
            key="microregion-toggle"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.25 }}
            className="space-y-5 bg-white border border-gray-100 rounded-lg shadow-sm px-4 py-5"
          >
            {/* Ativar toggle */}
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold text-gray-800">
                  Ativar micro-regiões
                </h3>
                <p className="text-xs text-gray-600">
                  Permite organizar a coleta por pontos distintos do território.
                </p>
              </div>
              <Switch
                checked={!!form.use_micro_regions}
                onChange={toggleUseMicroRegions}
              />
            </div>

            {/* Campo e botão */}
            {form.use_micro_regions && (
              <>
                <div className="flex justify-auto flex-col sm:flex-row gap-8 sm:items-end">
                  <FormField
                    legend="Nome da Região"
                    type="text"
                    value={form.new_region || ""}
                    onChange={(e) =>
                      setForm((prev) => ({
                        ...prev,
                        new_region: e.target.value,
                      }))
                    }
                    placeholder="Ex: Entrada Sul, Ponto 3..."
                  />
                  <motion.button
                    onClick={handleAdd}
                    disabled={!form.new_region?.trim()}
                    whileTap={{ scale: 0.95 }}
                    className="flex flex-row gap-4 justify-center items-center h-10 px-4 rounded-md bg-green-600 text-white text-sm font-medium shadow hover:bg-green-700 transition disabled:opacity-60 disabled:cursor-not-allowed"
                  >
                    <Plus size={16} className="inline" />
                    Adicionar
                  </motion.button>
                </div>

                {/* Lista */}
                {regions.length > 0 ? (
                  <ul className="flex flex-wrap gap-2">
                    {regions.map((region, idx) => (
                      <motion.li
                        key={region + idx}
                        initial={{ opacity: 0, scale: 0.95 }}
                        animate={{ opacity: 1, scale: 1 }}
                        exit={{ opacity: 0, scale: 0.95 }}
                        transition={{ duration: 0.2 }}
                        className="flex items-center gap-2 px-3 py-1 bg-gray-100 border border-gray-300 rounded-full text-sm text-gray-800 shadow-sm"
                      >
                        {region}
                        <button
                          onClick={() => handleDelete(idx)}
                          className="text-red-500 hover:text-red-600 transition"
                          aria-label={`Remover ${region}`}
                        >
                          <Trash2 size={14} />
                        </button>
                      </motion.li>
                    ))}
                  </ul>
                ) : (
                  <p className="text-sm text-gray-500 text-center">
                    Nenhuma micro-região criada ainda.
                  </p>
                )}
              </>
            )}
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : StaticCollectionSection.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/StaticCollectionSection.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useRef } from "react";
import Switch from "@/components/ui/Switch";
import FormField from "@/components/forms/FormField";
import Button from "@/components/ui/Button";

/**
 * StaticCollectionSection
 * Usado para criação ou edição de coleta via arquivos estáticos (PDFs, Imagens etc).
 *
 * Props:
 *  - initialData: dados iniciais da coleta (se for edição)
 *  - onSubmit: função chamada ao enviar
 *  - isEdit: booleano para distinguir entre criação e edição
 */
export default function StaticCollectionSection({
  initialData = {},
  onSubmit,
  isEdit = false,
}) {
  const [enabled, setEnabled] = useState(false);
  const [form, setForm] = useState({
    title: "",
    description: "",
    fileUrl: "",
    ...initialData,
  });

  const initialDataRef = useRef(JSON.stringify(initialData));

  useEffect(() => {
    if (!isEdit) return;

    const newInitial = JSON.stringify(initialData);

    if (initialDataRef.current !== newInitial) {
      initialDataRef.current = newInitial;
      setForm((prev) => ({ ...prev, ...initialData }));
    }
  }, [initialData, isEdit]);

  const handleChange = (field) => (e) => {
    setForm((prev) => ({ ...prev, [field]: e.target.value }));
  };

  const handleSubmit = () => {
    const payload = {
      title: form.title,
      description: form.description,
      fileUrl: form.fileUrl,
      type: "static",
    };
    onSubmit?.(payload);
  };

  return (
    <div className="border rounded-xl p-6 bg-white shadow max-w-4xl mx-auto w-full space-y-6">
      {/* Header com toggle */}
      <div className="flex flex-col sm:flex-row sm:items-center sm:justify-between gap-2">
        <h2 className="text-lg font-semibold text-gray-800">
          {isEdit ? "Editar Coleta Estática" : "Nova Coleta Estática"}
        </h2>
        <div className="flex items-center gap-2">
          <span className="text-sm text-gray-600">Ativar coleta</span>
          <Switch checked={enabled} onChange={setEnabled} />
        </div>
      </div>

      {enabled && (
        <div className="grid grid-cols-1 md:grid-cols-2 gap-4">
          <FormField
            legend="Título do Arquivo"
            type="text"
            value={form.title}
            onChange={handleChange("title")}
          />

          <FormField
            legend="Descrição"
            type="text"
            value={form.description}
            onChange={handleChange("description")}
          />

          <FormField
            className="md:col-span-2"
            legend="Link para Download ou Visualização"
            type="text"
            value={form.fileUrl}
            onChange={handleChange("fileUrl")}
            placeholder="https://..."
          />
        </div>
      )}

      {enabled && (
        <div className="pt-4 flex justify-end">
          <Button variant="secondary" onClick={handleSubmit}>
            {isEdit ? "Salvar Alterações" : "Adicionar Coleta Estática"}
          </Button>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : TimeRanges.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/TimeRanges.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import Switch from "@/components/ui/Switch";
import { Clock, Plus, Trash2 } from "lucide-react";
import * as Tooltip from "@radix-ui/react-tooltip";
import TimeSelectorModal from "@/components/surveys/TimeSelectorModal";

export default function TimeRanges({ timeRanges = [], setTimeRanges }) {
  const [showTimeRanges, setShowTimeRanges] = useState(false);
  const [showModal, setShowModal] = useState(false);

  const handleAddTime = (selectedTime) => {
    if (!timeRanges.includes(selectedTime)) {
      const sorted = [...timeRanges, selectedTime].sort();
      setTimeRanges(sorted);
    }
    setShowModal(false);
  };

  const handleDelete = (time) => {
    setTimeRanges(timeRanges.filter((t) => t !== time));
  };

  return (
    <div className="rounded-lg space-y-4">
      {/* Cabeçalho com tooltip e switch */}
      <div className="flex items-center justify-between px-4 py-3">
        <div className="space-y-1">
          <div className="flex items-center gap-2">
            <h2 className="text-base sm:text-lg font-semibold text-gray-800">
              Horas de Coleta
            </h2>
            <Tooltip.Provider delayDuration={100}>
              <Tooltip.Root>
                <Tooltip.Trigger asChild>
                  <button>
                    <Clock
                      size={16}
                      className="text-gray-400 hover:text-gray-600 transition"
                    />
                  </button>
                </Tooltip.Trigger>
                <Tooltip.Portal>
                  <Tooltip.Content
                    side="top"
                    className="z-50 px-3 py-2 text-sm bg-gray-800 text-white rounded-md shadow-lg max-w-xs"
                    sideOffset={6}
                  >
                    Defina os horários exatos de atuação dos pesquisadores em campo.
                    <Tooltip.Arrow className="fill-gray-800" />
                  </Tooltip.Content>
                </Tooltip.Portal>
              </Tooltip.Root>
            </Tooltip.Provider>
          </div>
          <p className="text-sm text-gray-600 leading-snug">
            Registre os horários em que a coleta será realizada.
          </p>
        </div>
        <Switch
          checked={showTimeRanges}
          onChange={setShowTimeRanges}
          type="arrow"
        />
      </div>

      <AnimatePresence>
        {showTimeRanges && (
          <motion.div
            key="timerange-toggle"
            initial={{ opacity: 0, y: 4 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -4 }}
            transition={{ duration: 0.25 }}
            className="space-y-5 bg-white border border-gray-100 rounded-lg shadow-sm px-4 py-5"
          >
            <div className="flex items-center justify-between">
              <div>
                <h3 className="text-sm font-semibold text-gray-800">
                  Registrar horários
                </h3>
                <p className="text-xs text-gray-600">
                  Exemplos: 09h00, 09h30, 10h00...
                </p>
              </div>
              <button
                onClick={() => setShowModal(true)}
                className="inline-flex items-center gap-2 px-3 py-2 text-sm bg-green-600 text-white rounded-md hover:bg-green-700 active:scale-95 transition shadow"
              >
                <Plus size={16} />
                Adicionar hora
              </button>
            </div>

            {/* Lista */}
            {timeRanges.length > 0 ? (
              <ul className="flex flex-wrap gap-2">
                {timeRanges.map((time, idx) => (
                  <motion.li
                    key={time + idx}
                    initial={{ opacity: 0, scale: 0.95 }}
                    animate={{ opacity: 1, scale: 1 }}
                    exit={{ opacity: 0, scale: 0.95 }}
                    transition={{ duration: 0.2 }}
                    className="flex items-center gap-2 px-3 py-1 bg-gray-100 border border-gray-300 rounded-full text-sm text-gray-800 shadow-sm"
                  >
                    {time}
                    <button
                      onClick={() => handleDelete(time)}
                      className="text-red-500 hover:text-red-600 transition"
                    >
                      <Trash2 size={14} />
                    </button>
                  </motion.li>
                ))}
              </ul>
            ) : (
              <p className="text-sm text-gray-500 text-center">
                Nenhum horário registrado.
              </p>
            )}

            <TimeSelectorModal
              isOpen={showModal}
              onClose={() => setShowModal(false)}
              onSelectTime={handleAddTime}
            />
          </motion.div>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : TimeSelectorModal.jsx
📂 Pasta   : components/surveys
🧭 Caminho : components/surveys/TimeSelectorModal.jsx
--------------------------------------
📜 Conteúdo:

import { Dialog } from "@headlessui/react";
import { useState } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { X } from "lucide-react";

export default function TimeSelectorModal({ isOpen, onClose, onSelectTime }) {
  const [hour, setHour] = useState("09");
  const [minute, setMinute] = useState("00");

  const handleConfirm = () => {
    const formatted = `${hour}h${minute}`;
    onSelectTime(formatted);
  };

  const hours = Array.from({ length: 17 }, (_, i) =>
    String(i + 6).padStart(2, "0")
  );
  const minutes = ["00", "15", "30", "45"];

  return (
    <AnimatePresence>
      {isOpen && (
        <Dialog
          as="div"
          open={isOpen}
          onClose={onClose}
          className="relative z-50"
        >
          {/* Fundo escurecido */}
          <motion.div
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
            className="fixed inset-0 bg-black/40 backdrop-blur-sm"
            aria-hidden="true"
          />

          {/* Painel modal */}
          <div className="fixed inset-0 flex items-center justify-center p-4">
            <motion.div
              initial={{ opacity: 0, y: 24 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 24 }}
              transition={{ duration: 0.25 }}
              className="relative w-full max-w-sm bg-white rounded-2xl shadow-xl p-6 space-y-6"
            >
              <Dialog.Panel className="w-full space-y-6">
                {/* Botão de Fechar */}
                <button
                  onClick={onClose}
                  className="absolute top-3 right-3 bg-red-600 hover:bg-red-700 p-1.5 rounded-full shadow text-white transition"
                  aria-label="Fechar"
                >
                  <X size={16} />
                </button>

                {/* Título */}
                <Dialog.Title className="text-lg font-semibold text-gray-800 text-center">
                  Selecione um horário
                </Dialog.Title>

                {/* Selects */}
                <div className="flex justify-center gap-3 items-center">
                  <select
                    value={hour}
                    onChange={(e) => setHour(e.target.value)}
                    className="w-24 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                  >
                    {hours.map((h) => (
                      <option key={h} value={h}>
                        {h}
                      </option>
                    ))}
                  </select>
                  <span className="text-lg font-medium text-gray-600">:</span>
                  <select
                    value={minute}
                    onChange={(e) => setMinute(e.target.value)}
                    className="w-24 rounded-md border border-gray-300 px-3 py-2 text-center shadow-sm text-sm focus:ring-2 focus:ring-green-500 focus:outline-none transition"
                  >
                    {minutes.map((m) => (
                      <option key={m} value={m}>
                        {m}
                      </option>
                    ))}
                  </select>
                </div>

                {/* Botão de Adicionar */}
                <div className="flex justify-center pt-2">
                  <motion.button
                    whileTap={{ scale: 0.95 }}
                    onClick={handleConfirm}
                    className="px-5 py-2 text-sm rounded-md bg-green-600 text-white hover:bg-green-700 active:scale-95 transition"
                  >
                    Adicionar
                  </motion.button>
                </div>
              </Dialog.Panel>
            </motion.div>
          </div>
        </Dialog>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : Button.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Button.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import clsx from "clsx";
import { VARIANTS } from "@/config/colors";

export default function Button({
  children,
  className = "",
  variant = "primary",
  ...props
}) {
  const baseStyle = "py-2 px-2 rounded font-medium transition";


  return (
    <button
      className={clsx(baseStyle, VARIANTS[variant], className)}
      {...props}
    >
      {children}
    </button>
  );
}


============================================================


📄 Arquivo : FiltersComponent.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/FiltersComponent.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import clsx from "clsx";
import Button from "@/components/ui/Button";
import Switch from "@/components/ui/Switch";

export default function FiltersComponent({
  showFilters,
  setShowFilters,
  filters,
  onChange,
  onClear,
  variants = {},
  mobilePosition = "right", // default: "right"
}) {
  const [mobileOpen, setMobileOpen] = useState(false);

  const renderFilterContent = () => (
    <section className="space-y-5">
      {filters.map((filter) => {
        if (filter.type === "text") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-1">
                <span className="material-symbols-outlined text-base">{filter.icon}</span>
                {filter.label}
              </label>
              <input
                type="text"
                value={filter.value}
                onChange={(e) => onChange(filter.key, e.target.value)}
                placeholder={filter.placeholder || ""}
                className="w-full border border-gray-300 rounded-lg px-3 py-2 text-sm focus:outline-none focus:ring-2 focus:ring-indigo-400"
              />
            </div>
          );
        }

        if (filter.type === "button-group") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-1">
                <span className="material-symbols-outlined text-base">{filter.icon}</span>
                {filter.label}
              </label>
              <div className="flex gap-2 flex-wrap">
                {filter.options.map((opt) => (
                  <button
                    key={opt.value}
                    onClick={() => onChange(filter.key, opt.value)}
                    className={clsx(
                      "px-4 py-1 rounded-full text-sm border",
                      filter.value === opt.value
                        ? variants.secondary || "bg-gray-400 text-white"
                        : variants.light || "bg-gray-100"
                    )}
                  >
                    {opt.label}
                  </button>
                ))}
              </div>
            </div>
          );
        }

        if (filter.type === "switch-group") {
          return (
            <div key={filter.key}>
              <label className="text-sm font-semibold text-gray-700 flex items-center gap-1 mb-2">
                <span className="material-symbols-outlined text-base">visibility</span>
                {filter.label}
              </label>
              <div className="space-y-2">
                {filter.options.map((opt) => (
                  <div
                    key={opt.value}
                    className="flex items-center justify-between border border-gray-200 p-3 rounded-lg"
                  >
                    <span className="text-sm text-gray-700">{opt.label}</span>
                    <Switch
                      checked={opt.checked}
                      onChange={(checked) => {
                        onChange(filter.key, { [opt.value]: checked });
                      }}
                    />
                  </div>
                ))}
              </div>
            </div>
          );
        }

        return null;
      })}

      {filters.some((f) => f.value !== "" && f.value !== f.defaultValue) && (
        <div className="pt-1">
          <Button
            onClick={onClear}
            variant="transparent_cinza"
            className="text-sm"
          >
            Limpar Filtros
          </Button>
        </div>
      )}
    </section>
  );

  return (
    <div>
      {/* DESKTOP: botão de expandir/recolher */}
      <div className="hidden lg:flex justify-start mb-2">
        <Button
          variant="light"
          onClick={() => setShowFilters((prev) => !prev)}
          className="text-sm flex items-center gap-1"
        >
          <span className="material-symbols-outlined text-base">
            {showFilters ? "expand_less" : "tune"}
          </span>
          {showFilters ? "Esconder filtros" : "Mostrar filtros"}
        </Button>
      </div>

      {/* DESKTOP: filtros inline */}
      <div
        className={clsx(
          "transition-all overflow-hidden hidden lg:block",
          showFilters ? "max-h-[1000px] opacity-100" : "max-h-0 opacity-0"
        )}
      >
        <section className="mb-6 border border-gray-200 rounded-xl shadow-sm p-4 bg-white">
          {renderFilterContent()}
        </section>
      </div>

      {/* MOBILE: botão flutuante */}
      {!mobileOpen && (
        <div className="fixed bottom-4 right-4 z-50 lg:hidden">
          <button
            onClick={() => setMobileOpen(true)}
            className="w-14 h-14 rounded-full bg-gray-400 text-white flex items-center justify-center shadow-lg hover:scale-105 transition"
          >
            <span className="material-symbols-outlined text-3xl">tune</span>
          </button>
        </div>
      )}

      {/* MOBILE: painel lateral */}
      {mobileOpen && (
        <div
          className={clsx(
            "fixed top-0 bottom-0 z-50 w-72 max-w-full bg-white shadow-2xl border border-gray-200 p-4 transition-transform duration-300 lg:hidden",
            mobilePosition === "right"
              ? "right-0 animate-slide-in-right"
              : "left-0 animate-slide-in-left"
          )}
        >
          <div className="flex justify-between items-center mb-4">
            <h2 className="text-lg font-bold text-gray-800">Filtros</h2>
            <button
              onClick={() => setMobileOpen(false)}
              className="text-gray-600 hover:text-gray-900 transition"
            >
              <span className="material-symbols-outlined text-2xl">close</span>
            </button>
          </div>

          <div className="overflow-y-auto h-full pr-1">
            {renderFilterContent()}
          </div>
        </div>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : FullscreenButton.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/FullscreenButton.jsx
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from "react";
import { motion, AnimatePresence } from "framer-motion";

const isDesktop = () => {
  if (typeof window === "undefined") return false;
  return window.innerWidth >= 1024;
};

export default function FullscreenButton({ expanded, hovered, setHovered }) {
  const [visible, setVisible] = useState(false);

  useEffect(() => {
    if (isDesktop()) setVisible(true);

    const handleResize = () => {
      setVisible(window.innerWidth >= 1024);
    };

    window.addEventListener("resize", handleResize);
    return () => window.removeEventListener("resize", handleResize);
  }, []);

  const enterFullscreen = async () => {
    try {
      await document.documentElement.requestFullscreen();
      setVisible(false);
    } catch (err) {
      console.error("Erro ao tentar entrar em fullscreen:", err);
    }
  };

  if (!visible) return null;

  return (
    <div
      className="relative"
      onMouseEnter={() => {
        if (!expanded) setHovered("Fullscreen");
      }}
      onMouseLeave={() => {
        if (!expanded) setHovered(null);
      }}
    >
      <button
        onClick={enterFullscreen}
        className={`group flex items-center gap-2 px-4 py-2 rounded-md transition-all w-full hover:bg-gray-100 ${
          !expanded ? "justify-center" : ""
        } text-black`}
      >
        <span className="material-symbols-outlined text-xl">fullscreen</span>
        {expanded && (
          <span className="text-sm font-medium whitespace-nowrap">
            Tela cheia
          </span>
        )}
      </button>

      {!expanded && hovered === "Fullscreen" && (
        <AnimatePresence>
          <motion.div
            initial={{ opacity: 0, x: 10 }}
            animate={{ opacity: 1, x: 0 }}
            exit={{ opacity: 0, x: 10 }}
            transition={{ duration: 0.2 }}
            className="absolute left-full ml-2 top-1/2 transform -translate-y-1/2 px-2 py-1 bg-gray-800 text-white text-xs rounded shadow-lg whitespace-nowrap z-10"
          >
            Tela cheia
          </motion.div>
        </AnimatePresence>
      )}
    </div>
  );
}


============================================================


📄 Arquivo : Loading.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Loading.jsx
--------------------------------------
📜 Conteúdo:

"use client";

import { motion } from "framer-motion";

export default function Loading({ message = "Carregando..." }) {
  return (
    <motion.div
      className="fixed inset-0 z-50 flex flex-col items-center justify-center bg-white/80"
      initial={{ opacity: 0 }}
      animate={{ opacity: 1 }}
      exit={{ opacity: 0 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
    >
      {/* Mensagem acima do spinner */}
      {message && (
        <motion.p
          className="mb-4 text-gray-700 text-sm font-medium"
          initial={{ opacity: 0, y: -6 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.2, ease: "easeOut" }}
        >
          {message}
        </motion.p>
      )}

      <motion.div
        className="w-12 h-12 border-4 border-blue-500 border-t-transparent rounded-full animate-spin"
        initial={{ scale: 0.8 }}
        animate={{ scale: 1 }}
        transition={{ duration: 0.3, ease: "easeOut" }}
      />
    </motion.div>
  );
}


============================================================


📄 Arquivo : Message.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Message.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";

const variantStyles = {
  verde: "text-black bg-[rgb(114,227,173)] border-[rgb(80,180,130)] hover:brightness-95",
  vermelho: "text-white bg-red-600 border-transparent hover:bg-red-700",
  vermelho_claro: "text-red-700 bg-red-100 border-red-400 hover:bg-red-200",
  azul_claro: "text-black bg-blue-200 border-blue-600 hover:bg-blue-300",
  cinza: "text-black bg-gray-300 border-gray-800 hover:bg-gray-400",
  azul_escuro: "text-white bg-blue-600 border-transparent hover:bg-blue-700"
};

export default function Message({ message, variant = "info", show }) {
  return (
    <AnimatePresence>
      {show && (
        <motion.div
          initial={{ y: -60, opacity: 0 }}
          animate={{ y: 0, opacity: 1 }}
          exit={{ y: -60, opacity: 0 }}
          transition={{ duration: 0.4, ease: "easeOut" }}
          className={`
            fixed top-4 inset-x-0 z-50
            w-fit max-w-[90%] mx-auto
            px-4 py-3 rounded-xl shadow-lg text-center
            text-sm font-medium
            ${variantStyles[variant] || variantStyles.info}
          `}
        >
          {message}
        </motion.div>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : ModalRegisterUser.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/ModalRegisterUser.jsx
--------------------------------------
📜 Conteúdo:

// src/components/ui/ModalRegisterUser.jsx
import { useState, useEffect } from "react";
import { AnimatePresence, motion } from "framer-motion";
import Button from "@/components/ui/Button";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";
import { addCachedItem, markItemForCreate } from "@/services/cache";

export default function ModalRegisterUser({
  isOpen,
  onClose,
  onUserCreated,
  showMessage,
}) {
  const [form, setForm] = useState({
    name: "",
    email: "",
    confirmation_email: "",
    role: "",
    status: "",
  });
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    if (isOpen) {
      setForm({
        name: "",
        email: "",
        confirmation_email: "",
        role: "",
        status: "",
      });
    }
  }, [isOpen]);

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    if (form.email !== form.confirmation_email) {
      showMessage("E-mails não coincidem", "vermelho_claro", 5000);
      return;
    }
    setIsProcessing(true);
    try {
      const res = await fetch("/api/users/register", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });
      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Erro ao cadastrar");
      showMessage("Usuário cadastrado com sucesso!", "verde");

      await addCachedItem("users", { ...data.user, _syncStatus: "synced" });
      if (onUserCreated) {
        onUserCreated(data.user);
      }
      onClose();
    } catch (err) {
      try {
        const pendingUser = await markItemForCreate("users", form);
        if (onUserCreated) {
          onUserCreated(pendingUser);
        }
        showMessage(
          "Servidor indisponível. Usuário salvo localmente e ficará pendente de sincronização.",
          "vermelho",
          5000
        );
      } catch (err) {
        showMessage(err.message, "vermelho_claro", 5000);
        onClose();
      }
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && (
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className="absolute inset-0 bg-black bg-opacity-40"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />
          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className="relative bg-white rounded-lg shadow-lg w-full max-w-md mx-2"
          >
            <div className="bg-gray-600 rounded-t-lg p-4">
              <h2 className="text-xl font-semibold text-white">
                Cadastrar Novo Usuário
              </h2>
              <button
                onClick={onClose}
                className="absolute top-3 right-3 text-white hover:text-gray-200"
              >
                <span className="material-symbols-outlined text-xl">close</span>
              </button>
            </div>
            <div className="p-6">
              <form onSubmit={handleSubmit} className="space-y-6">
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Nome
                  </label>
                  <input
                    type="text"
                    name="name"
                    value={form.name}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    E-mail
                  </label>
                  <input
                    type="email"
                    name="email"
                    value={form.email}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Confirmar E-mail
                  </label>
                  <input
                    type="email"
                    name="confirmation_email"
                    value={form.confirmation_email}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  />
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Papel
                  </label>
                  <select
                    name="role"
                    value={form.role}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    <option value="">Selecione um papel</option>
                    {USER_ROLES.map((role) => (
                      <option key={role} value={role}>
                        {role}
                      </option>
                    ))}
                  </select>
                </div>
                <div>
                  <label className="block text-sm font-medium text-gray-700">
                    Status
                  </label>
                  <select
                    name="status"
                    value={form.status}
                    onChange={handleChange}
                    className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                    required
                  >
                    <option value="">Selecione um status</option>
                    {USER_STATUS.map((status) => (
                      <option key={status} value={status}>
                        {status}
                      </option>
                    ))}
                  </select>
                </div>
                <div className="flex justify-center">
                  <Button
                    type="submit"
                    variant="dark"
                    disabled={isProcessing}
                    className="w-full max-w-xs text-md"
                  >
                    {isProcessing ? (
                      "Cadastrando..."
                    ) : (
                      <span className="flex items-center justify-center">
                        <span className="material-symbols-outlined mr-2">
                          person_add
                        </span>
                        Cadastrar
                      </span>
                    )}
                  </Button>
                </div>
              </form>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}


============================================================


📄 Arquivo : ModalUser.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/ModalUser.jsx
--------------------------------------
📜 Conteúdo:

// src/components/ui/ModalUser.jsx
import { useState, useEffect } from "react";
import { AnimatePresence, motion } from "framer-motion";
import {
  updateCachedItemById,
  deleteCachedItemById,
  markItemForUpdate,
  markItemForDelete,
} from "@/services/cache";
import Button from "@/components/ui/Button";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";
import Link from "next/link";

export default function ModalUser({
  isOpen,
  user,
  onClose,
  onUserUpdated,
  onUserDeleted,
  showMessage,
}) {
  const [form, setForm] = useState({
    id: "",
    name: "",
    email: "",
    role: "",
    status: "",
  });
  const [isProcessing, setIsProcessing] = useState(false);

  useEffect(() => {
    if (user) {
      setForm({
        id: user.id || "",
        name: user.name || "",
        email: user.email || "",
        role: user.role || "",
        status: user.status || "",
      });
    }
  }, [user]);

  if (!isOpen || !user) {
    return null;
  }

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const cleanStatus = (status) => status.replace(/^["']|["']$/g, "");

  const handleUpdate = async () => {
    setIsProcessing(true);
    const updateData = { ...form, status: cleanStatus(form.status) };
    try {
      const res = await fetch("/api/users/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(updateData),
      });
      const data = await res.json();
      if (!res.ok) {
        // Se a API falhar, marca para sincronização
        await markItemForUpdate("users", form.id, updateData);
        showMessage(
          "Falha na atualização. Alteração pendente de sincronização.",
          "vermelho",
          5000
        );
      } else {
        // Em caso de sucesso, force a atualização removendo o status pendente
        const updatedDataWithSync = { ...updateData, _syncStatus: "synced" };
        await updateCachedItemById("users", form.id, updatedDataWithSync);
        onUserUpdated({
          ...form,
          _syncStatus: "synced",
          updated_at: data.updated_at || new Date().toISOString(),
        });
        showMessage("Usuário atualizado com sucesso!", "azul_claro");
      }
      onClose();
    } catch (err) {
      await markItemForUpdate("users", form.id, updateData);
      showMessage(
        "Erro ao atualizar. Alteração ficará pendente de sincronização.",
        "vermelho",
        5000
      );
    } finally {
      setIsProcessing(false);
    }
  };
  

  const handleDelete = async () => {
    setIsProcessing(true);
    try {
      const res = await fetch("/api/users/delete", {
        method: "DELETE",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ id: user.id }),
      });
      const data = await res.json();
      if (!res.ok) {
        // Se a exclusão falhar, marca para sincronização
        await markItemForDelete("users", user.id);
        showMessage(
          "Falha ao deletar. Exclusão pendente de sincronização.",
          "vermelho",
          5000
        );
      } else {
        await deleteCachedItemById("users", user.id);
        onUserDeleted(user.id);
        showMessage("Usuário deletado com sucesso!", "verde");
      }
      onClose();
    } catch (err) {
      await markItemForDelete("users", user.id);
      showMessage(
        "Erro ao deletar. Exclusão ficará pendente de sincronização.",
        "vermelho",
        5000
      );
    } finally {
      setIsProcessing(false);
    }
  };

  return (
    <AnimatePresence>
      {isOpen && user && (
        <motion.div
          className="fixed inset-0 z-50 flex items-center justify-center"
          initial={{ opacity: 0 }}
          animate={{ opacity: 1 }}
          exit={{ opacity: 0 }}
        >
          <motion.div
            className="absolute inset-0 bg-black bg-opacity-40"
            initial={{ opacity: 0 }}
            animate={{ opacity: 1 }}
            exit={{ opacity: 0 }}
          />

          <motion.div
            initial={{ opacity: 0, scale: 0.95 }}
            animate={{ opacity: 1, scale: 1 }}
            exit={{ opacity: 0, scale: 0.95 }}
            transition={{ duration: 0.2 }}
            className="relative bg-white rounded-lg shadow-lg w-full max-w-md mx-2"
          >
            <div className="bg-gray-600 rounded-t-lg p-4">
              <h2 className="text-xl font-semibold text-white">
                Detalhes do Usuário
              </h2>
              <button
                className="absolute top-3 right-3 text-white hover:text-gray-200"
                onClick={onClose}
              >
                <span className="material-symbols-outlined text-xl">
                  close
                </span>
              </button>
            </div>
            <div className="p-6 space-y-4">
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Nome
                </label>
                <input
                  type="text"
                  name="name"
                  value={form.name}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  E-mail
                </label>
                <input
                  type="email"
                  name="email"
                  value={form.email}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                />
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Papel
                </label>
                <select
                  name="role"
                  value={form.role}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="">Selecione um papel</option>
                  {USER_ROLES.map((role) => (
                    <option key={role} value={role}>
                      {role}
                    </option>
                  ))}
                </select>
              </div>
              <div>
                <label className="block text-sm font-medium text-gray-700">
                  Status
                </label>
                <select
                  name="status"
                  value={form.status}
                  onChange={handleChange}
                  className="mt-1 border border-gray-300 rounded w-full p-2 focus:ring-blue-500 focus:border-blue-500"
                >
                  <option value="">Selecione um status</option>
                  {USER_STATUS.map((status) => (
                    <option key={status} value={status}>
                      {status}
                    </option>
                  ))}
                </select>
              </div>
              <div className="flex flex-row justify-center items-center">
                <Link href={`/users/${form.id}`} passHref>
                  <Button variant="dark" className="w-full">
                    Ver Perfil
                  </Button>
                </Link>
              </div>
            </div>

            <div className="flex justify-between items-center space-x-2 p-4 border-t">
              <Button
                onClick={handleDelete}
                variant="transparent_vermelho"
                disabled={isProcessing}
              >
                {isProcessing ? (
                  "Excluindo..."
                ) : (
                  <div className="flex items-center space-x-2">
                    <span>Excluir</span>
                    <span className="material-symbols-outlined text-base">
                      delete
                    </span>
                  </div>
                )}
              </Button>
              <Button
                onClick={handleUpdate}
                variant="transparent_verde"
                disabled={isProcessing}
              >
                {isProcessing ? (
                  "Salvando..."
                ) : (
                  <div className="flex items-center space-x-2">
                    <span>Salvar</span>
                    <span className="material-symbols-outlined text-base">
                      save
                    </span>
                  </div>
                )}
              </Button>
            </div>
          </motion.div>
        </motion.div>
      )}
    </AnimatePresence>
  );
}






============================================================


📄 Arquivo : DropdownSelect.jsx
📂 Pasta   : components/ui/Multiselect
🧭 Caminho : components/ui/Multiselect/DropdownSelect.jsx
--------------------------------------
📜 Conteúdo:

import { useState, useRef, useEffect } from "react";
import { motion, AnimatePresence } from "framer-motion";
import { ChevronDown, Check } from "lucide-react";

export default function DropdownSelect({
  options = [],
  selected = null,
  onChange,
  placeholder = "Selecionar...",
  label,
}) {
  const [isOpen, setIsOpen] = useState(false);
  const dropdownRef = useRef(null);

  const handleToggle = () => setIsOpen(!isOpen);

  const handleSelect = (value) => {
    onChange(value);
    setIsOpen(false);
  };

  useEffect(() => {
    const handleClickOutside = (event) => {
      if (dropdownRef.current && !dropdownRef.current.contains(event.target)) {
        setIsOpen(false);
      }
    };
    document.addEventListener("mousedown", handleClickOutside);
    return () => document.removeEventListener("mousedown", handleClickOutside);
  }, []);

  const selectedLabel = options.find((opt) => opt.value === selected)?.label;

  return (
    <div className="relative w-full max-w-md" ref={dropdownRef}>
      {label && (
        <label className="block mb-1 text-sm font-medium text-zinc-700 dark:text-zinc-300">
          {label}
        </label>
      )}
      <button
        type="button"
        onClick={handleToggle}
        className="w-full bg-white dark:bg-zinc-900 border border-zinc-300 dark:border-zinc-700 rounded-lg px-4 py-2 flex justify-between items-center text-sm text-zinc-700 dark:text-zinc-200 shadow-sm hover:border-zinc-400"
      >
        <span>
          {selectedLabel || placeholder}
        </span>
        <ChevronDown className="w-4 h-4 ml-2" />
      </button>

      <AnimatePresence>
        {isOpen && (
          <motion.ul
            initial={{ opacity: 0, y: -5 }}
            animate={{ opacity: 1, y: 0 }}
            exit={{ opacity: 0, y: -5 }}
            transition={{ duration: 0.2 }}
            className="absolute z-10 mt-2 w-full bg-white dark:bg-zinc-900 border border-zinc-200 dark:border-zinc-700 rounded-lg shadow-lg max-h-60 overflow-y-auto text-sm"
          >
            {options.map((option) => (
              <li
                key={option.value}
                className="px-4 py-2 hover:bg-zinc-100 dark:hover:bg-zinc-800 cursor-pointer flex items-center justify-between"
                onClick={() => handleSelect(option.value)}
              >
                <span className="text-zinc-700 dark:text-zinc-200">{option.label}</span>
                {selected === option.value && (
                  <Check className="w-4 h-4 text-green-500" />
                )}
              </li>
            ))}
          </motion.ul>
        )}
      </AnimatePresence>
    </div>
  );
}


============================================================


📄 Arquivo : Multiselect.jsx
📂 Pasta   : components/ui/Multiselect
🧭 Caminho : components/ui/Multiselect/Multiselect.jsx
--------------------------------------
📜 Conteúdo:

import React from "react";
import Select from "react-select";

export default function MultiSelect({
  options = [],
  value = [],
  onChange,
  placeholder = "Selecione...",
  isDisabled = false,
  isMulti = true,
  closeMenuOnSelect = false,
}) {
  const customStyles = {
    control: (base, state) => ({
      ...base,
      backgroundColor: isDisabled ? "#f3f4f6" : "#fff",
      borderColor: state.isFocused ? "#22c55e" : "#d1d5db",
      boxShadow: state.isFocused ? "0 0 0 2px rgba(34, 197, 94, 0.3)" : "none",
      borderWidth: "1px",
      borderRadius: "0.5rem",
      padding: "2px 4px",
      transition: "all 0.2s ease",
      cursor: isDisabled ? "not-allowed" : "default",
      minHeight: "42px",
    }),
    option: (base, { isSelected, isFocused }) => ({
      ...base,
      backgroundColor: isSelected
        ? "#22c55e"
        : isFocused
        ? "#e5f9ed"
        : "#fff",
      color: isSelected ? "white" : "#111827",
      padding: "10px 12px",
      fontSize: "0.875rem",
      zIndex: 9999,
    }),
    multiValue: (base) => ({
      ...base,
      backgroundColor: "#d1fae5",
      borderRadius: "6px",
      padding: "2px 4px",
    }),
    multiValueLabel: (base) => ({
      ...base,
      color: "#065f46",
      fontWeight: 500,
    }),
    multiValueRemove: (base) => ({
      ...base,
      color: "#047857",
      ":hover": {
        backgroundColor: "#a7f3d0",
        color: "#064e3b",
      },
    }),
    menu: (base) => ({
      ...base,
      zIndex: 9999,
    }),
    menuPortal: (base) => ({
      ...base,
      zIndex: 9999,
    }),
  };

  return (
    <Select
      isMulti={isMulti}
      isDisabled={isDisabled}
      options={options}
      value={value}
      onChange={onChange}
      styles={customStyles}
      placeholder={placeholder}
      className="text-sm"
      closeMenuOnSelect={closeMenuOnSelect}
      menuPortalTarget={typeof window !== "undefined" ? document.body : null}
    />
  );
}


============================================================


📄 Arquivo : ResearchCard.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCard.jsx
--------------------------------------
📜 Conteúdo:

import { useRouter } from "next/router";
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";
import { motion } from "framer-motion";

export default function ResearchCard({ research }) {
  const router = useRouter();
  const imageIndex = Math.floor(Math.random() * 5); // 0 a 4
  const imageUrl = `/img/cards/img-${imageIndex}.jpg`;

  return (
    <motion.div
      whileHover={{ scale: 1.03 }}
      transition={{ duration: 0.2 }}
      className="rounded-2xl shadow-md bg-white overflow-hidden flex flex-col justify-between border hover:shadow-xl"
    >
      {/* Header com imagem de fundo */}
      <div className="relative h-14 bg-cover bg-center" style={{ backgroundImage: `url('${imageUrl}')` }}>
        <div className="absolute inset-0 bg-black/30 rounded-t-2xl" />
        <div className="absolute inset-0 flex items-center px-4">
          <h3 className="text-white text-md font-semibold truncate drop-shadow-md z-10">
            {research.title}
          </h3>
        </div>
      </div>

      {/* Conteúdo textual abaixo da imagem */}
      <div className="p-4 space-y-2 text-sm">
        <p className="text-gray-600 truncate">
          Descrição: {research.description || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Local: {research.location_title || "—"}
        </p>
        <p className="text-gray-600 truncate">
          Início: {research.release_date || "—"}
        </p>
      </div>

      {/* Rodapé com botões */}
      <div className="flex items-center justify-between gap-2 px-4 pb-4">
        {research._syncStatus && (
          <span
            className={`flex-shrink-0 truncate max-w-[100px] px-2 py-1 text-xs font-semibold rounded ${
              VARIANTS[research._syncStatus] || VARIANTS.verde
            }`}
          >
            {research._syncStatus}
          </span>
        )}
        <div className="flex items-center gap-2 ml-auto">
          <Button
            variant="transparent_cinza"
            className="p-2"
            title="Ver Detalhes"
            onClick={() => router.push(`/researches/${research.id}`)}
          >
            <span className="material-symbols-outlined text-base">
              visibility
            </span>
          </Button>
          <Button
            variant="transparent_cinza"
            className="p-2"
            title="Ver Respostas"
            onClick={() => router.push(`/researches/${research.id}/answers`)}
          >
            <span className="material-symbols-outlined text-base">
              question_answer
            </span>
          </Button>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : ResearchCardCompact.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCardCompact.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";

export default function ResearchCardCompact({ research }) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className="bg-white border border-gray-200 rounded-lg p-3 shadow-sm text-sm space-y-1 hover:shadow-md transition-all"
    >
      <div className="flex items-center gap-2">
        <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center text-gray-600 text-xs font-bold uppercase">
          {research.title?.charAt(0)}
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-medium text-gray-800 truncate">{research.title}</h4>
          <p className="text-xs text-gray-500 truncate">ID: {research.id}</p>
          <p className="text-xs text-gray-500 truncate">Local: {research.location_title || "—"}</p>
          <p className="text-xs text-gray-500 truncate">Início: {research.release_date || "—"}</p>
          {/* Adicione mais campos aqui se quiser */}
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : ResearchCardSkeleton.jsx
📂 Pasta   : components/ui/Research
🧭 Caminho : components/ui/Research/ResearchCardSkeleton.jsx
--------------------------------------
📜 Conteúdo:

export default function ResearchCardSkeleton() {
    return (
      <div className="animate-pulse bg-white rounded-lg shadow p-4 space-y-3">
        <div className="h-4 bg-gray-300 rounded w-3/4" />
        <div className="h-3 bg-gray-200 rounded w-full" />
        <div className="h-3 bg-gray-200 rounded w-5/6" />
        <div className="h-3 bg-gray-200 rounded w-1/2" />
      </div>
    );
  }
  

============================================================


📄 Arquivo : SideBarSectionsFilter.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/SideBarSectionsFilter.jsx
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import { AnimatePresence, motion } from "framer-motion";

/**
 * SideBarSectionsFilter
 * Componente de navegação entre seções via ícones e labels.
 * - Aparece como um botão flutuante (bolinha) para abrir/fechar
 * - Exibe menu fixo à direita ao abrir, com animação
 *
 * Props:
 *  - sections: [{ id: string, label: string, icon: string }]
 */
export default function SideBarSectionsFilter({ sections }) {
  const [visible, setVisible] = useState(false);

  const handleScrollTo = (id) => {
    const el = document.getElementById(id);
    if (el) el.scrollIntoView({ behavior: "smooth" });
    setVisible(false); // fecha o menu após clique
  };

  return (
    <>
      {/* Botão flutuante para abrir/fechar */}
      <button
        onClick={() => setVisible((prev) => !prev)}
        className="fixed bottom-4 right-4 bg-gray-400 text-white rounded-full w-12 h-12 flex items-center justify-center shadow-xl z-50 hover:scale-105 transition"
      >
        <span className="material-symbols-outlined">
          {visible ? "close" : "menu"}
        </span>
      </button>

      {/* Navbar lateral direita animada */}
      <AnimatePresence>
        {visible && (
          <motion.nav
            initial={{ x: 200, opacity: 0 }}
            animate={{ x: 0, opacity: 1 }}
            exit={{ x: 200, opacity: 0 }}
            transition={{ duration: 0.25 }}
            className="fixed right-0 top-1/3 -translate-y-1/2 bg-white border-l border-gray-200 rounded-l-xl shadow-2xl p-4 flex flex-col gap-5 z-40"
          >
            {sections.map((section) => (
              <button
                key={section.id}
                onClick={() => handleScrollTo(section.id)}
                className="flex flex-col items-center text-xs text-gray-700 hover:text-indigo-600 transition"
              >
                <span className="material-symbols-outlined text-xl">
                  {section.icon}
                </span>
                <span className="text-[10px] mt-1">{section.label}</span>
              </button>
            ))}
          </motion.nav>
        )}
      </AnimatePresence>
    </>
  );
}


============================================================


📄 Arquivo : Switch.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/Switch.jsx
--------------------------------------
📜 Conteúdo:

import { motion, AnimatePresence } from "framer-motion";
import {
  ChevronDown,
  ChevronUp,
  Check,
  Eye,
  EyeOff,
} from "lucide-react";
import React from "react";

export default function Switch({
  checked = false,
  onChange,
  disabled = false,
  type = "toggle", // "toggle", "arrow", "checkbox", "eye"
}) {
  const baseBtn =
    "flex items-center gap-2 px-3 py-1 text-sm rounded-md border transition-all duration-200 shadow-sm " +
    "bg-white dark:bg-zinc-800 text-gray-700 dark:text-gray-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500";

  const interactive = !disabled
    ? "hover:bg-gray-100 dark:hover:bg-zinc-700 cursor-pointer"
    : "opacity-50 cursor-not-allowed";

  if (type === "arrow") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`w-8 h-8 flex items-center justify-center rounded-full border border-gray-300 bg-transparent shadow-sm hover:bg-gray-100 transition-all focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
          disabled ? "opacity-50 cursor-not-allowed" : ""
        }`}
      >
        <AnimatePresence mode="wait" initial={false}>
          {checked ? (
            <motion.div
              key="up"
              initial={{ opacity: 0, y: 4 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: -4 }}
              transition={{ duration: 0.2 }}
            >
              <ChevronUp className="w-4 h-4 text-green-600" />
            </motion.div>
          ) : (
            <motion.div
              key="down"
              initial={{ opacity: 0, y: -4 }}
              animate={{ opacity: 1, y: 0 }}
              exit={{ opacity: 0, y: 4 }}
              transition={{ duration: 0.2 }}
            >
              <ChevronDown className="w-4 h-4 text-green-600" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  if (type === "eye") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`${baseBtn} ${interactive}`}
      >
        <AnimatePresence mode="wait" initial={false}>
          {checked ? (
            <motion.div
              key="eye"
              className="flex items-center gap-1"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
            >
              Exibir <Eye className="w-4 h-4 text-green-600" />
            </motion.div>
          ) : (
            <motion.div
              key="eyeoff"
              className="flex items-center gap-1"
              initial={{ opacity: 0, scale: 0.9 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.9 }}
              transition={{ duration: 0.2 }}
            >
              Ocultar <EyeOff className="w-4 h-4 text-gray-500" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  if (type === "checkbox") {
    return (
      <button
        type="button"
        aria-pressed={checked}
        onClick={() => !disabled && onChange(!checked)}
        disabled={disabled}
        className={`flex items-center justify-center w-5 h-5 rounded border transition-all duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
          checked
            ? "bg-green-600 border-green-700"
            : "bg-white border-gray-300"
        } ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}`}
      >
        <AnimatePresence>
          {checked && (
            <motion.div
              key="check"
              initial={{ opacity: 0, scale: 0.8 }}
              animate={{ opacity: 1, scale: 1 }}
              exit={{ opacity: 0, scale: 0.8 }}
              transition={{ duration: 0.2 }}
            >
              <Check className="w-4 h-4 text-white" />
            </motion.div>
          )}
        </AnimatePresence>
      </button>
    );
  }

  // toggle switch padrão
  return (
    <button
      type="button"
      aria-pressed={checked}
      onClick={() => !disabled && onChange(!checked)}
      disabled={disabled}
      className={`relative inline-flex h-6 w-11 items-center rounded-full border transition-all duration-200 focus:outline-none focus-visible:ring-2 focus-visible:ring-green-500 ${
        checked
          ? "bg-green-600 border-green-700"
          : "bg-gray-300 border-gray-300"
      } ${disabled ? "opacity-50 cursor-not-allowed" : "hover:opacity-90"}`}
    >
      <motion.div
        className="absolute left-1 flex items-center justify-center h-4 w-4 rounded-full bg-white shadow-md"
        animate={{ x: checked ? 20 : 0 }}
        transition={{ type: "spring", stiffness: 300, damping: 20 }}
      />
    </button>
  );
}


============================================================


📄 Arquivo : UserCard.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCard.jsx
--------------------------------------
📜 Conteúdo:

// components/ui/UserCard.jsx
import Button from "@/components/ui/Button";
import { VARIANTS } from "@/config/colors";

export default function UserCard({ user, onViewDetails }) {
  const getBadgeVariant = (status) => {
    switch (status) {
      case "pendingCreate": return VARIANTS.azul_escuro;
      case "pendingUpdate": return VARIANTS.warning;
      case "pendingDelete": return VARIANTS.vermelho;
      default: return VARIANTS.verde;
    }
  };

  return (
    <div className="rounded-lg shadow p-4 flex flex-col justify-between transition transform hover:scale-105 hover:shadow-xl">
      <div className="space-y-2 text-sm">
        <h3 className="text-lg font-semibold truncate">{user.name}</h3>
        <p className="text-gray-600 truncate">Email: {user.email}</p>
        <p className="text-gray-600 truncate">Papel: {user.role}</p>
        <p className="text-gray-600 truncate">Status: {user.status}</p>
      </div>
      <div className="flex items-center gap-2 mt-4">
        {user._syncStatus && (
          <span
            className={`flex-shrink-0 truncate max-w-[100px] px-2 py-1 text-xs font-semibold rounded ${getBadgeVariant(user._syncStatus)}`}
          >
            {user._syncStatus}
          </span>
        )}
        <Button
          variant="transparent_cinza"
          className="p-1 flex-shrink-0"
          onClick={onViewDetails}
        >
          <span className="material-symbols-outlined">info</span>
        </Button>
      </div>
    </div>
  );
}

============================================================


📄 Arquivo : UserCardCompact.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCardCompact.jsx
--------------------------------------
📜 Conteúdo:

import { motion } from "framer-motion";

/**
 * UserCardCompact
 * ---------------
 * Exibe as informações de um usuário em formato de card.
 * - `user`: objeto com {id, name, role, status, email}.
 * - `borderColor`: string opcional para personalizar a cor da borda (ex: "border-green-500").
 * - `showRemoveButton`: boolean opcional (default false). Se true, exibe um botão "x" no canto superior.
 * - `onRemove`: função opcional para ser chamada ao clicar no botão "x".
 */
export default function UserCardCompact({
  user,
  borderColor = "border-gray-200",
  showRemoveButton = false,
  onRemove,
}) {
  return (
    <motion.div
      initial={{ opacity: 0, y: 8 }}
      animate={{ opacity: 1, y: 0 }}
      whileHover={{ scale: 1.02 }}
      transition={{ duration: 0.2, ease: "easeOut" }}
      className={`relative bg-white border rounded-lg p-3 shadow-sm text-sm space-y-1 hover:shadow-md transition-all ${borderColor}`}
    >
      {/* Se estiver habilitado para remoção, exibe o botão "x" */}
      {showRemoveButton && (
        <button
          type="button"
          onClick={onRemove}
          className="absolute top-1 right-1 text-gray-500 hover:text-red-500 text-base"
          title="Remover"
        >
          ✕
        </button>
      )}

      <div className="flex items-center gap-2">
        {/* Inicial do Nome */}
        <div className="w-8 h-8 bg-gray-100 rounded-full flex items-center justify-center text-gray-600 text-xs font-bold uppercase">
          {user.name?.charAt(0)}
        </div>
        <div className="flex-1 min-w-0">
          <h4 className="font-medium text-gray-800 truncate">{user.name}</h4>
          <p className="text-xs text-gray-500 truncate">ID: {user.id}</p>
          <p className="text-xs text-gray-500 truncate">
            Papel: {user.role || "N/A"}
          </p>
          <p className="text-xs text-gray-500 truncate">
            Status: {user.status || "N/A"}
          </p>
          <p className="text-xs text-gray-500 truncate">
            Email: {user.email || "N/A"}
          </p>
        </div>
      </div>
    </motion.div>
  );
}


============================================================


📄 Arquivo : UserCardSkeleton.jsx
📂 Pasta   : components/ui
🧭 Caminho : components/ui/UserCardSkeleton.jsx
--------------------------------------
📜 Conteúdo:

// components/ui/UserCardSkeleton.jsx
export default function UserCardSkeleton() {
    return (
      <div className="animate-pulse bg-white rounded-lg shadow p-4 space-y-3">
        <div className="h-4 bg-gray-300 rounded w-3/4" />
        <div className="h-3 bg-gray-200 rounded w-full" />
        <div className="h-3 bg-gray-200 rounded w-5/6" />
        <div className="h-3 bg-gray-200 rounded w-1/2" />
      </div>
    );
  }
  

============================================================


📄 Arquivo : colors.js
📂 Pasta   : config
🧭 Caminho : config/colors.js
--------------------------------------
📜 Conteúdo:

export const VARIANTS = {
  // Verdes
  verde: "text-white bg-emerald-500 border-emerald-600 hover:bg-emerald-600",

  // Vermelhos
  vermelho: "text-white bg-rose-600 border-rose-700 hover:bg-rose-700 shadow-sm",

  // Azuis
  azul_claro: "text-sky-700 bg-sky-100 border-sky-300 hover:bg-sky-200",
  azul_escuro: "text-white bg-sky-600 border-sky-700 hover:bg-sky-700 shadow-sm",

  // Cinzas / Neutros
  cinza: "text-gray-800 bg-gray-200 border-gray-300 hover:bg-gray-300",
  light: "text-gray-800 bg-gray-100 border-gray-200 hover:bg-gray-200",
  dark: "text-white bg-black border-gray-500 hover:bg-gray-800",

  // Transparentes com identidade
  transparent_azul: "text-sky-600 bg-transparent border-none hover:bg-sky-50",
  transparent_vermelho: "text-rose-600 bg-transparent border-none hover:bg-rose-50",
  transparent_verde: "text-emerald-600 bg-transparent border-none hover:bg-emerald-50",
  transparent_cinza: "text-gray-600 bg-transparent border-none hover:bg-gray-100",

  // Branding e utilidades
  primary: "text-white bg-indigo-600 border-indigo-700 hover:bg-indigo-700 shadow-sm",
  secondary: "text-white bg-gray-600 border-gray-700 hover:bg-gray-700",
  warning: "text-white bg-amber-500 border-amber-600 hover:bg-amber-600",
};


============================================================


📄 Arquivo : data_types.js
📂 Pasta   : config
🧭 Caminho : config/data_types.js
--------------------------------------
📜 Conteúdo:




export const USER_ROLES = ["admin", "researcher"]


export const USER_STATUS = ["active", "inactive"]







============================================================


📄 Arquivo : routes.js
📂 Pasta   : config
🧭 Caminho : config/routes.js
--------------------------------------
📜 Conteúdo:

export const PUBLIC_PAGES = ["/login", "/forgot-password", "/validate-code"];


export const PUBLIC_APIS = [
  "/api/auth/login",
  "/api/auth/forgot-password",
  "/api/auth/validate-code",
];

export const AUTHENTICATED_PAGES = [
  "/create",
  "/users",
  "/dashboard",
  "/",
];


export const ROLE_PERMISSIONS = {
  admin: [],
  research: [],
};


============================================================


📄 Arquivo : tabs.js
📂 Pasta   : config
🧭 Caminho : config/tabs.js
--------------------------------------
📜 Conteúdo:

export const TABS = {
  Dashboard: {
    link: "/",
    icon: "dashboard",
  },
  Usuários: {
    link: "/users",
    icon: "group",
  },
  Pesquisas: {
    icon: "app_registration",
    subTabs: {
      "Pesquisas": {
        link: "/researches",
        icon: "pending_actions",
      },
      "Criar pesquisa": {
        link: "/researches/create",
        icon: "add",
      },
    },
  },
  Relatórios: {
    link: "/reports",
    icon: "analytics",
  },
};

export const PERMISSION_TABS = {
  admin: ["Usuários", "Criar pesquisa"],
  research: [],
};

export const TABSTYLES = {
  active: "text-white bg-black border-gray-800 hover:bg-gray-800",
  inactive: "text-gray-700 border-gray-200 hover:bg-gray-100 shadow-sm transition-colors",
};


============================================================


📄 Arquivo : AuthContext.jsx
📂 Pasta   : context
🧭 Caminho : context/AuthContext.jsx
--------------------------------------
📜 Conteúdo:

import { createContext, useContext, useEffect, useState } from "react";
import { initAuthDB } from "@/lib/db";

const AuthContext = createContext();

export const AuthProvider = ({ children }) => {
  const [authToken, setAuthToken] = useState(null);
  const [userData, setUserData] = useState(null);

  const fetchFromIndexedDB = async (storeName, key) => {
    const db = await initAuthDB();
    return await db.get(storeName, key);
  };

  const saveToIndexedDB = async (storeName, key, data) => {
    const db = await initAuthDB();
    await db.put(storeName, { id: key, ...data });
  };

  const loadAuthState = async () => {
    const creds = await fetchFromIndexedDB("user-creds", "user-creds");
    const user = await fetchFromIndexedDB("user-data", "user-data");
    if (creds) setAuthToken(creds);
    if (user) setUserData(user.user);
  };

  const saveCredentials = async ({ access_token, token_type, expires_at }) => {
    const data = { access_token, token_type, expires_at };
    await saveToIndexedDB("user-creds", "user-creds", data);
    setAuthToken(data);
  };
  
  const saveUserInfo = async (user) => {
    await saveToIndexedDB("user-data", "user-data", { user });
    setUserData(user);
  };
  
  const syncUserDataFromAPI = async () => {
    try {
      if (!userData?.id) return;

      const res = await fetch(`/api/users/${userData.id}`);
      if (!res.ok) throw new Error("Erro ao buscar dados do usuário");

      const data = await res.json();
      if (data.user) {
        await saveUserInfo(data.user);
      }
    } catch (err) {
      console.error("[syncUserDataFromAPI]", err);
    }
  };

  useEffect(() => {
    loadAuthState();
  }, []);

  return (
    <AuthContext.Provider
      value={{
        userCreds: authToken,
        userData,
        saveCredentials,
        saveUserInfo,
        syncUserData: syncUserDataFromAPI,
      }}
    >
      {children}
    </AuthContext.Provider>
  );
};

export const useAuth = () => useContext(AuthContext);


============================================================


📄 Arquivo : LoadingContext.jsx
📂 Pasta   : context
🧭 Caminho : context/LoadingContext.jsx
--------------------------------------
📜 Conteúdo:

import { createContext, useState, useContext } from "react";

const LoadingContext = createContext();

export function LoadingContextProvider({ children }) {
  const [isLoading, setIsLoading] = useState(false);

  return (
    <LoadingContext.Provider value={{ isLoading, setIsLoading }}>
      {children}
    </LoadingContext.Provider>
  );
}
export function useLoading() {
  return useContext(LoadingContext);
}


============================================================


📄 Arquivo : MessageContext.jsx
📂 Pasta   : context
🧭 Caminho : context/MessageContext.jsx
--------------------------------------
📜 Conteúdo:

import { createContext, useContext, useState } from "react";
import Message from "@/components/ui/Message";


const MessageContext = createContext();

export function MessageProvider({ children }) {
  const [message, setMessage] = useState("");
  const [variant, setVariant] = useState("info");
  const [show, setShow] = useState(false);

  const showMessage = (msg, type = "info", duration = 3000) => {
    setMessage(msg);
    setVariant(type);
    setShow(true);

    setTimeout(() => {
      setShow(false);
    }, duration);
  };

  return (
    <MessageContext.Provider value={{ showMessage }}>
      {children}
      <Message message={message} variant={variant} show={show} />
    </MessageContext.Provider>
  );
}

export function useMessage() {
  return useContext(MessageContext);
}



============================================================


📄 Arquivo : index.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/index.ts
--------------------------------------
📜 Conteúdo:

export * from './useUsers';
export * from './useActivityAnswers';
export * from './useFields';
export * from './useResearches';
export * from './useSurveyTimeRanges';
export * from './useSurveyRegions';
export * from './useSurveyGroups';
export * from './useSurveyContributors';
export * from './useStaticSurveys';
export * from './useFormSurveys';
export * from './useDynamicSurveys';
export * from './useResearchContributors';
export * from './useInputTypes';
export * from './useFieldOptions';
export * from './useSurveyAnswers';


============================================================


📄 Arquivo : useActivityAnswers.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useActivityAnswers.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useActivityAnswers.ts
import { useEffect, useState } from 'react';
import { ActivityAnswer } from '@/lib/types/indexeddb';
import { createActivityAnswer } from '@/repositories/server/activityAnswerApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useActivityAnswers() {
  type LocalActivityAnswer = ActivityAnswer & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [answers, setAnswers] = useState<LocalActivityAnswer[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('activity_answers');
        setAnswers(data);
      } catch (err) {
        setError('Erro ao carregar respostas de atividade');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addActivityAnswer = async (answer: ActivityAnswer) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newAnswer: LocalActivityAnswer = { ...answer, _syncStatus: isOnline ? 'synced' : 'pending' };
    setAnswers(prev => [...prev, newAnswer]);

    try {
      await createItem('activity_answers', newAnswer);
      if (isOnline) await createActivityAnswer(answer);
    } catch {
      const errorAnswer: LocalActivityAnswer = { ...answer, _syncStatus: 'error' };
      await createItem('activity_answers', errorAnswer);
    }
  };

  return { answers, loading, error, addActivityAnswer };
}


============================================================


📄 Arquivo : useDynamicSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useDynamicSurveys.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useDynamicSurveys.ts
import { useEffect, useState } from 'react';
import { DynamicSurvey } from '@/lib/types/indexeddb';
import { createDynamicSurvey } from '@/repositories/server/dynamicSurveyApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useDynamicSurveys() {
  type LocalDynamicSurvey = DynamicSurvey & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [surveys, setSurveys] = useState<LocalDynamicSurvey[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('dynamic_surveys');
        setSurveys(data);
      } catch (err) {
        setError('Erro ao carregar dynamic surveys');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addDynamicSurvey = async (survey: DynamicSurvey) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newSurvey: LocalDynamicSurvey = { ...survey, _syncStatus: isOnline ? 'synced' : 'pending' };
    setSurveys(prev => [...prev, newSurvey]);

    try {
      await createItem('dynamic_surveys', newSurvey);
      if (isOnline) await createDynamicSurvey(survey);
    } catch {
      const errorSurvey: LocalDynamicSurvey = { ...survey, _syncStatus: 'error' };
      await createItem('dynamic_surveys', errorSurvey);
    }
  };

  return { surveys, loading, error, addDynamicSurvey };
}

============================================================


📄 Arquivo : useFieldOptions.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFieldOptions.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useFieldOptions.ts
import { useEffect, useState } from 'react';
import { FieldOption } from '@/lib/types/indexeddb';
import { getFieldOptions, createFieldOption } from '@/repositories/server/fieldOptionApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useFieldOptions(fieldId: string) {
  type LocalFieldOption = FieldOption & { _syncStatus?: 'pending' | 'synced' | 'error' };

  const [options, setOptions] = useState<LocalFieldOption[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const isOnline = typeof window !== 'undefined' && navigator.onLine;
        const data = isOnline ? await getFieldOptions(fieldId) : await getAllItems('field_options');
        setOptions(data.filter(opt => opt.field_id === fieldId));
      } catch (err) {
        setError('Erro ao carregar opções do campo');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, [fieldId]);

  const addFieldOption = async (option: FieldOption) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newOption: LocalFieldOption = { ...option, _syncStatus: isOnline ? 'synced' : 'pending' };
    setOptions(prev => [...prev, newOption]);

    try {
      await createItem('field_options', newOption);
      if (isOnline) await createFieldOption(option);
    } catch {
      const errorOption: LocalFieldOption = { ...option, _syncStatus: 'error' };
      await createItem('field_options', errorOption);
    }
  };

  return { options, loading, error, addFieldOption };
}


============================================================


📄 Arquivo : useFields.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFields.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useFields.ts
import { useEffect, useState } from "react";
import { Field } from "@/lib/types/indexeddb";
import { createField } from "@/repositories/server/fieldApi";
import {
  createItem,
  getAllItems,
} from "@/repositories/indexeddb/indexedDBService";

export function useFields() {
  type LocalField = Omit<Field, "id"> & {
    id?: string;
    _syncStatus?: "pending" | "synced" | "error";
  };
  const [fields, setFields] = useState<LocalField[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems("fields");
        setFields(data);
      } catch (err) {
        setError("Erro ao carregar campos");
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addField = async (field: Field) => {
    const isOnline = typeof window !== "undefined" && navigator.onLine;
    const newField: LocalField = {
      ...field,
      _syncStatus: isOnline ? "synced" : "pending",
    };
    setFields((prev) => [...prev, newField]);

    try {
      await createItem("fields", newField);
      if (isOnline) await createField(field);
    } catch {
      const errorField: LocalField = { ...field, _syncStatus: "error" };
      await createItem("fields", errorField);
    }
  };

  return { fields, loading, error, addField };
}


============================================================


📄 Arquivo : useFormSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useFormSurveys.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from 'react';
import { FormSurvey } from '@/lib/types/indexeddb';
import { createFormSurvey } from '@/repositories/server/formSurveyApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useFormSurveys() {
  type LocalFormSurvey = FormSurvey & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [surveys, setSurveys] = useState<LocalFormSurvey[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('form_surveys');
        setSurveys(data);
      } catch (err) {
        setError('Erro ao carregar form surveys');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addFormSurvey = async (survey: FormSurvey) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newSurvey: LocalFormSurvey = { ...survey, _syncStatus: isOnline ? 'synced' : 'pending' };
    setSurveys(prev => [...prev, newSurvey]);

    try {
      await createItem('form_surveys', newSurvey);
      if (isOnline) await createFormSurvey(survey);
    } catch {
      const errorSurvey: LocalFormSurvey = { ...survey, _syncStatus: 'error' };
      await createItem('form_surveys', errorSurvey);
    }
  };

  return { surveys, loading, error, addFormSurvey };
}


============================================================


📄 Arquivo : useInputTypes.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useInputTypes.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useInputTypes.ts
import { useEffect, useState } from 'react';
import { InputType } from '@/lib/types/indexeddb';
import { getInputTypes } from '@/repositories/server/inputTypeApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useInputTypes() {
  const [types, setTypes] = useState<InputType[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const isOnline = typeof window !== 'undefined' && navigator.onLine;
        const data = isOnline ? await getInputTypes() : await getAllItems('input_types');

        setTypes(data);
      } catch (err) {
        setError('Erro ao carregar tipos de input');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  return { types, loading, error };
}

============================================================


📄 Arquivo : useResearchContributors.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useResearchContributors.ts
--------------------------------------
📜 Conteúdo:

import { useEffect, useState } from 'react';
import { ResearchContributor } from '@/lib/types/indexeddb';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';
import { createResearchContributor } from '@/repositories/server/researchContributorApi';

export function useResearchContributors() {
  type LocalResearchContributor = ResearchContributor & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [contributors, setContributors] = useState<LocalResearchContributor[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('research_contributors');
        setContributors(data);
      } catch (err) {
        setError('Erro ao carregar colaboradores de pesquisa');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addResearchContributor = async (contributor: ResearchContributor) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newContributor: LocalResearchContributor = { ...contributor, _syncStatus: isOnline ? 'synced' : 'pending' };
    setContributors(prev => [...prev, newContributor]);

    try {
      await createItem('research_contributors', newContributor);
      if (isOnline) await createResearchContributor(contributor);
    } catch {
      const errorContributor: LocalResearchContributor = { ...contributor, _syncStatus: 'error' };
      await createItem('research_contributors', errorContributor);
    }
  };

  return { contributors, loading, error, addResearchContributor };
}


============================================================


📄 Arquivo : useResearches.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useResearches.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useResearches.ts
import { useEffect, useState } from 'react';
import { Research } from '@/lib/types/indexeddb';
import { createResearch } from '@/repositories/server/researchApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useResearches() {
  type LocalResearch = Omit<Research, 'id'> & { id?: string; _syncStatus?: 'pending' | 'synced' | 'error' };
  const [researches, setResearches] = useState<LocalResearch[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('researches');
        setResearches(data);
      } catch (err) {
        setError('Erro ao carregar pesquisas');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addResearch = async (research: Research) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newResearch: LocalResearch = { ...research, _syncStatus: isOnline ? 'synced' : 'pending' };
    setResearches(prev => [...prev, newResearch]);

    try {
      await createItem('researches', newResearch);
      if (isOnline) await createResearch(research);
    } catch {
      const errorResearch: LocalResearch = { ...research, _syncStatus: 'error' };
      await createItem('researches', errorResearch);
    }
  };

  return { researches, loading, error, addResearch };
}


============================================================


📄 Arquivo : useStaticSurveys.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useStaticSurveys.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useStaticSurveys.ts
import { useEffect, useState } from 'react';
import { StaticSurvey } from '@/lib/types/indexeddb';
import { createStaticSurvey } from '@/repositories/server/staticSurveyApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useStaticSurveys() {
  type LocalStaticSurvey = StaticSurvey & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [surveys, setSurveys] = useState<LocalStaticSurvey[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('static_surveys');
        setSurveys(data);
      } catch (err) {
        setError('Erro ao carregar static surveys');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addStaticSurvey = async (survey: StaticSurvey) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newSurvey: LocalStaticSurvey = { ...survey, _syncStatus: isOnline ? 'synced' : 'pending' };
    setSurveys(prev => [...prev, newSurvey]);

    try {
      await createItem('static_surveys', newSurvey);
      if (isOnline) await createStaticSurvey(survey);
    } catch {
      const errorSurvey: LocalStaticSurvey = { ...survey, _syncStatus: 'error' };
      await createItem('static_surveys', errorSurvey);
    }
  };

  return { surveys, loading, error, addStaticSurvey };
}


============================================================


📄 Arquivo : useSurveyAnswers.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyAnswers.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyAnswers.ts
import { useEffect, useState } from 'react';
import { SurveyAnswer } from '@/lib/types/indexeddb';
import { getSurveyAnswers, createSurveyAnswer } from '@/repositories/server/surveyAnswerApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyAnswers() {
  type LocalSurveyAnswer = SurveyAnswer & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);
  const [answers, setAnswers] = useState<LocalSurveyAnswer[]>([]);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const isOnline = typeof window !== 'undefined' && navigator.onLine;
        const data = isOnline ? await getSurveyAnswers() : await getAllItems('survey_answers');
        setAnswers(data);
      } catch (err) {
        setError('Erro ao carregar respostas da coleta');
      } finally {
        setLoading(false);
      }
    };

    fetchData();
  }, []);

  const addSurveyAnswer = async (answer: SurveyAnswer) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newAnswer: LocalSurveyAnswer = { ...answer, _syncStatus: isOnline ? 'synced' : 'pending' };

    setAnswers(prev => [...prev, newAnswer]);

    try {
      await createItem('survey_answers', newAnswer);
      if (isOnline) await createSurveyAnswer(answer);
    } catch {
      const errorAnswer: LocalSurveyAnswer = { ...answer, _syncStatus: 'error' };
      await createItem('survey_answers', errorAnswer);
    }
  };

  return {
    answers,
    loading,
    error,
    addSurveyAnswer,
  };
}

============================================================


📄 Arquivo : useSurveyContributors.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyContributors.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyContributors.ts
import { useEffect, useState } from 'react';
import { SurveyContributor } from '@/lib/types/indexeddb';
import { createSurveyContributor } from '@/repositories/server/surveyContributorApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyContributors() {
  type LocalSurveyContributor = SurveyContributor & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [contributors, setContributors] = useState<LocalSurveyContributor[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('survey_contributors');
        setContributors(data);
      } catch (err) {
        setError('Erro ao carregar colaboradores');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addSurveyContributor = async (contributor: SurveyContributor) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newContributor: LocalSurveyContributor = { ...contributor, _syncStatus: isOnline ? 'synced' : 'pending' };
    setContributors(prev => [...prev, newContributor]);

    try {
      await createItem('survey_contributors', newContributor);
      if (isOnline) await createSurveyContributor(contributor);
    } catch {
      const errorContributor: LocalSurveyContributor = { ...contributor, _syncStatus: 'error' };
      await createItem('survey_contributors', errorContributor);
    }
  };

  return { contributors, loading, error, addSurveyContributor };
}


============================================================


📄 Arquivo : useSurveyGroups.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyGroups.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyGroups.ts
import { useEffect, useState } from 'react';
import { SurveyGroup } from '@/lib/types/indexeddb';
import { createSurveyGroup } from '@/repositories/server/surveyGroupApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyGroups() {
  type LocalSurveyGroup = SurveyGroup & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [groups, setGroups] = useState<LocalSurveyGroup[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('survey_group');
        setGroups(data);
      } catch (err) {
        setError('Erro ao carregar grupos');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addSurveyGroup = async (group: SurveyGroup) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newGroup: LocalSurveyGroup = { ...group, _syncStatus: isOnline ? 'synced' : 'pending' };
    setGroups(prev => [...prev, newGroup]);

    try {
      await createItem('survey_group', newGroup);
      if (isOnline) await createSurveyGroup(group);
    } catch {
      const errorGroup: LocalSurveyGroup = { ...group, _syncStatus: 'error' };
      await createItem('survey_group', errorGroup);
    }
  };

  return { groups, loading, error, addSurveyGroup };
}

============================================================


📄 Arquivo : useSurveyRegions.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyRegions.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyRegions.ts
import { useEffect, useState } from 'react';
import { SurveyRegion } from '@/lib/types/indexeddb';
import { createSurveyRegion } from '@/repositories/server/surveyRegionApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyRegions() {
  type LocalSurveyRegion = SurveyRegion & { _syncStatus?: 'pending' | 'synced' | 'error' };

  const [regions, setRegions] = useState<LocalSurveyRegion[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('survey_regions');
        setRegions(data);
      } catch (err) {
        setError('Erro ao carregar regiões');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addSurveyRegion = async (region: SurveyRegion) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newRegion: LocalSurveyRegion = {
      ...region,
      _syncStatus: isOnline ? 'synced' : 'pending',
    };
    setRegions((prev) => [...prev, newRegion]);

    try {
      await createItem('survey_regions', newRegion);
      if (isOnline) await createSurveyRegion(region);
    } catch {
      const errorRegion: LocalSurveyRegion = {
        ...region,
        _syncStatus: 'error',
      };
      await createItem('survey_regions', errorRegion);
    }
  };

  return {
    regions,
    loading,
    error,
    addSurveyRegion,
  };
}


============================================================


📄 Arquivo : useSurveyTimeRanges.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useSurveyTimeRanges.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useSurveyTimeRanges.ts
import { useEffect, useState } from 'react';
import { SurveyTimeRange } from '@/lib/types/indexeddb';
import { createSurveyTimeRange } from '@/repositories/server/surveyTimeRangeApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useSurveyTimeRanges() {
  type LocalSurveyTimeRange = SurveyTimeRange & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [ranges, setRanges] = useState<LocalSurveyTimeRange[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('survey_time_ranges');
        setRanges(data);
      } catch (err) {
        setError('Erro ao carregar faixas de horário');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addSurveyTimeRange = async (range: SurveyTimeRange) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newRange: LocalSurveyTimeRange = { ...range, _syncStatus: isOnline ? 'synced' : 'pending' };
    setRanges(prev => [...prev, newRange]);

    try {
      await createItem('survey_time_ranges', newRange);
      if (isOnline) await createSurveyTimeRange(range);
    } catch {
      const errorRange: LocalSurveyTimeRange = { ...range, _syncStatus: 'error' };
      await createItem('survey_time_ranges', errorRange);
    }
  };

  return { ranges, loading, error, addSurveyTimeRange };
}

============================================================


📄 Arquivo : useUsers.ts
📂 Pasta   : hooks
🧭 Caminho : hooks/useUsers.ts
--------------------------------------
📜 Conteúdo:

// src/hooks/useUsers.ts
import { useEffect, useState } from 'react';
import { User } from '@/lib/types/indexeddb';
import { createUser } from '@/repositories/server/userApi';
import { createItem, getAllItems } from '@/repositories/indexeddb/indexedDBService';

export function useUsers() {
  type LocalUser = User & { _syncStatus?: 'pending' | 'synced' | 'error' };
  const [users, setUsers] = useState<LocalUser[]>([]);
  const [loading, setLoading] = useState(true);
  const [error, setError] = useState<string | null>(null);

  useEffect(() => {
    const fetchData = async () => {
      setLoading(true);
      try {
        const data = await getAllItems('users');
        setUsers(data);
      } catch (err) {
        setError('Erro ao carregar usuários');
      } finally {
        setLoading(false);
      }
    };
    fetchData();
  }, []);

  const addUser = async (user: User) => {
    const isOnline = typeof window !== 'undefined' && navigator.onLine;
    const newUser: LocalUser = { ...user, _syncStatus: isOnline ? 'synced' : 'pending' };
    setUsers(prev => [...prev, newUser]);

    try {
      await createItem('users', newUser);
      if (isOnline) await createUser(user);
    } catch {
      const errorUser: LocalUser = { ...user, _syncStatus: 'error' };
      await createItem('users', errorUser);
    }
  };

  return { users, loading, error, addUser };
}


============================================================


📄 Arquivo : db.js
📂 Pasta   : lib
🧭 Caminho : lib/db.js
--------------------------------------
📜 Conteúdo:

import { openDB } from "idb";

export async function initAuthDB() {
    return openDB("UserCredentialsDB", 1, {
      upgrade(db) {
        if (!db.objectStoreNames.contains("user-data")) {
          db.createObjectStore("user-data", { keyPath: "id" });
        }
        if (!db.objectStoreNames.contains("user-creds")) {
          db.createObjectStore("user-creds", { keyPath: "id" });
        }
      },
    });
  }
  

export async function initResearchsDB() {
    return openDB("ResearchsDB", 1, {
      upgrade(db) {
        if (!db.objectStoreNames.contains("researches")) {
          db.createObjectStore("researches", { keyPath: "id" });
        }
      },
    });
}


export async function initCachedDB() {
  return openDB("CachedDB", 1, {
    upgrade(db) {
      const stores = ["users", "researches", "itemTobeCreated"];
      for (const storeName of stores) {
        if (!db.objectStoreNames.contains(storeName)) {
          db.createObjectStore(storeName, { keyPath: "id" });
        }
      }
    },
  });
}


  

============================================================


📄 Arquivo : network.js
📂 Pasta   : lib
🧭 Caminho : lib/network.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";

export function useNetworkStatus() {
  const [isOnline, setIsOnline] = useState(true); // Inicialmente assume online para evitar mismatch no SSR

  useEffect(() => {
    const updateStatus = () => setIsOnline(navigator.onLine);

    window.addEventListener("online", updateStatus);
    window.addEventListener("offline", updateStatus);

    updateStatus(); // Atualiza com o estado real do navegador

    return () => {
      window.removeEventListener("online", updateStatus);
      window.removeEventListener("offline", updateStatus);
    };
  }, []);

  return isOnline;
}


============================================================


📄 Arquivo : indexeddb.ts
📂 Pasta   : lib/types
🧭 Caminho : lib/types/indexeddb.ts
--------------------------------------
📜 Conteúdo:

export interface User {
  id: string; // UUID
  name: string;
  email: string;
  password: string;
  role: string; // 'admin', 'researcher', etc.
  status: string; // 'active', 'inactive', etc.
  created_at?: string;
  updated_at?: string;
}

export interface ActivityAnswer {
  id?: string;
  contributor_id: string;
  field_id: string;
  field_option_id?: string;
  value: string;
  created_at: string;
  _syncStatus?: "pending" | "synced" | "error";
}

export interface Field {
  id?: string;
  activity_id: string;
  title: string;
  input_type: string;
  description?: string;
  created_at?: string;
  updated_at?: string;
}

export interface Research {
  id?: string;
  title: string;
  description?: string;
  release_date?: string;
  lat?: number;
  long?: number;
  location_title?: string;
  created_by?: string;
  created_at?: string;
  updated_at?: string;
  end_date?: string;
}

export interface SurveyTimeRange {
  id: string;
  start_time: string; // formato HH:mm:ss
  end_time: string;
  survey_id: string;
  survey_type: string;
}

export interface SurveyRegion {
  id: string;
  name: string;
  lat: number;
  long: number;
  location_title: string;
  survey_type: string;
  survey_id: string;
}

export interface SurveyGroup {
  id: string;
  survey_type: string;
  survey_id: string;
}

export interface SurveyContributor {
  id: string;
  survey_id: string;
  survey_type: string;
  user_id: string;
  instruction?: string;
  created_at?: string;
  updated_at?: string;
}

export interface SurveyAnswer {
  id: string;
  value: string;
  survey_type: string;
  survey_id: string;
  survey_group_id?: string;
  contributor_id: string;
  registered_at: string;
  survey_time_range_id?: string;
  survey_region_id?: string;
}

export interface StaticSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
}

export interface FormSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
}

export interface DynamicSurvey {
  id: string;
  title: string;
  description?: string;
  lat: number;
  long: number;
  location_title: string;
  research_id?: string;
}

export interface ResearchContributor {
  id: string;
  research_id: string;
  user_id: string;
  instruction: string;
}

export interface InputType {
  id: string;
  name: string;
  stored_as: string;
}

export interface FieldOption {
  id: string;
  field_id: string;
  option_text: string;
  option_value?: string;
  created_at: string;
  updated_at: string;
}

export type StoreTypes = {
  users: User;
  activity_answers: ActivityAnswer;
  fields: Field;
  researches: Research;
  survey_time_ranges: SurveyTimeRange;
  survey_regions: SurveyRegion;
  survey_group: SurveyGroup;
  survey_contributors: SurveyContributor;
  survey_answers: SurveyAnswer;
  static_surveys: StaticSurvey;
  form_surveys: FormSurvey;
  dynamic_surveys: DynamicSurvey;
  research_contributors: ResearchContributor;
  input_types: InputType;
  field_options: FieldOption;
};


============================================================


📄 Arquivo : middleware.js
📂 Pasta   : .
🧭 Caminho : middleware.js
--------------------------------------
📜 Conteúdo:

import { NextResponse } from "next/server";
import { jwtVerify } from "jose";
import {
  PUBLIC_PAGES,
  PUBLIC_APIS,
  AUTHENTICATED_PAGES,
  ROLE_PERMISSIONS,
} from "@/config/routes";

const JWT_SECRET = new TextEncoder().encode(process.env.JWT_SECRET);

export async function middleware(request) {
  const { pathname } = request.nextUrl;
  const token = request.cookies.get("token")?.value;
  const isPublicRoute = PUBLIC_PAGES.includes(pathname) || PUBLIC_APIS.includes(pathname);

  let payload = null;
  if (token) {
    try {
      const { payload: verifiedPayload } = await jwtVerify(token, JWT_SECRET);
      payload = verifiedPayload;
    } catch (error) {
      // Token inválido ou expirado: payload continua null
    }
  }
  
  if (isPublicRoute) {
    if (payload?.sub) {
      return NextResponse.redirect(new URL("/", request.url));
    }
    return NextResponse.next();
  }

  if (!payload?.sub) {
    return NextResponse.redirect(new URL("/login", request.url));
  }


  if (AUTHENTICATED_PAGES.some((route) => pathname.startsWith(route))) {
    return NextResponse.next();
  }

  const allowedRoutes = ROLE_PERMISSIONS[payload.role] || [];
  if (!allowedRoutes.some((route) => pathname.startsWith(route))) {
    return NextResponse.redirect(new URL("/", request.url));
  }

  return NextResponse.next();
}

export const config = {
  matcher: [
    "/((?!_next|favicon.ico|manifest.json|workers|robots.txt|img|icons|static|offline|logo|fonts).*)",
  ],
};


============================================================


📄 Arquivo : _app.js
📂 Pasta   : pages
🧭 Caminho : pages/_app.js
--------------------------------------
📜 Conteúdo:

// pages/_app.js
import "@/styles/globals.css";
import { useEffect } from "react";
import { AnimatePresence } from "framer-motion";
import { LoadingContextProvider, useLoading } from "@/context/LoadingContext";
import { MessageProvider } from "@/context/MessageContext";
import { AuthProvider, useAuth } from "@/context/AuthContext";
import Loading from "@/components/ui/Loading";
import { registerServiceWorker } from "@/services/registerServiceWorker";
import PublicLayout from "@/components/layouts/PublicLayout";
import PrivateLayout from "@/components/layouts/PrivateLayout";
import Head from "next/head";
import '@/services/syncWorker';


function AppContent({ Component, pageProps }) {
  const { isLoading } = useLoading();
  const PageComponent = Component;
  const pageName = PageComponent.pageName || "Minha Aplicação";
  const layoutType = PageComponent.layout || "public";
  const Layout = layoutType === "private" ? PrivateLayout : PublicLayout;

  return (
    <>
      <Head>
        <title>{`${pageName} | Minha Aplicação`}</title>
        <link
          rel="icon"
          type="image/png"
          sizes="512x512"
          href="/img/icon-512x512.png"
        />
        <meta
          name="viewport"
          content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no"
        />
      </Head>

      <Layout pageName={pageName}>
        <PageComponent {...pageProps} />
      </Layout>
      <AnimatePresence>{isLoading && <Loading />}</AnimatePresence>
    </>
  );
}

function MyApp({ Component, pageProps }) {
  useEffect(() => {
    registerServiceWorker();
  }, []);

  return (
    <AuthProvider>
      <LoadingContextProvider>
        <MessageProvider>
          <AppContent Component={Component} pageProps={pageProps} />
        </MessageProvider>
      </LoadingContextProvider>
    </AuthProvider>
  );
}

export default MyApp;


============================================================


📄 Arquivo : _document.js
📂 Pasta   : pages
🧭 Caminho : pages/_document.js
--------------------------------------
📜 Conteúdo:

import Document, { Html, Head, Main, NextScript } from "next/document";

class MyDocument extends Document {
  render() {
    return (
      <Html lang="pt-BR">
        <Head>
          <link rel="manifest" href="/manifest.json" />
          <meta name="theme-color" content="#000000" />
          <link rel="apple-touch-icon" href="/img/521-azul.png" />
          <link
            rel="apple-touch-startup-image"
            href="/splashscreens/521-branco.png"
            media="(device-width: 320px) and (device-height: 568px)"
          />
          <meta name="apple-mobile-web-app-capable" content="yes" />
          <meta
            name="apple-mobile-web-app-status-bar-style"
            content="black-translucent"
          />

          <link
            rel="stylesheet"
            href="https://fonts.googleapis.com/css2?family=Material+Symbols+Outlined:opsz,wght,FILL,GRAD@24,200,0,-25"
          />
        </Head>
        <body>
          <Main />
          <NextScript />
        </body>
      </Html>
    );
  }
}

export default MyDocument;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/activity-answers
🧭 Caminho : pages/api/activity-answers/index.js
--------------------------------------
📜 Conteúdo:


export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/activity-answers`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar respostas de atividade' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar resposta de atividade' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : change-password.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/change-password.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const token = req.cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Não autorizado: token ausente" });
  }

  const { new_password, confirm_password } = req.body;



  if (!new_password || !confirm_password) {
    return res
      .status(400)
      .json({ error: "Campos obrigatórios não preenchidos" });
  }

  if (new_password !== confirm_password) {
    return res.status(400).json({ error: "As senhas não coincidem" });
  }

  try {
    const response = await fetch(
      `${process.env.SERVER_URL}/auth/reset_password`,
      {
        method: "PUT",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          new_password,
          confirm_password,
        }),
      }
    );

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json({ message: "Senha atualizada com sucesso!" });
  } catch (err) {
    console.error("Erro ao mudar a senha:", err);
    return res.status(500).json({ error: "Erro interno do servidor" });
  }
}


============================================================


📄 Arquivo : forgot-password.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/forgot-password.js
--------------------------------------
📜 Conteúdo:


export default async function handler(req, res) {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const { email} = req.body;
    try {
        const response = await fetch(`${process.env.SERVER_URL}/auth/forgot_password`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email}),
      });

      
      if (!response.ok) {
        const errorData = await response.json();
        return res.status(response.status).json(errorData);
      }
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }
  

============================================================


📄 Arquivo : login.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/login.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { email, password } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/login`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ email, password }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();

    const expiresDate = new Date(data.access_token.expires_at);
    res.setHeader(
      "Set-Cookie",
      serialize("token", data.access_token.token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        path: "/",
        expires: expiresDate,
      })
    );


    return res.status(200).json(data);

  } catch (err) {
    console.error("[Login Error]", err);
    return res
      .status(500)
      .json({ error: "Erro ao conectar com o servidor de autenticação." });
  }
}


============================================================


📄 Arquivo : logout.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/logout.js
--------------------------------------
📜 Conteúdo:

import { serialize, parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Método não permitido" });
  }

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    res.setHeader("Set-Cookie", serialize("token", "", {
      path: "/",
      expires: new Date(0),
      httpOnly: true,
      secure: process.env.NODE_ENV === "production",
      sameSite: "lax"
    }));
    return res.status(401).json({ message: "Token não encontrado" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/logout`, {
      method: "POST",
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      console.error("Erro ao fazer logout no servidor:", await response.text());
    }
  } catch (error) {
    console.error("Erro de conexão com o servidor:", error);
  }

  res.setHeader("Set-Cookie", serialize("token", "", {
    path: "/",
    expires: new Date(0),
    httpOnly: true,
    secure: process.env.NODE_ENV === "production",
    sameSite: "lax"
  }));

  return res.status(200).json({ message: "Logout realizado com sucesso" });
}


============================================================


📄 Arquivo : register.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/register.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const { name, email, confirmation_email, role, status } = req.body;


  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/register`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ name, email, confirmation_email, role, status }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();

    return res.status(200).json(data);

  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : validate-code.js
📂 Pasta   : pages/api/auth
🧭 Caminho : pages/api/auth/validate-code.js
--------------------------------------
📜 Conteúdo:

import { serialize } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ message: "Method not allowed" });
  }

  const { code } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/validate_code`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
      },
      body: JSON.stringify({ token: code }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    const { token, expires_at } = data.access_token;

    const expiresDate = new Date(expires_at);

    res.setHeader(
      "Set-Cookie",
      serialize("token", token, {
        httpOnly: true,
        secure: process.env.NODE_ENV === "production",
        sameSite: "lax",
        path: "/",
        expires: expiresDate,
      })
    );

    return res.status(200).json(data);

  } catch (err) {
    console.error("[verify-code]", err);
    return res.status(500).json({ message: "Erro ao verificar código" });
  }
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "user_id"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id, user_id  } = req.query;
    const missingFields = checkMissingFields({ research_id, user_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        user_id
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(201).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";
const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "user_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id, user_id } = req.query;

    const missingFields = checkMissingFields({ research_id, user_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors/${user_id}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/contributors
🧭 Caminho : pages/api/contributors/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {

  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { research_id } = req.query;
    const missingFields = checkMissingFields({ research_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/contributors`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();


    const formattedData = data.contributors.map((c) => ({
      value: c.user?.id,
      id: c.user?.id,
      name: c.user?.name,
      label: c.user?.name,
      email: c.user?.email,
      role: c.user?.role,
      status: c.user?.status,
    }));


    return res.status(200).json(formattedData);

  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}

============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["field_id", "option_text", "option_value"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { field_id, option_text, option_value  } = req.query;
    const missingFields = checkMissingFields({ field_id, option_text, option_value });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/fields/${field_id}/options`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        option_text,
        option_value,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(201).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";
const checkMissingFields = (dataObj) => {
  const requiredFields = ["field_id", "option_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { field_id, option_id } = req.query;

    const missingFields = checkMissingFields({ field_id, option_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/fields/${field_id}/options/${option_id}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/field_options
🧭 Caminho : pages/api/field_options/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = ["field_id"];
  return requiredFields.filter((field) => !dataObj[field]);
}

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { field_id } = req.query;
    const missingFields = checkMissingFields({ field_id });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/fields/${field_id}/options`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}

============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "survey_id",
    "survey_type",
    "title",
    "description",
    "input_type_id",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      title,
      description,
      input_type_id
    } = req.body;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      title,
      description,
      input_type_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        title,
        description,
        input_type_id
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "field_id",
    "survey_id",
    "survey_type",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      field_id
    } = req.query;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      field_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields/${field_id}?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      }
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";
export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }
  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { survey_id, survey_type } = req.query;
    const missingFields = checkMissingFields({ survey_id, survey_type });
    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const response = await fetch(`${process.env.SERVER_URL}/survey/${survey_id}/fields?survey_type=${encodeURIComponent(survey_type)}`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
    });


    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    console.error("Erro ao buscar input_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}

const checkMissingFields = (dataObj) => {
    const requiredFields = ["survey_id", "survey_type"];
    return requiredFields.filter((field) => !dataObj[field]);
  };
  



============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/fields
🧭 Caminho : pages/api/fields/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "field_id",
    "survey_id",
    "survey_type",
    "title",
    "description",
    "input_type_id",
  ];
  return requiredFields.filter((field) => !dataObj[field]);
};

export async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      title,
      description,
      input_type_id,
      field_id
    } = req.query;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      title,
      description,
      input_type_id,
      field_id
    });

    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${
      process.env.SERVER_URL
    }/survey/${survey_id}/fields/${field_id}?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        title,
        description,
        input_type_id
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : hello.js
📂 Pasta   : pages/api
🧭 Caminho : pages/api/hello.js
--------------------------------------
📜 Conteúdo:

// Next.js API route support: https://nextjs.org/docs/api-routes/introduction

export default function handler(req, res) {
  res.status(200).json({ name: "John Doe" });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/input_types
🧭 Caminho : pages/api/input_types/index.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const response = await fetch(`${process.env.SERVER_URL}/input_types`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
    });


    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    console.error("Erro ao buscar input_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/[id].js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";


const BASE_URL = process.env.SERVER_URL || "http://localhost:8000";

async function fetchWithAuth(url, token) {
  const res = await fetch(url, {
    method: "GET",
    headers: {
      Authorization: `Bearer ${token}`,
    },
  });

  const data = await res.json();
  return { ok: res.ok, status: res.status, data };
}

async function getResearchDetails(id, token) {
  const { ok, status, data } = await fetchWithAuth(`${BASE_URL}/research/${id}`, token);
  if (!ok) {
    throw { status, message: "Erro ao buscar dados da pesquisa", details: data };
  }
  return data.research;
}

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Método não permitido" });
  }

  const {
    query: { id },
  } = req;

  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  try {
    const [research] = await Promise.all([
      getResearchDetails(id, token)
    ]);

    return res.status(200).json({research});
  } catch (error) {
    console.error("Erro ao buscar dados da pesquisa:", error);
    return res
      .status(error.status || 500)
      .json({ error: error.message || "Erro interno", details: error.details });
  }
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const BASE_URL = process.env.SERVER_URL;

async function createResearch(researchData, token) {
  const researchRes = await fetch(`${BASE_URL}/research`, {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      Authorization: `Bearer ${token}`,
    },
    body: JSON.stringify(researchData),
  });

  const data = await researchRes.json();

  if (!researchRes.ok) {
    throw {
      status: researchRes.status,
      message: "Erro ao criar a pesquisa",
      details: data,
    };
  }

  return data.research;
}

async function addCollaborator(researchId, collaboratorId, token) {
  const contributorRes = await fetch(
    `${BASE_URL}/research/${researchId}/contributors/${collaboratorId}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ instruction: "Pesquisador" }),
    }
  );

  const data = await contributorRes.json();

  if (!contributorRes.ok) {
    throw {
      status: contributorRes.status,
      message: `Erro ao adicionar colaborador`,
      details: data,
    };
  }

  return data.user;
}

async function addCollaborators(researchId, collaborators, token) {
  const contributors = [];
  
  for (const collaborator of collaborators) {
    try {
      const contributor = await addCollaborator(researchId, collaborator.id, token);
      contributors.push(contributor);
    } catch (error) {
      throw {
        ...error,
        message: `Erro ao adicionar colaborador ${collaborator.label}`,
      };
    }
  }

  return contributors;
}

function validateRequest(req) {
  const cookies = parse(req.headers.cookie || "");
  const token = cookies.token;

  if (!token) {
    throw {
      status: 401,
      message: "Token não fornecido",
    };
  }

  const created_by = req.headers["x-user-id"] || req.body.created_by;

  if (!created_by) {
    throw {
      status: 400,
      message: "ID do criador não fornecido.",
    };
  }

  return { token, created_by };
}

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Método não permitido" });
  }

  try {
    const { token, created_by } = validateRequest(req);

    const {
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title,
      selectedCollaborators,
    } = req.body;

    const researchPayload = {
      title,
      description,
      release_date: release_date,
      end_date: end_date,
      lat,
      long,
      location_title,
      created_by,
    };

    var research = await createResearch(researchPayload, token);
    var contributors = await addCollaborators(research.id, selectedCollaborators, token);

    research.selectedCollaborators = contributors;
    research.activities = [];

    return res.status(201).json({
      message: "Pesquisa criada e colaboradores adicionados com sucesso!",
      research,
    });
  } catch (error) {
    console.error("Erro interno:", error);
    return res.status(error.status || 500).json({
      error: error.message || "Erro interno no servidor",
      details: error.details,
    });
  }
}






============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/delete.js
--------------------------------------
📜 Conteúdo:

// deleteResearch.js

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    // Obtém o token do cookie
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { id } = req.body;

    if (!id) {
      return res.status(400).json({ error: "ID é obrigatório para deletar a pesquisa." });
    }

    // Envia a requisição para o backend para deletar a pesquisa
    const response = await fetch(`${process.env.SERVER_URL}/research/${id}`, {
      method: "DELETE",
      headers: {
        "Authorization": `Bearer ${token}`,
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    return res.status(200).json({ message: "Pesquisa deletada com sucesso." });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET" && req.method !== "POST") {
    return res.status(405).json({ error: "Método não permitido" });
  }
  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  if (req.method === "GET") {
    try {
      const response = await fetch(`${process.env.SERVER_URL}/research/`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
      });

      const data = await response.json();

      if (!response.ok) {
        return res.status(response.status).json(data);
      }

      return res.status(200).json(data);
    } catch (err) {
      console.error("Erro ao buscar pesquisas:", err);
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }

  // Caso o método seja POST, cria uma nova pesquisa
  if (req.method === "POST") {
    const { titulo, descricao, data_criacao } = req.body;

    if (!titulo || !descricao || !data_criacao) {
      return res.status(400).json({ error: "Dados inválidos: título, descrição e data_criacao são obrigatórios" });
    }

    try {
      const response = await fetch(`${process.env.SERVER_URL}/research/`, {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "Authorization": `Bearer ${token}`,
        },
        body: JSON.stringify({
          titulo,
          descricao,
          data_criacao,
        }),
      });

      const data = await response.json();

      if (!response.ok) {
        return res.status(response.status).json(data);
      }

      return res.status(201).json(data);
    } catch (err) {
      console.error("Erro ao criar pesquisa:", err);
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  }
}


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/researches
🧭 Caminho : pages/api/researches/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

// Função para atualizar a pesquisa
async function updateResearch(token, researchId, researchData) {
  const response = await fetch(
    `${process.env.SERVER_URL}/research/${researchId}`,
    {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify(researchData),
    }
  );
  return response;
}

// Função para adicionar um colaborador
async function addCollaborator(token, researchId, userId) {
  const response = await fetch(
    `${process.env.SERVER_URL}/research/${researchId}/contributors/${userId}`,
    {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        instruction: "Pesquisador"
      }),
    }
  );

  return response;
}

// Função para remover um colaborador
async function removeCollaborator(token, researchId, userId) {
  const response = await fetch(
    `${process.env.SERVER_URL}/research/${researchId}/contributors/${userId}`,
    {
      method: "DELETE",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
    }
  );
  return response;
}

// Função que processa os arrays de colaboradores a adicionar e remover
async function processCollaborators(
  token,
  researchId,
  collaboratorsToAdd = [],
  collaboratorsToRemove = []
) {
  // Processa adição dos colaboradores
  const addPromises = collaboratorsToAdd.map((collab) =>
    addCollaborator(token, researchId, collab.id)
  );
  const addResponses = await Promise.all(addPromises);

  // Processa remoção dos colaboradores
  const removePromises = collaboratorsToRemove.map((collab) =>
    removeCollaborator(token, researchId, collab.id)
  );
  const removeResponses = await Promise.all(removePromises);

  return { addResponses, removeResponses };
}

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    // Obtém o token do cookie
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      id,
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title,
      selectedCollaborators, // Array de colaboradores já selecionados
      collaboratorsToAdd, // Array de colaboradores a serem adicionados
      collaboratorsToRemove, // Array de colaboradores a serem removidos
    } = req.body;

    // Validação básica dos campos obrigatórios
    if (
      !id ||
      !title ||
      !description ||
      !release_date ||
      !lat ||
      !long ||
      !location_title
    ) {
      return res
        .status(400)
        .json({ error: "Todos os campos obrigatórios devem ser preenchidos." });
    }

    // Dados para atualização da pesquisa
    const researchData = {
      title,
      description,
      release_date,
      end_date,
      lat,
      long,
      location_title,
    };

    // Atualiza a pesquisa
    const updateResponse = await updateResearch(token, id, researchData);
    if (!updateResponse.ok) {
      const errorData = await updateResponse.json();
      return res.status(updateResponse.status).json(errorData);
    }
    const updatedResearch = await updateResponse.json();

    // Inicializa arrays para os resultados finais
    let finalSelectedCollaborators = [...selectedCollaborators];
    let finalCollaboratorsToAdd = collaboratorsToAdd
      ? [...collaboratorsToAdd]
      : [];
    let finalCollaboratorsToRemove = collaboratorsToRemove
      ? [...collaboratorsToRemove]
      : [];

    // Processa colaboradores, se houver arrays de adição ou remoção
    if (
      (collaboratorsToAdd && collaboratorsToAdd.length) ||
      (collaboratorsToRemove && collaboratorsToRemove.length)
    ) {
      const { addResponses, removeResponses } = await processCollaborators(
        token,
        id,
        collaboratorsToAdd,
        collaboratorsToRemove
      );

      // Arrays para armazenar os que tiveram sucesso e os que falharam
      const successfulAdd = [];
      const failedAdd = [];
      for (let i = 0; i < addResponses.length; i++) {
        if (addResponses[i].ok) {
          successfulAdd.push(collaboratorsToAdd[i]);
        } else {
          failedAdd.push(collaboratorsToAdd[i]);
          const errData =await addResponses[i].json();
          console.error("Erro ao adicionar colaborador:", errData);
        }
      }

      const successfulRemove = [];
      const failedRemove = [];
      for (let i = 0; i < removeResponses.length; i++) {
        if (removeResponses[i].ok) {
          successfulRemove.push(collaboratorsToRemove[i]);
        } else {
          failedRemove.push(collaboratorsToRemove[i]);
          const errData = await removeResponses[i].json();
          console.error("Erro ao remover colaborador:", errData);
        }
      }

      // Atualiza o array de colaboradores selecionados:
      // Remove os que foram removidos com sucesso
      if (successfulRemove.length) {
        finalSelectedCollaborators = finalSelectedCollaborators.filter(
          (collab) => !successfulRemove.some((rem) => rem.id === collab.id)
        );
      }

      successfulAdd.forEach((collab) => {
        if (!finalSelectedCollaborators.some((c) => c.id === collab.id)) {
          finalSelectedCollaborators.push(collab);
        }
      });

      finalCollaboratorsToAdd = failedAdd;
      finalCollaboratorsToRemove = failedRemove;
    }

    const finalData = {
      ...updatedResearch,
      selectedCollaborators: finalSelectedCollaborators,
      collaboratorsToAdd: finalCollaboratorsToAdd,
      collaboratorsToRemove: finalCollaboratorsToRemove,
    };

    return res.status(200).json(finalData);
  } catch (err) {
    console.error("Erro no handler:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/survey-answers
🧭 Caminho : pages/api/survey-answers/[id].js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const { id } = req.query;

  if (!id || typeof id !== 'string') return res.status(400).json({ error: 'ID inválido' });

  const url = `${process.env.API_BASE_URL}/survey-answers/${id}`;

  try {
    if (req.method === 'GET') {
      const response = await fetch(url);
      const data = await response.json();
      return res.status(200).json(data);
    }

    if (req.method === 'PUT') {
      const response = await fetch(url, {
        method: 'PUT',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    }

    if (req.method === 'DELETE') {
      const response = await fetch(url, {
        method: 'DELETE',
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    }

    return res.status(405).json({ error: 'Método não permitido' });
  } catch (error) {
    return res.status(500).json({ error: 'Erro ao processar a requisição' });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-answers
🧭 Caminho : pages/api/survey-answers/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  if (req.method === 'GET') {
    try {
      const response = await fetch(`${process.env.API_BASE_URL}/survey-answers`);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar respostas da survey' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(`${process.env.API_BASE_URL}/survey-answers`, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar resposta da survey' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-groups
🧭 Caminho : pages/api/survey-groups/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/survey-groups`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar grupos de survey' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar grupo' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-regions
🧭 Caminho : pages/api/survey-regions/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/survey-regions`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar regiões' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar região' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey-time-ranges
🧭 Caminho : pages/api/survey-time-ranges/index.js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
  const baseUrl = `${process.env.API_BASE_URL}/survey-time-ranges`;

  if (req.method === 'GET') {
    try {
      const response = await fetch(baseUrl);
      const data = await response.json();
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao buscar faixas de horário' });
    }
  }

  if (req.method === 'POST') {
    try {
      const response = await fetch(baseUrl, {
        method: 'POST',
        headers: { 'Content-Type': 'application/json' },
        body: JSON.stringify(req.body),
      });
      const data = await response.json();
      return res.status(response.status).json(data);
    } catch (err) {
      return res.status(500).json({ error: 'Erro ao criar faixa de horário' });
    }
  }

  return res.status(405).json({ error: 'Método não permitido' });
}


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/survey_contributors
🧭 Caminho : pages/api/survey_contributors/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  try {
    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { survey_id, survey_type, user_id, instruction } = req.body;
    if (!survey_id || !survey_type || !user_id || !instruction) {
      return res
        .status(400)
        .json({ error: "survey_id e survey_type são obrigatórios" });
    }
    const response = await fetch(
      `${process.env.SERVER_URL}/survey/${survey_id}/contributors`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          survey_type: survey_type,
          user_id: user_id,
          instruction: instruction,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    if (!data) {
      return res.status(404).json({ error: "Erro ao adicionar um contribuidor à coleta." });
    }

    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

export default handler;


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/survey_contributors
🧭 Caminho : pages/api/survey_contributors/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
    try {
      if (req.method !== "DELETE") {
        return res.status(405).json({ error: "Method not allowed" });
      }
      const cookies = parse(req.headers.cookie || "");
      const token = cookies.token;
      if (!token) {
        return res.status(401).json({ error: "Token não fornecido" });
      }
  
      const { survey_id, survey_type, user_id } = req.body;
      if (!survey_id || !survey_type || !user_id) {
        return res
          .status(400)
          .json({ error: "survey_id e survey_type são obrigatórios" });
      }
      const response = await fetch(
        `${process.env.SERVER_URL}/survey/${survey_id}/contributors/${user_id}`,
        {
          method: "POST",
          headers: {
            "Content-Type": "application/json",
            Authorization: `Bearer ${token}`,
          },
          body: JSON.stringify({
            survey_type: survey_type,
          }),
        }
      );
  
      if (!response.ok) {
        const errorData = await response.json();
        return res.status(response.status).json(errorData);
      }
      const data = await response.json();
      if (!data) {
        return res.status(404).json({ error: "Erro ao deletar um contribuidor da coleta." });
      }
      return res.status(200).json(data);
    } catch (err) {
      return res.status(500).json({ error: "Erro ao conectar com o servidor" });
    }
  };
  
  export default handler;
  

============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/survey_contributors
🧭 Caminho : pages/api/survey_contributors/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  try {
    if (req.method !== "GET") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { survey_id, survey_type } = req.body;
    if (!survey_id || !survey_type) {
      return res
        .status(400)
        .json({ error: "survey_id e survey_type são obrigatórios" });
    }
    const response = await fetch(
      `${process.env.SERVER_URL}/survey/${survey_id}/contributors`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          survey_type: survey_type,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    if (!data) {
      return res.status(404).json({ error: "Nenhum dado encontrado" });
    }

    return res.status(200).json(data);
  } catch (err) {
    console.error("Erro ao buscar activity_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

export default handler;


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/[id].js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const { survey_id, research_id, survey_type } = req.query;
    let missingFields = checkMissingFields([
      survey_id,
      research_id,
      survey_type,
    ]);

    if (missingFields.length > 0) {
      return res
        .status(400)
        .json({ error: `Os campos são obrigatórios: ${missingFields}` });
    }

    const response = await fetch(
      `${process.env.SERVER_URL}/research/${research_id}/survey/${survey_id}?survey_type=${encodeURIComponent(survey_type)}`,
      {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);
  } catch (err) {
    console.error("Erro ao buscar activity_types:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ["survey_type", "survey_id", "research_id"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/create.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  try {

    if (req.method !== "POST") {
      return res.status(405).json({ error: "Method not allowed" });
    }
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;
    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    
    const {survey_type, title, description, lat, long, location_title, research_id} = req.body;
    let missingFields = checkMissingFields({
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id,
    });




    if (missingFields.length > 0) {
      return res
        .status(400)
        .json({ error: `Os campos são obrigatórios: ${missingFields}` });
    }
    const response = await fetch(
      `${process.env.SERVER_URL}/survey?survey_type=${encodeURIComponent(survey_type)}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
        body: JSON.stringify({
          title: title,
          description: description,
          lat: lat,
          long: long,
          location_title: location_title,
          research_id: research_id,
        }),
      }
    );

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }
    const data = await response.json();
    if (!data) {
      return res.status(404).json({ error: "Erro ao adicionar um contribuidor à coleta." });
    }
    return res.status(200).json(data);
  } catch (err) {
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};


const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "survey_type", "title", "description", "lat", "long", "location_title", "research_id"
  ];

  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/delete.js
--------------------------------------
📜 Conteúdo:

import { parse } from 'cookie';

const handler = async (req, res) => {
  if (req.method !== 'DELETE') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    const cookies = parse(req.headers.cookie || '');
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: 'Token não fornecido' });
    }

    const { survey_id, research_id, survey_type } = req.body;

    const missingFields = checkMissingFields({ survey_id, research_id, survey_type });
    if (missingFields.length > 0) {
      return res.status(400).json({ error: `Os campos são obrigatórios: ${missingFields.join(', ')}` });
    }

    const response = await fetch(`${process.env.SERVER_URL}/research/${research_id}/survey/${survey_id}?survey_type=${encodeURIComponent(survey_type)}`, {
      method: 'DELETE',
      headers: {
        'Authorization': `Bearer ${token}`,
        'Content-Type': 'application/json',
      },
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    return res.status(200).json({ message: 'Survey deletado com sucesso' });
  } catch (err) {
    console.error('Erro ao deletar survey:', err);
    return res.status(500).json({ error: 'Erro ao conectar com o servidor' });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ['survey_id', 'research_id', 'survey_type'];
  return requiredFields.filter(field => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }
    
    const { research_id, survey_type } = req.query;

    const missingFields = checkMissingFields({ research_id, survey_type });
    if (missingFields.length > 0) {
      return res.status(400).json({
        error: `Os campos são obrigatórios: ${missingFields.join(", ")}`,
      });
    }

    const url = `${process.env.SERVER_URL}/research/${research_id}/survey?survey_type=${encodeURIComponent(survey_type)}`;

    const response = await fetch(url, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      }
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    console.error("Erro ao buscar surveys:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = ["research_id", "survey_type"];
  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/surveys
🧭 Caminho : pages/api/surveys/update.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

const handler = async (req, res) => {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  try {
    const cookies = parse(req.headers.cookie || "");
    const token = cookies.token;

    if (!token) {
      return res.status(401).json({ error: "Token não fornecido" });
    }

    const {
      survey_id,
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id
    } = req.body;

    const missingFields = checkMissingFields({
      survey_id,
      survey_type,
      title,
      description,
      lat,
      long,
      location_title,
      research_id,
    });

    if (missingFields.length > 0) {
      return res.status(400).json({ error: `Os campos são obrigatórios: ${missingFields.join(', ')}` });
    }

    const response = await fetch(`${process.env.SERVER_URL}/survey/${survey_id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({
        survey_type,
        title,
        description,
        lat,
        long,
        location_title,
        research_id,
      }),
    });

    if (!response.ok) {
      const errorData = await response.json();
      return res.status(response.status).json(errorData);
    }

    const data = await response.json();
    return res.status(200).json(data);

  } catch (err) {
    console.error("Erro ao atualizar o survey:", err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
};

const checkMissingFields = (dataObj) => {
  const requiredFields = [
    "survey_id",
    "survey_type",
    "title",
    "description",
    "lat",
    "long",
    "location_title",
    "research_id"
  ];

  return requiredFields.filter((field) => !dataObj[field]);
};

export default handler;


============================================================


📄 Arquivo : sync.js
📂 Pasta   : pages/api
🧭 Caminho : pages/api/sync.js
--------------------------------------
📜 Conteúdo:

// pages/api/sync.js
import { createClient } from '@supabase/supabase-js';

const supabaseUrl = process.env.NEXT_PUBLIC_SUPABASE_URL;
const supabaseKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;
const supabase = createClient(supabaseUrl, supabaseKey);

export default async function handler(req, res) {
  if (req.method === 'POST') {
    const { names } = req.body;

    if (!names || !Array.isArray(names)) {
      console.error("Erro: 'names' não é um array válido:", names);
      return res.status(400).json({ message: 'Dados inválidos: "names" deve ser array' });
    }

    try {
      const { data, error } = await supabase
        .from('names')
        .insert(names.map((name) => ({ name })));

      if (error) {
        console.error("Erro ao salvar no Supabase:", error);
        return res.status(500).json({ message: 'Erro ao salvar no Supabase', error });
      }

      return res.status(200).json({ message: 'Nomes sincronizados com sucesso', data });
    } catch (err) {
      console.error("Exceção ao inserir dados no Supabase:", err);
      return res.status(500).json({ message: 'Erro de servidor', error: err });
    }
  }

  if (req.method === 'GET') {
    try {
      const { data, error } = await supabase
        .from('names')
        .select('*')
        .order('id', { ascending: true });

      if (error) {
        console.error("Erro ao buscar dados do Supabase:", error);
        return res.status(500).json({ message: 'Erro ao buscar dados do Supabase', error });
      }

      return res.status(200).json(data);
    } catch (err) {
      console.error("Exceção ao buscar dados do Supabase:", err);
      return res.status(500).json({ message: 'Erro de servidor', error: err });
    }
  }

  // Caso o método não seja GET ou POST
  return res.status(405).json({ message: 'Método não permitido' });
}


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/[id].js
--------------------------------------
📜 Conteúdo:

export default async function handler(req, res) {
    if (req.method !== "GET") {
      return res.status(405).json({ error: "Method not allowed" });
    }
  
    const { id } = req.query;
  
    const token = req.cookies?.token;
    if (!token) return res.status(401).json({ error: "Token não encontrado" });
  
    try {
      const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
        method: "GET",
        headers: {
          "Content-Type": "application/json",
          Authorization: `Bearer ${token}`,
        },
      });
  
      const data = await response.json();
      if (!response.ok) {
        return res.status(response.status).json({ error: data.message || "Erro ao buscar usuário" });
      }
  
      return res.status(200).json({ user: data });
    } catch (err) {
      console.error("[GET /api/users/[id]]", err);
      return res.status(500).json({ error: "Erro interno ao buscar usuário" });
    }
  }
  

============================================================


📄 Arquivo : delete.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/delete.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "DELETE") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { id } = req.body;

  if (!id) {
    return res.status(400).json({ error: "ID do usuário não fornecido" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
      method: "DELETE",
      headers: {
        Authorization: `Bearer ${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data);
  } catch (err) {
    console.error("[delete]", err);
    return res.status(500).json({ error: "Erro ao deletar usuário" });
  }
}


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/index.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "GET") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/`, {
      method: "GET",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : register.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/register.js
--------------------------------------
📜 Conteúdo:

import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "POST") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { name, email, confirmation_email, role, status } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/auth/register`, {
      method: "POST",
      headers: {
        "Content-Type": "application/json",
        "Authorization": `Bearer ${token}`,
      },
      body: JSON.stringify({ name, email, confirmation_email, role, status }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }

    return res.status(200).json(data);
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "Erro ao conectar com o servidor" });
  }
}


============================================================


📄 Arquivo : update.js
📂 Pasta   : pages/api/users
🧭 Caminho : pages/api/users/update.js
--------------------------------------
📜 Conteúdo:


import { parse } from "cookie";

export default async function handler(req, res) {
  if (req.method !== "PUT") {
    return res.status(405).json({ error: "Method not allowed" });
  }

  const cookies = req.headers.cookie ? parse(req.headers.cookie) : {};
  const token = cookies.token;

  if (!token) {
    return res.status(401).json({ error: "Token não fornecido" });
  }

  const { id, name, email, role, status } = req.body;

  try {
    const response = await fetch(`${process.env.SERVER_URL}/users/${id}`, {
      method: "PUT",
      headers: {
        "Content-Type": "application/json",
        Authorization: `Bearer ${token}`,
      },
      body: JSON.stringify({ name, email, role, status }),
    });

    const data = await response.json();

    if (!response.ok) {
      return res.status(response.status).json(data);
    }


    return res.status(200).json(data);
  } catch (err) {

    console.error("[update]", err);
    return res.status(500).json({ error: "Erro ao atualizar usuário" });
  }
}


============================================================


📄 Arquivo : forgot-password.js
📂 Pasta   : pages
🧭 Caminho : pages/forgot-password.js
--------------------------------------
📜 Conteúdo:

import { useState } from "react";
import Image from "next/image";
import Button from "@/components/ui/Button";
import { motion } from "framer-motion";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import Link from "next/link";
import { useRouter } from "next/router"; 

export default function ForgotPassword() {
  const [email, setEmail] = useState("");
  const { showMessage } = useMessage();
  const { isLoading, setIsLoading } = useLoading();
  const router = useRouter();

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const response = await fetch("/api/auth/forgot-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || "Erro ao enviar email");
      }

      showMessage(
        "Se o email estiver cadastrado, você receberá o código para recuperar sua senha.",
        "verde"
      );
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 10000);
    } finally {
      setIsLoading(false);
      localStorage.setItem("recover_email", email);
      router.push("/validate-code"); 
    }
  };

  return (
    <div
      className="h-screen flex items-center justify-center p-8 bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken"
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <h2 className="text-xl font-semibold text-center text-gray-800 mb-4">
          Recuperar Senha
        </h2>

        <form className="space-y-4" onSubmit={handleSubmit}>
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              inputMode="email"
              autoComplete="email"
              className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="seu@email.com"
              required
            />
          </div>
          <div className="flex justify-end p-2">
            <Link
              href="/login"
              className="text-sm text-blue-500 hover:underline"
            >
              Login?
            </Link>
          </div>

          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Enviando..." : "Enviar"}
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

ForgotPassword.pageName = "Recuperar Senha";
ForgotPassword.layout = "public";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages
🧭 Caminho : pages/index.js
--------------------------------------
📜 Conteúdo:

export default function Home() {

  return (
    <div>
      <h1>Home</h1>
    </div>
  );
  
}

Home.layout = "private";
Home.pageName = "Home";

============================================================


📄 Arquivo : login.js
📂 Pasta   : pages
🧭 Caminho : pages/login.js
--------------------------------------
📜 Conteúdo:

import { use, useState } from "react";
import Button from "@/components/ui/Button";
import Image from "next/image";
import { motion } from "framer-motion";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import Link from "next/link";
import { useRouter } from "next/router";
import { useAuth } from "@/context/AuthContext";

export default function Login() {
  const [email, setEmail] = useState("");
  const [password, setPassword] = useState("");
  const [showPassword, setShowPassword] = useState(false);
  const { isLoading, setIsLoading } = useLoading(false);
  const { showMessage } = useMessage();
  const { saveCredentials, saveUserInfo } = useAuth();
  const router = useRouter();

  const handleLogin = async (e) => {
    e.preventDefault();
    setIsLoading(true);

    try {
      const res = await fetch("/api/auth/login", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email, password }),
      });

      if (!res.ok) {
        const errorData = await res.json();
        throw new Error(errorData.message || "Erro ao fazer login");
      }

      const data = await res.json();
      

      const { token, token_type, expires_at } = data.access_token;

      await saveCredentials({
        access_token: token,
        token_type,
        expires_at,
      });

      await saveUserInfo(data.user);

      showMessage(data.message, "verde");
      router.push("/");
    } catch (err) {
      showMessage(err.message, "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div
      className="
      h-screen flex items-center justify-center p-8
      bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken
    "
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <form className="space-y-4" onSubmit={handleLogin}>
          <div>
            <label
              htmlFor="email"
              className="block text-sm font-medium text-gray-700"
            >
              Email
            </label>
            <input
              type="email"
              id="email"
              value={email}
              onChange={(e) => setEmail(e.target.value)}
              inputMode="email"
              autoComplete="email"
              autoCorrect="off"
              className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="seu@email.com"
              required
            />
          </div>

          <div>
            <label
              htmlFor="password"
              className="block text-sm font-medium text-gray-700"
            >
              Senha
            </label>
            <div className="relative">
              <input
                type={showPassword ? "text" : "password"}
                id="password"
                value={password}
                onChange={(e) => setPassword(e.target.value)}
                className="mt-1 block w-full px-4 py-3 text-lg border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500 pr-14"
                placeholder="********"
                required
              />
              <button
                type="button"
                onClick={() => setShowPassword(!showPassword)}
                className="absolute top-1/2 right-4 transform -translate-y-1/2 text-sm  hover:underline"
              >
                {showPassword ? "Ocultar" : "Mostrar"}
              </button>
            </div>
          </div>

          <div className="flex justify-end p-2">
            <Link
              href="/forgot-password"
              className="text-sm text-blue-500 hover:underline"
            >
              Esqueceu a senha?
            </Link>
          </div>
          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Entrando..." : "Entrar"}
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

Login.pageName = "Login";
Login.layout = "public";


============================================================


📄 Arquivo : offline.js
📂 Pasta   : pages
🧭 Caminho : pages/offline.js
--------------------------------------
📜 Conteúdo:

export default function HomeOffline() {
  return (
    <div style={{ textAlign: "center", padding: "20px" }}>
      <h1>Você está offline</h1>
      <p>Esta é uma versão offline do nosso site.</p>
      <p>Verifique sua conexão e tente novamente.</p>
    </div>
  );
}


============================================================


📄 Arquivo : reports.js
📂 Pasta   : pages
🧭 Caminho : pages/reports.js
--------------------------------------
📜 Conteúdo:



export default function Reports() {
    return (
        <div>
        <h1>Reports</h1>
        <p>This is the reports page.</p>
        </div>
    );
}

============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/researches
🧭 Caminho : pages/researches/[id].js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import ResearchForm from "@/components/research/ResearchForm";
import { useMessage } from "@/context/MessageContext";
import ResearchLoadingSkeleton from "@/components/research/ResearchLoadingSkeleton";
import SideBarSectionsFilter from "@/components/ui/SideBarSectionsFilter";
import CollectionFormSection from "@/components/surveys/CollectionFormSection";
import AddSurveyPrompt from "@/components/surveys/AddSurveyPrompt";

export default function EditResearch() {
  const router = useRouter();
  const { id } = router.query;
  const { showMessage } = useMessage();
  const [researchData, setResearchData] = useState(null);
  const [contributors, setContributors] = useState(null);
  const [users, setUsers] = useState([]);
  const [loading, setLoading] = useState(true);
  const [renderedSurveys, setRenderedSurveys] = useState([]);
  const [isCreatingSurvey, setIsCreatingSurvey] = useState(false);

  const SURVEY_TYPES = [
    { id: "formulario", label: "Formulário", icon: "description" },
    { id: "estatica", label: "Estática", icon: "insights" },
    { id: "dinamica", label: "Dinâmica", icon: "sync_alt" },
  ];

  useEffect(() => {
    if (!id) return;
    loadResearchData();
    loadContributors();
    loadAllSurveyTypes();
  }, [id]);

  useEffect(() => {
    loadUsers();
  }, []);

  const loadUsers = async () => {
    try {
      const res = await fetch("/api/users");
      const data = await res.json();
      const formatted = data.users?.map((u) => ({
        value: u.id,
        label: u.name,
        role: u.role,
        status: u.status,
        email: u.email,
      }));
      setUsers(formatted || []);
    } catch (err) {
      console.error("Erro ao buscar usuários:", err);
    }
  };

  const loadResearchData = async () => {
    setLoading(true);
    try {
      const res = await fetch(`/api/researches/${id}`);
      const data = await res.json();
      if (!data.research) {
        showMessage("Pesquisa não encontrada", "vermelho_claro", 5000);
        return;
      }
      setResearchData(data.research);
    } catch (err) {
      console.error("Erro ao buscar dados da pesquisa:", err);
    } finally {
      setLoading(false);
    }
  };

  const loadContributors = async () => {
    try {
      const res = await fetch(`/api/contributors?research_id=${id}`);
      const data = await res.json();
      if (!data) {
        showMessage("Colaboradores não encontrados", "vermelho_claro", 5000);
        return;
      }
      setContributors(data);
    } catch (err) {
      console.error("Erro ao buscar colaboradores:", err);
    }
  };

  const loadAllSurveyTypes = () => {
    SURVEY_TYPES.forEach(({ label }) => loadSurveyByType(label));
  };

  const loadSurveyByType = async (surveyType) => {
    try {
      const params = new URLSearchParams({
        research_id: id,
        survey_type: surveyType,
      });
      const res = await fetch(`/api/surveys?${params.toString()}`);
      const data = await res.json();

      if (!data.surveys || data.surveys.length === 0) return;

      renderSurveyComponent(surveyType, data);
    } catch (err) {
      console.error("Erro ao buscar survey do tipo", surveyType, err);
    }
  };

  const renderSurveyComponent = (surveyLabel, data) => {

    const surveyType = SURVEY_TYPES.find((t) => t.label === surveyLabel);
    const surveyData = data?.surveys[0] || null;
    if (!surveyType || renderedSurveys.find((s) => s.id === surveyType.id)) return;
    setRenderedSurveys((prev) => {
      return [
        ...prev,
        {
          ...surveyType,
          component: (
            <CollectionFormSection
              key={`survey-${surveyType.id}`}
              survey_type={surveyType.label}
              research_id={id}
              initialData={surveyData}
              handleCancelCreateSurvey={handleCancelCreateSurvey}
              handleCreateSurvey={handleCreateSurvey}
            />
          ),
        },
      ]
    });
  };

  const handleStartCreateSurvey = (selectedTypeId) => {
    const typeObj = SURVEY_TYPES.find((t) => t.id === selectedTypeId);
    if (!typeObj) return;

    renderSurveyComponent(typeObj.label, null);

    setTimeout(() => {
      const element = document.getElementById(`survey-${selectedTypeId}`);
      if (element) {
        element.scrollIntoView({ behavior: "smooth", block: "start" });
      }
    }, 300);

    setIsCreatingSurvey(true);
  };

  const handleCancelCreateSurvey = () => {
    setRenderedSurveys((prev) => prev.filter((s) => s.id !== "formulario"));
    setIsCreatingSurvey(false);
  };

  const handleResearchUpdate = async (payload) => {
    try {
      const release_date = payload.release_date
        ? `${payload.release_date}T00:00:00`
        : null;
      const end_date = payload.end_date ? `${payload.end_date}T00:00:00` : null;

      const finalPayload = { ...payload, id, release_date, end_date };

      const res = await fetch("/api/researches/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(finalPayload),
      });

      if (!res.ok) {
        throw new Error(`Falha ao atualizar pesquisa. Status: ${res.status}`);
      }

      const updated = await res.json();
      showMessage("Pesquisa atualizada com sucesso", "verde", 5000);
      router.reload();
    } catch (err) {
      console.error("Erro ao atualizar a pesquisa:", err);
      showMessage("Erro ao atualizar a pesquisa", "vermelho_claro", 5000);
    }
  };

  const handleCreateSurvey = async (payload) => {
    try {
      const res = await fetch("/api/surveys/create", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });

      const data = await res.json();
      if (!res.ok) {
        throw new Error(`Falha ao criar uma coleta. Status: ${res.status}`);
      }
      if (!data) {
        showMessage("Erro ao criar uma coleta", "vermelho_claro", 5000);
        return null;
      }
      showMessage("Coleta criada com sucesso", "verde", 5000);
      setIsCreatingSurvey(true);
      return data?.survey;
    } catch (err) {
      showMessage("Erro ao criar uma coleta", "vermelho_claro", 5000);
      return null;
    }
  };

  const handleSurveyUpdate = async (payload) => {
    try {
      const res = await fetch("/api/surveys/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(payload),
      });
      if (!res.ok) {
        throw new Error(`Falha ao atualizar a coleta. Status: ${res.status}`);
      }
      const data = await res.json();
      showMessage("Coleta atualizada com sucesso", "verde", 5000);
      router.reload();
    } catch (err) {
      console.error("Erro ao atualizar a coleta:", err);
      showMessage("Erro ao atualizar a coleta", "vermelho_claro", 5000);
    }
  };

  const handleSurveyDelete = async (surveyId) => {
    try {
      const res = await fetch(`/api/surveys/delete?survey_id=${surveyId}`, {
        method: "DELETE",
      });
      if (!res.ok) {
        throw new Error(`Falha ao deletar a coleta. Status: ${res.status}`);
      }
      const data = await res.json();
      showMessage("Coleta deletada com sucesso", "verde", 5000);
      router.reload();
    } catch (err) {
      console.error("Erro ao deletar a coleta:", err);
      showMessage("Erro ao deletar a coleta", "vermelho_claro", 5000);
    }
  };

  if (loading) return <ResearchLoadingSkeleton />;
  if (!researchData) {
    return (
      <div className="p-6 text-red-500">
        Não foi possível carregar a pesquisa.
      </div>
    );
  }

  const sidebarSections = [
    { id: "pesquisa", label: "Pesquisa", icon: "search" },
    ...SURVEY_TYPES,
  ];

  return (
    <div className="relative">
      <main className="p-4 sm:p-6 space-y-20 mb-20">
        <section id="pesquisa">
          <h2 className="text-xl font-bold mb-4">Pesquisa</h2>
          <ResearchForm
            isEdit
            initialData={researchData}
            contributorsData={contributors}
            users={users}
            onSubmit={handleResearchUpdate}
          />
        </section>

        {!isCreatingSurvey && (
          <section id="create-survey">
            <h2 className="text-xl font-bold mb-4">Criar coleta</h2>
            <AddSurveyPrompt onContinue={handleStartCreateSurvey} />
          </section>
        )}

        {renderedSurveys.map((survey) => (
          <section id={`survey-${survey.id}`} key={`survey-${survey.id}`}>
            <h2 className="text-xl font-bold mb-4">{survey.label}</h2>
            {survey.component}
          </section>
        ))}
      </main>

      <SideBarSectionsFilter sections={sidebarSections} position="right" />
    </div>
  );
}

EditResearch.layout = "private";
EditResearch.pageName = "Editar Pesquisa";

============================================================


📄 Arquivo : create.js
📂 Pasta   : pages/researches
🧭 Caminho : pages/researches/create.js
--------------------------------------
📜 Conteúdo:

import { useRouter } from "next/router";
import { useEffect, useState } from "react";
import ResearchForm from "@/components/research/ResearchForm";
import { initAuthDB } from "@/lib/db";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import { set } from "zod";

export default function CreateResearch() {
  const { showMessage } = useMessage();
  const { setIsLoading } = useLoading();
  const router = useRouter();
  const [users, setUsers] = useState([]);

  useEffect(() => { 
    fetchUsers();
  }, []);

  const fetchUsers = async () => {
    try {
      const res = await fetch("/api/users");
      const data = await res.json();

      const formatted = data.users?.map((c) => ({
        value: c.id,
        id: c.id,
        label: c.name,
        role: c.role,
        status: c.status,
        email: c.email,
      }));
      setUsers(formatted || []);
    } catch (error) {
      console.error("Erro ao buscar colaboradores:", error);
    }
  };
      
  
  const handleCreate = async (payload) => {
    setIsLoading(true);

    try {
      const db = await initAuthDB();
      const stored = await db.get("user-data", "user-data");
      const userId = stored?.user?.id;

      if (!userId) {
        showMessage("Usuário não encontrado", "vermelho", 5000);
        return;
      }

      const release_date = payload.release_date
        ? `${payload.release_date}T00:00:00`
        : null;
      const end_date = payload.end_date
        ? `${payload.end_date}T00:00:00`
        : null;

      const finalPayload = {
        ...payload,
        release_date,
        end_date,
        created_by: userId,
      };

      const res = await fetch("/api/researches/create", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
          "x-user-id": userId,
        },
        body: JSON.stringify(finalPayload),
      });

      const data = await res.json();

      if (!res.ok) {
        const message = data?.error || "Erro ao criar a pesquisa.";
        showMessage(message, "vermelho", 5000);
        return;
      }

      showMessage("Pesquisa criada com sucesso!", "verde", 4000);

      router.push(`/researches/${data.research.id}`);
    } catch (error) {
      console.error("Erro ao criar pesquisa:", error);
      showMessage("Erro interno ao criar pesquisa.", "vermelho", 5000);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="pb-20">
      <ResearchForm
        isEdit={false} 
        onSubmit={handleCreate}
        users={users}
      />
    </div>
  );
}

CreateResearch.layout = "private";
CreateResearch.pageName = "Criar Pesquisa";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/researches
🧭 Caminho : pages/researches/index.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useMemo, useCallback } from "react";
import { motion } from "framer-motion";
import { useRouter } from "next/router";
import Button from "@/components/ui/Button";
import FiltersComponent from "@/components/ui/FiltersComponent";
import ResearchCard from "@/components/ui/Research/ResearchCard";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import {
  getCachedData,
  syncLocalToServer,
  syncServerToCache,
} from "@/services/cache";
import { VARIANTS } from "@/config/colors";

export default function Researches() {
  const [researches, setResearches] = useState([]);
  const [filters, setFilters] = useState("");
  const [sortOrder, setSortOrder] = useState("asc");
  const [showCategory, setShowCategory] = useState({
    completed: true,
    ongoing: true,
    future: true,
  });
  const [page, setPage] = useState({
    completed: 1,
    ongoing: 1,
    future: 1,
  });
  const perPage = 3;
  const { isLoading, setIsLoading } = useLoading();
  const { showMessage } = useMessage();
  const router = useRouter();
  const [showFilters, setShowFilters] = useState(false);

const loadResearches = async () => {
  try {
    const res = await fetch("/api/researches");
    if (!res.ok) throw new Error("Network response was not ok");
    const json = await res.json();
    const list = Array.isArray(json) ? json : json.researches || [];
    setResearches(list);
  } catch (e) {
    console.error("Erro ao carregar pesquisas:", e);
    showMessage("Erro ao carregar pesquisas.", "vermelho_claro", 5000);
  }
};


  const loadCachedResearches = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await getCachedData("researches", { paginated: false });
      setResearches(result);
    } catch (err) {
      console.error("Erro ao carregar pesquisas do cache:", err);
      showMessage("Erro ao carregar pesquisas.", "vermelho_claro", 5000);
    } finally {
      setIsLoading(false);
    }
  }, [setIsLoading, showMessage]);

  
  useEffect(() => {
    loadResearches();
  }, []);

  
  const categorizedResearches = useMemo(() => {
    const currentDate = new Date();
    const list = Array.isArray(researches) ? researches : [];
    const cat = { completed: [], ongoing: [], future: [] };
    list.forEach((research) => {
      const endDate = new Date(research.end_date);
      const startDate = new Date(research.release_date);
  
      if (endDate < currentDate)      cat.completed.push(research);
      else if (startDate > currentDate) cat.future.push(research);
      else                              cat.ongoing.push(research);
    });
  
    return cat;
  }, [researches]);

  const filterAndSortResearches = (list) => {
    return list
      .filter(
        (research) =>
          research.title.toLowerCase().includes(filters.toLowerCase()) ||
          research.description.toLowerCase().includes(filters.toLowerCase()) ||
          research.location_title.toLowerCase().includes(filters.toLowerCase())
      )
      .sort((a, b) => {
        const aDate = a?.created_at ?? "";
        const bDate = b?.created_at ?? "";
        return sortOrder === "asc"
          ? aDate.localeCompare(bDate)
          : bDate.localeCompare(aDate);
      });
      
  };

  const handleSync = async () => {
    setIsLoading(true);
    try {
      await syncLocalToServer("researches");
      await syncServerToCache("researches");
      showMessage("Pesquisas sincronizadas com sucesso!", "azul_claro");
      // Atualiza a listagem no estado local
      loadCachedResearches();
    } catch (err) {
      console.error("Erro ao sincronizar pesquisas:", err);
      showMessage("Erro ao sincronizar pesquisas.", "vermelho_claro", 5000);
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-transparent">
      <main className="p-4 md:p-8 max-w-8xl mx-auto">
        <motion.section
          initial={{ opacity: 0, y: 20 }}
          animate={{ opacity: 1, y: 0 }}
          transition={{ duration: 0.4 }}
          className="bg-transparent rounded-2xl p-6 md:p-8"
        >
          <div className="flex flex-col md:flex-row md:justify-between md:items-center gap-4 mb-6">
            <h2 className="text-3xl font-bold text-gray-800">
              Gerenciar Pesquisas
            </h2>
            <Button
              onClick={handleSync}
              disabled={isLoading}
              className="w-full sm:w-fit self-start sm:self-auto px-4 py-2 transition flex items-center justify-center gap-2 text-sm"
              variant="secondary"
            >
              <span className="material-symbols-outlined text-base">sync</span>
              <span>Atualizar</span>
            </Button>
          </div>

          <FiltersComponent
            showFilters={showFilters}
            setShowFilters={setShowFilters}
            variants={VARIANTS}
            filters={[
              {
                key: "filters",
                label: "Buscar por título, descrição ou local",
                icon: "search",
                type: "text",
                value: filters,
                defaultValue: "",
              },
              {
                key: "sortOrder",
                label: "Ordenação",
                icon: "sort",
                type: "button-group",
                value: sortOrder,
                defaultValue: "asc",
                options: [
                  { label: "Mais Recentes", value: "asc" },
                  { label: "Mais Antigos", value: "desc" },
                ],
              },
              {
                key: "showCategory",
                label: "Mostrar categorias",
                type: "switch-group",
                options: [
                  {
                    label: "Pesquisas Já Realizadas",
                    value: "completed",
                    checked: showCategory.completed,
                  },
                  {
                    label: "Pesquisas em Andamento",
                    value: "ongoing",
                    checked: showCategory.ongoing,
                  },
                  {
                    label: "Pesquisas Futuras",
                    value: "future",
                    checked: showCategory.future,
                  },
                ],
              },
            ]}
            onChange={(key, value) => {
              if (key === "filters") setFilters(value);
              if (key === "sortOrder") setSortOrder(value);
              if (key === "showCategory") {
                setShowCategory((prev) => ({ ...prev, ...value }));
              }
            }}
            onClear={() => {
              setFilters("");
              setSortOrder("asc");
              setShowCategory({ completed: true, ongoing: true, future: true });
            }}
          />

          {Object.entries(categorizedResearches).map(([key, list]) => {
            if (!showCategory[key]) return null;

            const filteredAndSorted = filterAndSortResearches(list);
            const totalPages = Math.ceil(filteredAndSorted.length / perPage);

            const handlePrevious = () => {
              setPage((prev) => ({
                ...prev,
                [key]: Math.max(prev[key] - 1, 1),
              }));
            };

            const handleNext = () => {
              setPage((prev) => ({
                ...prev,
                [key]: Math.min(prev[key] + 1, totalPages),
              }));
            };

            return (
              <div key={key} className="mt-10">
                <h3 className="text-2xl font-semibold mb-4 text-gray-700">
                  {key === "completed"
                    ? "Pesquisas Já Realizadas"
                    : key === "ongoing"
                    ? "Pesquisas em Andamento"
                    : "Pesquisas Futuras"}
                </h3>
                {filteredAndSorted.length === 0 ? (
                  <p className="text-gray-500 text-sm">
                    Nenhuma pesquisa encontrada.
                  </p>
                ) : (
                  <motion.div
                    layout
                    className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-3 gap-6"
                  >
                    {filteredAndSorted
                      .slice((page[key] - 1) * perPage, page[key] * perPage)
                      .map((research) => (
                        <motion.div
                          key={research.id}
                          layout
                          initial={{ opacity: 0 }}
                          animate={{ opacity: 1 }}
                          transition={{ duration: 0.3 }}
                        >
                          <ResearchCard
                            research={research}
                            onViewDetails={() =>
                              router.push(`/researches/${research.id}`)
                            }
                          />
                        </motion.div>
                      ))}
                  </motion.div>
                )}

                {filteredAndSorted.length > perPage && (
                  <div className="flex items-center justify-between gap-6 mt-6">
                    <Button
                      onClick={handlePrevious}
                      disabled={page[key] === 1}
                      variant="secondary"
                      className="px-4 py-2 text-sm"
                    >
                      Anterior
                    </Button>
                    <span className="text-sm text-gray-70">
                      Página {page[key]} de {totalPages}
                    </span>
                    <Button
                      onClick={handleNext}
                      disabled={page[key] === totalPages}
                      variant="secondary"
                      className="px-4 py-2 text-sm"
                    >
                      Próxima
                    </Button>
                  </div>
                )}
                <hr className="my-6 border-gray-200" />
              </div>
            );
          })}
        </motion.section>
      </main>
    </div>
  );
}

Researches.pageName = "Gerenciar Pesquisas";
Researches.layout = "private";


============================================================


📄 Arquivo : [id].js
📂 Pasta   : pages/users
🧭 Caminho : pages/users/[id].js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import { useRouter } from "next/router";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import Button from "@/components/ui/Button";
import { useAuth } from "@/context/AuthContext";
import { formatDateToDDMMYY } from "@/utils/formatDate";
import {
  getCachedItemById,
  updateCachedItemById,
  syncCachedData,
} from "@/services/cache";

export default function Profile() {
  const { isLoading, setIsLoading } = useLoading(false);
  const { showMessage } = useMessage();
  const { userData, saveUserInfo } = useAuth();
  const router = useRouter();
  const { id: routeUserId } = router.query;

  const [showNewPassword, setShowNewPassword] = useState(false);
  const [form, setForm] = useState({
    id: "",
    name: "",
    email: "",
    status: "",
    role: "",
    created_at: "",
    updated_at: "",
  });
  const [passwordForm, setPasswordForm] = useState({
    new_password: "",
    confirm_password: "",
  });

  const isSelf = userData?.id === routeUserId;

  useEffect(() => {
    const loadFromCache = async () => {
      if (!routeUserId) return;

      try {
        const cachedUserData = await getCachedItemById("users", routeUserId);
        if (cachedUserData) {
          document.title = `${cachedUserData.name} - Perfil`;
          setForm({
            id: cachedUserData.id || "",
            name: cachedUserData.name || "",
            email: cachedUserData.email || "",
            status: cachedUserData.status || "",
            role: cachedUserData.role || "",
            created_at: formatDateToDDMMYY(cachedUserData.created_at),
            updated_at: formatDateToDDMMYY(cachedUserData.updated_at),
          });
        }
      } catch (err) {
        console.error("Erro ao carregar dados do cache:", err);
      }
    };

    loadFromCache();
  }, [routeUserId]);

  const handleSync = async () => {
    setIsLoading(true);
    try {
      await syncCachedData("users");

      const updated = await getCachedItemById("users", routeUserId);
      if (updated) {
        setForm({
          id: updated.id,
          name: updated.name,
          email: updated.email,
          status: updated.status,
          role: updated.role,
          created_at: formatDateToDDMMYY(updated.created_at),
          updated_at: formatDateToDDMMYY(updated.updated_at),
        });
      }

      showMessage("Dados sincronizados com sucesso!", "azul_claro");
    } catch (err) {
      showMessage("Erro ao sincronizar dados do servidor", "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  const handleChange = (e) => {
    const { name, value } = e.target;
    setForm((prev) => ({ ...prev, [name]: value }));
  };

  const handlePasswordChange = (e) => {
    const { name, value } = e.target;
    setPasswordForm((prev) => ({ ...prev, [name]: value }));
  };

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      const res = await fetch("/api/users/update", {
        method: "PUT",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(form),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Erro ao atualizar perfil");

      if (data.user) {
        if (isSelf) saveUserInfo(data.user);
        await updateCachedItemById("users", data.user.id, data.user);

        setForm((prev) => ({
          ...prev,
          updated_at: formatDateToDDMMYY(data.user.updated_at),
        }));

        showMessage("Perfil atualizado com sucesso!", "verde");
      }
    } catch (err) {
      showMessage(err.message, "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  const handlePasswordSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
    try {
      if (passwordForm.new_password !== passwordForm.confirm_password) {
        throw new Error("As senhas não coincidem");
      }

      const res = await fetch("/api/auth/change-password", {
        method: "POST",
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify(passwordForm),
      });

      const data = await res.json();
      if (!res.ok) throw new Error(data.error || "Erro ao atualizar senha");

      showMessage("Senha atualizada com sucesso!", "verde");
      setPasswordForm({ new_password: "", confirm_password: "" });
    } catch (err) {
      showMessage(err.message, "vermelho_claro");
    } finally {
      setIsLoading(false);
    }
  };

  return (
    <div className="min-h-screen bg-transparent">
      <main className="p-2 md:p-6 space-y-8 max-w-3xl mx-auto">
        <section className="bg-white p-6 rounded shadow space-y-4">
          <h2 className="text-xl font-semibold mb-4">Dados do Perfil</h2>
          <div className="grid grid-cols-1 md:grid-cols-2 gap-4 text-sm text-gray-700">
            <div>
              <span className="font-bold">Nome:</span>
              <p>{form.name}</p>
            </div>
            <div>
              <span className="font-bold">E-mail:</span>
              <p>{form.email}</p>
            </div>
            <div>
              <span className="font-bold">ID:</span>
              <p>{form.id}</p>
            </div>
            <div>
              <span className="font-bold">Status:</span>
              <p>{form.status}</p>
            </div>
            <div>
              <span className="font-bold">Papel:</span>
              <p>{form.role}</p>
            </div>
            <div>
              <span className="font-bold">Criado em:</span>
              <p>{form.created_at}</p>
            </div>
            <div>
              <span className="font-bold">Atualizado em:</span>
              <p>{form.updated_at}</p>
            </div>
          </div>

          <p className="text-xs text-gray-500 mb-4">
            Os dados podem estar desatualizados. Clique em “Atualizar” para
            sincronizar com o servidor.
          </p>
          <div className="flex items-center space-x-2 mb-4">
            <Button
              onClick={handleSync}
              disabled={isLoading}
              className="px-4 py-2 transition flex justify-evenly items-center gap-2"
              variant="dark"
            >
              <span className="material-symbols-outlined">sync</span>
              <span>Atualizar</span>
            </Button>
          </div>
        </section>

        {isSelf && (
          <>
            {/* Editar nome e e-mail */}
            <section className="bg-white p-6 rounded shadow space-y-4">
              <h2 className="text-xl font-semibold mb-4">Editar Informações</h2>
              <form onSubmit={handleSubmit} className="space-y-4">
                <input
                  type="text"
                  name="name"
                  placeholder="Nome"
                  value={form.name}
                  onChange={handleChange}
                  className="border p-2 rounded w-full"
                  required
                />
                <input
                  type="email"
                  name="email"
                  placeholder="E-mail"
                  value={form.email}
                  onChange={handleChange}
                  className="border p-2 rounded w-full"
                  required
                />
                <div className="flex justify-center">
                  <Button
                    type="submit"
                    variant="dark"
                    className="w-full max-w-60 text-md active:scale-95"
                    disabled={isLoading}
                  >
                    {isLoading ? "Salvando..." : "Salvar Alterações"}
                  </Button>
                </div>
              </form>
            </section>

            {/* Alterar senha */}
            <section className="bg-white p-6 rounded shadow space-y-4">
              <h2 className="text-xl font-semibold mb-4">Alterar Senha</h2>
              <form onSubmit={handlePasswordSubmit} className="space-y-4">
                <div className="relative">
                  <input
                    type={showNewPassword ? "text" : "password"}
                    name="new_password"
                    placeholder="Nova Senha"
                    value={passwordForm.new_password}
                    onChange={handlePasswordChange}
                    className="border p-2 rounded w-full pr-12"
                    required
                  />
                  <button
                    type="button"
                    onClick={() => setShowNewPassword((prev) => !prev)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-600"
                  >
                    {showNewPassword ? "Ocultar" : "Mostrar"}
                  </button>
                </div>
                <div className="relative">
                  <input
                    type={showNewPassword ? "text" : "password"}
                    name="confirm_password"
                    placeholder="Confirme a Nova Senha"
                    value={passwordForm.confirm_password}
                    onChange={handlePasswordChange}
                    className="border p-2 rounded w-full pr-12"
                    required
                  />
                  <button
                    type="button"
                    onClick={() => setShowNewPassword((prev) => !prev)}
                    className="absolute right-3 top-1/2 transform -translate-y-1/2 text-gray-600"
                  >
                    {showNewPassword ? "Ocultar" : "Mostrar"}
                  </button>
                </div>
                <div className="flex justify-center">
                  <Button
                    type="submit"
                    variant="dark"
                    className="w-full max-w-60 text-md active:scale-95"
                    disabled={isLoading}
                  >
                    {isLoading ? "Atualizando..." : "Alterar Senha"}
                  </Button>
                </div>
              </form>
            </section>
          </>
        )}
      </main>
    </div>
  );
}

Profile.layout = "private";


============================================================


📄 Arquivo : index.js
📂 Pasta   : pages/users
🧭 Caminho : pages/users/index.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect, useCallback } from "react";
import clsx from "clsx";
import Button from "@/components/ui/Button";
import ModalUser from "@/components/ui/ModalUser";
import ModalRegisterUser from "@/components/ui/ModalRegisterUser";
import { useLoading } from "@/context/LoadingContext";
import { useMessage } from "@/context/MessageContext";
import UserCard from "@/components/ui/UserCard";
import {
  getCachedData,
  syncLocalToServer,
  syncServerToCache,
} from "@/services/cache";
import { VARIANTS } from "@/config/colors";
import { USER_ROLES, USER_STATUS } from "@/config/data_types";
import { useAuth } from "@/context/AuthContext";
import FiltersComponent from "@/components/ui/FiltersComponent";

export default function Users() {
  const [users, setUsers] = useState([]);
  const [page, setPage] = useState(1);
  const [totalPages, setTotalPages] = useState(1);
  const perPage = 10;
  const [selectedUser, setSelectedUser] = useState(null);
  const [isRegisterOpen, setIsRegisterOpen] = useState(false);
  const { isLoading, setIsLoading } = useLoading();
  const { showMessage } = useMessage();
  const [showFilters, setShowFilters] = useState(false);
  const [searchTerm, setSearchTerm] = useState("");
  const [order, setOrder] = useState("desc");
  const [filterStatus, setFilterStatus] = useState("");
  const [filterRole, setFilterRole] = useState("");
  const { userData } = useAuth();

  const loadCachedUsers = useCallback(async () => {
    setIsLoading(true);
    try {
      const result = await getCachedData("users", {
        paginated: false,
        order,
        search: searchTerm,
        filterStatus,
        filterRole,
      });

      const filtered = result.filter((user) => user.id !== userData?.id);

      const total = filtered.length;
      const totalPagesCalc = Math.ceil(total / perPage);
      const start = (page - 1) * perPage;
      const paginatedUsers = filtered.slice(start, start + perPage);

      setUsers(paginatedUsers);
      setTotalPages(totalPagesCalc);
    } catch (err) {
      console.error("Erro ao carregar dados do cache:", err);
      showMessage("Erro ao carregar dados do cache.", "vermelho_claro", 5000);
    } finally {
      setIsLoading(false);
    }
  }, [
    page,
    perPage,
    order,
    searchTerm,
    filterStatus,
    filterRole,
    setIsLoading,
    showMessage,
    userData?.id,
  ]);

  useEffect(() => {
    loadCachedUsers();
  }, [loadCachedUsers]);

  const handleSync = async () => {
    setIsLoading(true);
    try {
      await syncLocalToServer("users");
      await syncServerToCache("users");
      showMessage("Dados sincronizados com sucesso!", "azul_claro");
      loadCachedUsers();
    } catch (err) {
      console.error("Erro ao sincronizar dados:", err);
      showMessage("Erro ao sincronizar dados.", "vermelho_claro", 5000);
    } finally {
      setIsLoading(false);
    }
  };

  const handlePrevious = () => {
    if (page > 1) setPage((prev) => prev - 1);
  };
  const handleNext = () => {
    if (page < totalPages) setPage((prev) => prev + 1);
  };

  const handleUserUpdated = (updatedUser) => {
    setUsers((prev) =>
      prev.map((u) => (u.id === updatedUser.id ? updatedUser : u))
    );
  };
  const handleUserDeleted = (userId) => {
    setUsers((prev) => prev.filter((u) => u.id !== userId));
  };

  const getBadgeVariant = (status) => {
    switch (status) {
      case "pendingCreate":
        return VARIANTS.azul_escuro;
      case "pendingUpdate":
        return VARIANTS.warning;
      case "pendingDelete":
        return VARIANTS.vermelho;
      default:
        return VARIANTS.verde;
    }
  };

  return (
    <div className="min-h-screen bg-gray-50">
      <main className="p-2 md:p-8 max-w-7xl mx-auto">
        {/* Botão de cadastro */}
        <div className="flex justify-end mb-4">
          {/* Botão completo para desktop */}
          <Button
            onClick={() => setIsRegisterOpen(true)}
            variant="dark"
            className="flex px-4 py-2 gap-2 items-center"
          >
            <span className="material-symbols-outlined">person_add</span>
            Cadastrar usuário
          </Button>
        </div>

        {/* Seção de Gerenciamento */}
        <section className="bg-white rounded-lg shadow p-6">
          <div className="flex flex-col md:flex-row md:items-center md:justify-between mb-4">
            <h2 className="text-2xl font-bold mb-2 md:mb-0">
              Usuários Cadastrados
            </h2>
          </div>
          <p className="text-xs text-gray-500 mb-4">
            Os dados podem estar desatualizados. Clique em “Atualizar” para
            sincronizar com o servidor.
          </p>
          <div className="flex items-center space-x-2 mb-4">
            <Button
              onClick={handleSync}
              disabled={isLoading}
              className="px-4 py-2 transition flex justify-evenly items-center gap-2"
              variant="dark"
            >
              <span className="material-symbols-outlined">sync</span>
              <span>Atualizar</span>
            </Button>
          </div>

          {/* Filtros expandíveis com animação leve */}
          <FiltersComponent
            showFilters={showFilters}
            setShowFilters={setShowFilters}
            variants={VARIANTS}
            mobilePosition="right"
            filters={[
              {
                key: "searchTerm",
                label: "Buscar por nome ou e-mail",
                icon: "search",
                type: "text",
                value: searchTerm,
                defaultValue: "",
              },
              {
                key: "order",
                label: "Ordem de cadastro",
                icon: "sort",
                type: "button-group",
                value: order,
                defaultValue: "desc",
                options: [
                  { label: "Mais novo", value: "desc" },
                  { label: "Mais velho", value: "asc" },
                ],
              },
              {
                key: "filterStatus",
                label: "Filtrar por status",
                icon: "flag",
                type: "button-group",
                value: filterStatus,
                defaultValue: "",
                options: [
                  { label: "Todos", value: "" },
                  ...USER_STATUS.map((s) => ({ label: s, value: s })),
                ],
              },
              {
                key: "filterRole",
                label: "Filtrar por papel",
                icon: "groups",
                type: "button-group",
                value: filterRole,
                defaultValue: "",
                options: [
                  { label: "Todos", value: "" },
                  ...USER_ROLES.map((r) => ({ label: r, value: r })),
                ],
              },
            ]}
            onChange={(key, value) => {
              if (key === "searchTerm") setSearchTerm(value);
              if (key === "order") setOrder(value);
              if (key === "filterStatus") setFilterStatus(value);
              if (key === "filterRole") setFilterRole(value);
            }}
            onClear={() => {
              setSearchTerm("");
              setOrder("desc");
              setFilterStatus("");
              setFilterRole("");
            }}
          />

          {users.length === 0 ? (
            <p className="text-gray-500">
              Nenhum usuário encontrado. Tente alterar os filtros ou clique em
              “Atualizar”.
            </p>
          ) : (
            <div className="grid grid-cols-1 sm:grid-cols-2 md:grid-cols-2 lg:grid-cols-4 gap-6">
              {users.map((u) => (
                <UserCard
                  key={u.id}
                  user={u}
                  onViewDetails={() => setSelectedUser(u)}
                />
              ))}
            </div>
          )}

          <div className="flex items-center justify-between mt-6">
            <Button
              onClick={handlePrevious}
              disabled={page === 1}
              className="disabled:opacity-80"
              variant="dark"
            >
              Anterior
            </Button>
            <span className="text-sm text-gray-700">
              Página {page} de {totalPages}
            </span>
            <Button
              onClick={handleNext}
              disabled={page === totalPages}
              className="disabled:opacity-80"
              variant="dark"
            >
              Próxima
            </Button>
          </div>
        </section>
      </main>

      <ModalUser
        isOpen={!!selectedUser}
        user={selectedUser}
        onClose={() => setSelectedUser(null)}
        onUserUpdated={handleUserUpdated}
        onUserDeleted={handleUserDeleted}
        showMessage={showMessage}
      />

      <ModalRegisterUser
        isOpen={isRegisterOpen}
        onClose={() => setIsRegisterOpen(false)}
        onUserCreated={(newUser) => setUsers((prev) => [...prev, newUser])}
        showMessage={showMessage}
      />
    </div>
  );
}

Users.pageName = "Gerenciar Usuários";
Users.layout = "private";


============================================================


📄 Arquivo : validate-code.js
📂 Pasta   : pages
🧭 Caminho : pages/validate-code.js
--------------------------------------
📜 Conteúdo:

import { useState, useEffect } from "react";
import Button from "@/components/ui/Button";
import Image from "next/image";
import { motion } from "framer-motion";
import { useMessage } from "@/context/MessageContext";
import { useLoading } from "@/context/LoadingContext";
import { useRouter } from "next/router";
import { useAuth } from "@/context/AuthContext";


export default function ValidateCode() {
  const [code, setCode] = useState("");
  const [email, setEmail] = useState("");
  const { showMessage } = useMessage();
  const { isLoading, setIsLoading } = useLoading();
  const router = useRouter();
  const { saveCredentials, saveUserInfo } = useAuth();
  

  useEffect(() => {
    const storedEmail = localStorage.getItem("recover_email");
    if (storedEmail) setEmail(storedEmail);
  }, []);

  const handleSubmit = async (e) => {
    e.preventDefault();
    setIsLoading(true);
  
    try {
      const response = await fetch("/api/auth/validate-code", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ code }),
      });
  
      const data = await response.json();
  
      if (!response.ok) {
        throw new Error(data.message || "Código inválido");
      }
  
      const { token, token_type, expires_at } = data.access_token;
  
      await saveCredentials({
        access_token: token,
        token_type,
        expires_at,
      });
  
      await saveUserInfo(data.user);
  
      showMessage(data.message, "verde");
      router.push("/profile");
  
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 7000);
      console.error("[handleSubmit]", err);
    } finally {
      setIsLoading(false);
    }
  };
  

  const handleResend = async () => {
    try {
      const response = await fetch("/api/auth/forgot-password", {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({ email }),
      });

      if (!response.ok) {
        const data = await response.json();
        throw new Error(data.message || "Erro ao reenviar código");
      }

      showMessage("Código reenviado com sucesso!", "verde");
    } catch (err) {
      showMessage(err.message, "vermelho_claro", 7000);
    }
  };

  return (
    <div
      className="h-screen flex items-center justify-center p-8 bg-no-repeat bg-cover bg-center bg-black bg-opacity-60 bg-blend-darken"
      style={{ backgroundImage: "url('/img/bg-login.jpg')" }}
    >
      <motion.div
        initial={{ opacity: 0, y: 30 }}
        animate={{ opacity: 1, y: 0 }}
        transition={{ duration: 0.6 }}
        className="w-full max-w-md bg-white p-6 rounded-3xl shadow-xl"
      >
        <div className="flex justify-center mb-4">
          <Image
            src="/img/logo-no-bg-azul.png"
            alt="Logo"
            width={200}
            height={100}
            className="object-contain"
          />
        </div>

        <h2 className="text-xl font-semibold text-center text-gray-800 mb-2">
          Verificar Código
        </h2>

        {email && (
          <p className="text-sm text-gray-600 text-center mb-4">
            Código enviado para: <span className="font-medium">{email}</span>. Verifique na caixa de spam ou na lixeira.
          </p>
        )}

        <form className="space-y-4" onSubmit={handleSubmit}>
          <div>
            <label htmlFor="code" className="block text-sm font-medium text-gray-700">
              Código de Verificação
            </label>
            <input
              type="text"
              id="code"
              value={code}
              onChange={(e) => setCode(e.target.value)}
              maxLength={8}
              className="mt-1 block w-full px-4 py-3 text-lg tracking-widest text-center border border-gray-300 rounded-xl shadow-sm focus:ring-blue-500 focus:border-blue-500"
              placeholder="XXXXXXXX"
              required
            />
          </div>
          <Button
            type="submit"
            variant="azul_escuro"
            className="w-full text-lg py-3 active:scale-95"
            disabled={isLoading}
          >
            {isLoading ? "Verificando..." : "Verificar"}
          </Button>

          <Button
            type="button"
            variant="azul_claro"
            className="w-full text-bg py-2 mt-2"
            onClick={handleResend}
          >
            Reenviar código
          </Button>
        </form>
      </motion.div>
    </div>
  );
}

ValidateCode.pageName = "Verificar Código";
ValidateCode.layout = "public";


============================================================


📄 Arquivo : activityAnswerRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/activityAnswerRepository.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/indexeddb/activityAnswerRepository.ts
import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { ActivityAnswer } from '@/lib/types/indexeddb';
  
  const store = 'activity_answers' as const;
  
  export async function createActivityAnswer(answer: ActivityAnswer) {
    return createItem(store, answer);
  }
  
  export async function getActivityAnswer(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllActivityAnswers() {
    return getAllItems(store);
  }
  
  export async function updateActivityAnswer(id: string, data: Partial<ActivityAnswer>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteActivityAnswer(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : dynamicSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/dynamicSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { DynamicSurvey } from '@/lib/types/indexeddb';
  
  const store = 'dynamic_surveys' as const;
  
  export async function createDynamicSurvey(data: DynamicSurvey) {
    return createItem(store, data);
  }
  
  export async function getDynamicSurvey(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllDynamicSurveys() {
    return getAllItems(store);
  }
  
  export async function updateDynamicSurvey(id: string, data: Partial<DynamicSurvey>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteDynamicSurvey(id: string) {
    return deleteItem(store, id);
  }

============================================================


📄 Arquivo : fieldOptionRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/fieldOptionRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { FieldOption } from '@/lib/types/indexeddb';
  
  const store = 'field_options' as const;
  
  export async function createFieldOption(data: FieldOption) {
    return createItem(store, data);
  }
  
  export async function getFieldOption(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFieldOptions() {
    return getAllItems(store);
  }
  
  export async function updateFieldOption(id: string, data: Partial<FieldOption>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteFieldOption(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : fieldRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/fieldRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { Field } from '@/lib/types/indexeddb';
  
  const store = 'fields' as const;
  
  export async function createField(field: Field) {
    return createItem(store, field);
  }
  
  export async function getField(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFields() {
    return getAllItems(store);
  }
  
  export async function updateField(id: string, data: Partial<Field>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteField(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : formSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/formSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { FormSurvey } from '@/lib/types/indexeddb';
  
  const store = 'form_surveys' as const;
  
  export async function createFormSurvey(data: FormSurvey) {
    return createItem(store, data);
  }
  
  export async function getFormSurvey(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllFormSurveys() {
    return getAllItems(store);
  }
  
  export async function updateFormSurvey(id: string, data: Partial<FormSurvey>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteFormSurvey(id: string) {
    return deleteItem(store, id);
  }

============================================================


📄 Arquivo : index.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/index.ts
--------------------------------------
📜 Conteúdo:

export * from './userRepository';
export * from './surveyAnswerRepository';
export * from './activityAnswerRepository';
export * from './fieldRepository';
export * from './researchRepository';
export * from './surveyTimeRangeRepository';
export * from './surveyRegionRepository';
export * from './surveyGroupRepository';
export * from './surveyContributorRepository';
export * from './staticSurveyRepository';
export * from './formSurveyRepository';
export * from './dynamicSurveyRepository';
export * from './researchContributorRepository';
export * from './inputTypeRepository';
export * from './fieldOptionRepository';


============================================================


📄 Arquivo : indexedDBService.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/indexedDBService.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/indexeddb/indexedDBService.ts
import { openDB, IDBPDatabase } from 'idb';
import type { StoreTypes } from '@/lib/types/indexeddb';

const DB_NAME = 'placemaking-db';
const DB_VERSION = 1;

let dbPromise: Promise<IDBPDatabase<any>> | null = null;

export function getDB(): Promise<IDBPDatabase<any>> {
  if (!dbPromise) {
    dbPromise = openDB(DB_NAME, DB_VERSION, {
      upgrade(db) {
        for (const store of Object.keys(storeSchema)) {
          if (!db.objectStoreNames.contains(store)) {
            db.createObjectStore(store, { keyPath: 'id' });
          }
        }
      },
    });
  }
  return dbPromise;
}

export const storeSchema: Record<keyof StoreTypes, { keyPath: keyof any }> = {
  users: { keyPath: 'id' },
  activity_answers: { keyPath: 'id' },
  fields: { keyPath: 'id' },
  researches: { keyPath: 'id' },
  survey_time_ranges: { keyPath: 'id' },
  survey_regions: { keyPath: 'id' },
  survey_group: { keyPath: 'id' },
  survey_contributors: { keyPath: 'id' },
  survey_answers: { keyPath: 'id' },
  static_surveys: { keyPath: 'id' },
  form_surveys: { keyPath: 'id' },
  dynamic_surveys: { keyPath: 'id' },
  research_contributors: { keyPath: 'id' },
  input_types: { keyPath: 'id' },
  field_options: { keyPath: 'id' },
};

export async function createItem<K extends keyof StoreTypes>(store: K, data: StoreTypes[K]): Promise<void> {
  const db = await getDB();
  await db.put(store, data);
}

export async function getItem<K extends keyof StoreTypes>(store: K, id: string): Promise<StoreTypes[K] | undefined> {
  const db = await getDB();
  return db.get(store, id);
}

export async function getAllItems<K extends keyof StoreTypes>(store: K): Promise<StoreTypes[K][]> {
  const db = await getDB();
  return db.getAll(store);
}

export async function updateItem<K extends keyof StoreTypes>(store: K, id: string, data: Partial<StoreTypes[K]>): Promise<void> {
  const db = await getDB();
  const current = await db.get(store, id);
  if (current) {
    await db.put(store, { ...current, ...data });
  }
}

export async function deleteItem<K extends keyof StoreTypes>(store: K, id: string): Promise<void> {
  const db = await getDB();
  await db.delete(store, id);
}


============================================================


📄 Arquivo : inputTypeRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/inputTypeRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { InputType } from '@/lib/types/indexeddb';
  
  const store = 'input_types' as const;
  
  export async function createInputType(data: InputType) {
    return createItem(store, data);
  }
  
  export async function getInputType(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllInputTypes() {
    return getAllItems(store);
  }
  
  export async function updateInputType(id: string, data: Partial<InputType>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteInputType(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : researchContributorRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/researchContributorRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { ResearchContributor } from '@/lib/types/indexeddb';
  
  const store = 'research_contributors' as const;
  
  export async function createResearchContributor(data: ResearchContributor) {
    return createItem(store, data);
  }
  
  export async function getResearchContributor(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllResearchContributors() {
    return getAllItems(store);
  }
  
  export async function updateResearchContributor(id: string, data: Partial<ResearchContributor>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteResearchContributor(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : researchRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/researchRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { Research } from '@/lib/types/indexeddb';
  
  const store = 'researches' as const;
  
  export async function createResearch(research: Research) {
    return createItem(store, research);
  }
  
  export async function getResearch(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllResearchs() {
    return getAllItems(store);
  }
  
  export async function updateResearch(id: string, data: Partial<Research>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteResearch(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : staticSurveyRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/staticSurveyRepository.ts
--------------------------------------
📜 Conteúdo:

import {
  createItem,
  getItem,
  getAllItems,
  updateItem,
  deleteItem,
} from './indexedDBService';
import type { StaticSurvey } from '@/lib/types/indexeddb';

const store = 'static_surveys' as const;

export async function createStaticSurvey(data: StaticSurvey) {
  return createItem(store, data);
}

export async function getStaticSurvey(id: string) {
  return getItem(store, id);
}

export async function getAllStaticSurveys() {
  return getAllItems(store);
}

export async function updateStaticSurvey(id: string, data: Partial<StaticSurvey>) {
  return updateItem(store, id, data);
}

export async function deleteStaticSurvey(id: string) {
  return deleteItem(store, id);
}

============================================================


📄 Arquivo : surveyAnswerRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyAnswerRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyAnswer } from '@/lib/types/indexeddb';
  
  const store = 'survey_answers' as const;
  
  export async function createSurveyAnswer(answer: SurveyAnswer) {
    return createItem(store, answer);
  }
  
  export async function getSurveyAnswer(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyAnswers() {
    return getAllItems(store);
  }
  
  export async function updateSurveyAnswer(id: string, data: Partial<SurveyAnswer>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyAnswer(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyContributorRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyContributorRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyContributor } from '@/lib/types/indexeddb';
  
  const store = 'survey_contributors' as const;
  
  export async function createSurveyContributor(data: SurveyContributor) {
    return createItem(store, data);
  }
  
  export async function getSurveyContributor(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyContributors() {
    return getAllItems(store);
  }
  
  export async function updateSurveyContributor(id: string, data: Partial<SurveyContributor>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyContributor(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyGroupRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyGroupRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyGroup } from '@/lib/types/indexeddb';
  
  const store = 'survey_group' as const;
  
  export async function createSurveyGroup(data: SurveyGroup) {
    return createItem(store, data);
  }
  
  export async function getSurveyGroup(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyGroups() {
    return getAllItems(store);
  }
  
  export async function updateSurveyGroup(id: string, data: Partial<SurveyGroup>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyGroup(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyRegionRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyRegionRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyRegion } from '@/lib/types/indexeddb';
  
  const store = 'survey_regions' as const;
  
  export async function createSurveyRegion(data: SurveyRegion) {
    return createItem(store, data);
  }
  
  export async function getSurveyRegion(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyRegions() {
    return getAllItems(store);
  }
  
  export async function updateSurveyRegion(id: string, data: Partial<SurveyRegion>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyRegion(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : surveyTimeRangeRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/surveyTimeRangeRepository.ts
--------------------------------------
📜 Conteúdo:

import {
    createItem,
    getItem,
    getAllItems,
    updateItem,
    deleteItem,
  } from './indexedDBService';
  import type { SurveyTimeRange } from '@/lib/types/indexeddb';
  
  const store = 'survey_time_ranges' as const;
  
  export async function createSurveyTimeRange(data: SurveyTimeRange) {
    return createItem(store, data);
  }
  
  export async function getSurveyTimeRange(id: string) {
    return getItem(store, id);
  }
  
  export async function getAllSurveyTimeRanges() {
    return getAllItems(store);
  }
  
  export async function updateSurveyTimeRange(id: string, data: Partial<SurveyTimeRange>) {
    return updateItem(store, id, data);
  }
  
  export async function deleteSurveyTimeRange(id: string) {
    return deleteItem(store, id);
  }
  

============================================================


📄 Arquivo : userRepository.ts
📂 Pasta   : repositories/indexeddb
🧭 Caminho : repositories/indexeddb/userRepository.ts
--------------------------------------
📜 Conteúdo:

import {
  createItem,
  getItem,
  getAllItems,
  updateItem,
  deleteItem,
} from "./indexedDBService";
import type { User } from "@/lib/types/indexeddb";

const store = "users" as const;

export async function createUser(user: User) {
  return createItem(store, user);
}

export async function getUser(id: string) {
  return getItem(store, id);
}

export async function getAllUsers() {
  return getAllItems(store);
}

export async function updateUser(id: string, data: Partial<User>) {
  return updateItem(store, id, data);
}

export async function deleteUser(id: string) {
  return deleteItem(store, id);
}


============================================================


📄 Arquivo : activityAnswerApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/activityAnswerApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/activityAnswerApi.ts
import { ActivityAnswer } from '@/lib/types/indexeddb';

const baseUrl = '/api/activity-answers';

export async function getActivityAnswers(): Promise<ActivityAnswer[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar respostas de atividade');
  return res.json();
}

export async function createActivityAnswer(data: ActivityAnswer): Promise<ActivityAnswer> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar resposta');
  return res.json();
}


============================================================


📄 Arquivo : dynamicSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/dynamicSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/dynamicSurveyApi.ts
import { DynamicSurvey } from '@/lib/types/indexeddb';

const baseUrl = '/api/surveys/dynamic'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getDynamicSurveys(): Promise<DynamicSurvey[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar surveys dinâmicos');
  return res.json();
}

export async function createDynamicSurvey(data: DynamicSurvey): Promise<DynamicSurvey> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey dinâmico');
  return res.json();
}


============================================================


📄 Arquivo : fieldApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/fieldApi.ts
--------------------------------------
📜 Conteúdo:

import { Field } from '@/lib/types/indexeddb';

const baseUrl = '/api/fields';

export async function getFields(survey_id: string, survey_type: string): Promise<Field[]> {
  const url = `${baseUrl}?survey_id=${survey_id}&survey_type=${survey_type}`;
  const res = await fetch(url);
  if (!res.ok) throw new Error('Erro ao buscar campos');
  return res.json();
}

export async function createField(data: Field): Promise<Field> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar campo');
  return res.json();
}

export async function updateField(data: Field): Promise<Field> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar campo');
  return res.json();
}

export async function deleteField(params: { field_id: string, survey_id: string, survey_type: string }): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}/delete?` + new URLSearchParams(params), {
    method: 'DELETE',
  });
  if (!res.ok) throw new Error('Erro ao deletar campo');
  return res.json();
}

============================================================


📄 Arquivo : fieldOptionApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/fieldOptionApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/fieldOptionApi.ts
import { FieldOption } from '@/lib/types/indexeddb';

const baseUrl = '/api/field-options'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getFieldOptions(field_id: string): Promise<FieldOption[]> {
  const res = await fetch(`${baseUrl}?field_id=${field_id}`);
  if (!res.ok) throw new Error('Erro ao buscar opções do campo');
  return res.json();
}

export async function createFieldOption(data: FieldOption): Promise<FieldOption> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar opção do campo');
  return res.json();
}


============================================================


📄 Arquivo : formSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/formSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/formSurveyApi.ts
import { FormSurvey } from '@/lib/types/indexeddb';

const baseUrl = '/api/surveys/form'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getFormSurveys(): Promise<FormSurvey[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar surveys de formulário');
  return res.json();
}

export async function createFormSurvey(data: FormSurvey): Promise<FormSurvey> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey de formulário');
  return res.json();
}


============================================================


📄 Arquivo : index.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/index.ts
--------------------------------------
📜 Conteúdo:

export * from './userApi';
export * from './activityAnswerApi';
export * from './fieldApi';
export * from './researchApi';
export * from './surveyTimeRangeApi';
export * from './surveyRegionApi';
export * from './surveyGroupApi';
export * from './surveyContributorApi';
export * from './surveyAnswerApi';
export * from './staticSurveyApi';
export * from './formSurveyApi';
export * from './dynamicSurveyApi';
export * from './researchContributorApi';
export * from './inputTypeApi';
export * from './fieldOptionApi';


============================================================


📄 Arquivo : inputTypeApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/inputTypeApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/inputTypeApi.ts
import { InputType } from '@/lib/types/indexeddb';

const baseUrl = '/api/input-types'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getInputTypes(): Promise<InputType[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar tipos de input');
  return res.json();
}


============================================================


📄 Arquivo : researchApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/researchApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/researchApi.ts
import { Research } from '@/lib/types/indexeddb';

const baseUrl = '/api/researches';

export async function getResearches(): Promise<Research[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar pesquisas');
  return res.json();
}

export async function getResearchById(id: string): Promise<Research> {
  const res = await fetch(`${baseUrl}/${id}`);
  if (!res.ok) throw new Error('Erro ao buscar pesquisa');
  const { research } = await res.json();
  return research;
}

export async function createResearch(data: Research): Promise<Research> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar pesquisa');
  return res.json();
}

export async function updateResearch(data: Research): Promise<Research> {
  const res = await fetch(`${baseUrl}/update`, {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar pesquisa');
  return res.json();
}

export async function deleteResearch(id: string): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id }),
  });
  if (!res.ok) throw new Error('Erro ao deletar pesquisa');
  return res.json();
}


============================================================


📄 Arquivo : researchContributorApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/researchContributorApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/researchContributorApi.ts
import { ResearchContributor } from '@/lib/types/indexeddb';

const baseUrl = '/api/research_contributors'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getResearchContributors(research_id: string): Promise<ResearchContributor[]> {
  const res = await fetch(`${baseUrl}?research_id=${research_id}`);
  if (!res.ok) throw new Error('Erro ao buscar colaboradores da pesquisa');
  return res.json();
}

export async function createResearchContributor(data: ResearchContributor): Promise<ResearchContributor> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar colaborador da pesquisa');
  return res.json();
}


============================================================


📄 Arquivo : staticSurveyApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/staticSurveyApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/staticSurveyApi.ts
import { StaticSurvey } from '@/lib/types/indexeddb';

const baseUrl = '/api/surveys/static'; // ⚠️ Este endpoint ainda NÃO está implementado em /pages/api

export async function getStaticSurveys(): Promise<StaticSurvey[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar surveys estáticos');
  return res.json();
}

export async function createStaticSurvey(data: StaticSurvey): Promise<StaticSurvey> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar survey estático');
  return res.json();
}


============================================================


📄 Arquivo : surveyAnswerApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyAnswerApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyAnswerApi.ts
import { SurveyAnswer } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-answers';

export async function getSurveyAnswers(): Promise<SurveyAnswer[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar respostas de coleta');
  return res.json();
}

export async function createSurveyAnswer(data: SurveyAnswer): Promise<SurveyAnswer> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar resposta');
  return res.json();
}


============================================================


📄 Arquivo : surveyContributorApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyContributorApi.ts
--------------------------------------
📜 Conteúdo:

import { SurveyContributor } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey_contributors';

export async function getSurveyContributors(survey_id: string, survey_type: string): Promise<SurveyContributor[]> {
  const res = await fetch(baseUrl + '?survey_id=' + survey_id + '&survey_type=' + survey_type);
  if (!res.ok) throw new Error('Erro ao buscar colaboradores da coleta');
  return res.json();
}

export async function createSurveyContributor(data: SurveyContributor): Promise<SurveyContributor> {
  const res = await fetch(`${baseUrl}/create`, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar colaborador da coleta');
  return res.json();
}

export async function deleteSurveyContributor(data: Pick<SurveyContributor, 'survey_id' | 'survey_type' | 'user_id'>): Promise<{ message: string }> {
  const res = await fetch(`${baseUrl}/delete`, {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao deletar colaborador');
  return res.json();
}


============================================================


📄 Arquivo : surveyGroupApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyGroupApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyGroupApi.ts
import { SurveyGroup } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-groups';

export async function getSurveyGroups(): Promise<SurveyGroup[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar grupos da coleta');
  return res.json();
}

export async function createSurveyGroup(data: SurveyGroup): Promise<SurveyGroup> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar grupo');
  return res.json();
}


============================================================


📄 Arquivo : surveyRegionApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyRegionApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyRegionApi.ts
import { SurveyRegion } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-regions';

export async function getSurveyRegions(): Promise<SurveyRegion[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar regiões da coleta');
  return res.json();
}

export async function createSurveyRegion(data: SurveyRegion): Promise<SurveyRegion> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar região da coleta');
  return res.json();
}


============================================================


📄 Arquivo : surveyTimeRangeApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/surveyTimeRangeApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/surveyTimeRangeApi.ts
import { SurveyTimeRange } from '@/lib/types/indexeddb';

const baseUrl = '/api/survey-time-ranges';

export async function getSurveyTimeRanges(): Promise<SurveyTimeRange[]> {
  const res = await fetch(baseUrl);
  if (!res.ok) throw new Error('Erro ao buscar faixas de horário');
  return res.json();
}

export async function createSurveyTimeRange(data: SurveyTimeRange): Promise<SurveyTimeRange> {
  const res = await fetch(baseUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar faixa de horário');
  return res.json();
}


============================================================


📄 Arquivo : userApi.ts
📂 Pasta   : repositories/server
🧭 Caminho : repositories/server/userApi.ts
--------------------------------------
📜 Conteúdo:

// src/repositories/server/userApi.ts

import { User } from '@/lib/types/indexeddb';

export async function getUsers(): Promise<User[]> {
  const res = await fetch('/api/users');
  if (!res.ok) throw new Error('Erro ao buscar usuários');
  const data = await res.json();
  return data;
}

export async function getUserById(id: string): Promise<User> {
  const res = await fetch(`/api/users/${id}`);
  if (!res.ok) throw new Error('Erro ao buscar usuário');
  const { user } = await res.json();
  return user;
}

export async function createUser(data: Partial<User>): Promise<User> {
  const res = await fetch('/api/users/register', {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao criar usuário');
  return res.json();
}

export async function updateUser(data: Partial<User>): Promise<User> {
  const res = await fetch('/api/users/update', {
    method: 'PUT',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify(data),
  });
  if (!res.ok) throw new Error('Erro ao atualizar usuário');
  return res.json();
}

export async function deleteUser(id: string): Promise<{ message: string }> {
  const res = await fetch('/api/users/delete', {
    method: 'DELETE',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({ id }),
  });
  if (!res.ok) throw new Error('Erro ao deletar usuário');
  return res.json();
}

============================================================


📄 Arquivo : cache.js
📂 Pasta   : services
🧭 Caminho : services/cache.js
--------------------------------------
📜 Conteúdo:

import { initCachedDB } from "@/lib/db";
import { v4 as uuidv4 } from "uuid";

// ======================
// UTILS
// ======================

const getStore = async (storeName, mode = "readonly") => {
  const db = await initCachedDB();
  const tx = db.transaction(storeName, mode);
  return tx.objectStore(storeName);
};

const configMap = {
  users: {
    endpoint: "/api/users", // Usado para leitura e sincronização geral
    createEndpoint: "/api/auth/register", // Usado para criar usuário
    updateEndpoint: "/api/users/update",   // Usado para atualizar usuário
    deleteEndpoint: "/api/users/delete",   // Usado para deletar usuário
    extract: (res) => res.users || [],
    single: (res) => res.user || null,
  },
  researches: { 
    endpoint: "/api/researches",
    createEndpoint: "/api/researches/create",
    updateEndpoint: "/api/researches/update",
    deleteEndpoint: "/api/researches/delete",
    extract: (res) => res.researches || [],
    single: (res) => res.research || null,
  },
};

// ======================
// CACHE FUNCTIONS
// ======================

export async function getCachedData(
  storeName,
  {
    paginated = false,
    page = 1,
    perPage = 20,
    order = "desc",
    search = "",
    filterStatus = "",
    filterRole = "",
  } = {}
) {
  const mainStore = await getStore(storeName);
  const baseItems = await mainStore.getAll();

  let pendingItems = [];
  try {
    const pendingStore = await getStore("itemTobeCreated");
    const allPending = await pendingStore.getAll();
    pendingItems = allPending.filter(item => item._originStore === storeName);
  } catch (err) {
    // Se a store pending não estiver disponível, ignora
  }

  let allItems = [...baseItems, ...pendingItems];

  // 🔍 Filtro por busca (nome ou email)
  if (search) {
    const lowerSearch = search.toLowerCase();
    allItems = allItems.filter(
      item =>
        item.name?.toLowerCase().includes(lowerSearch) ||
        item.email?.toLowerCase().includes(lowerSearch)
    );
  }

  if (filterStatus) {
    allItems = allItems.filter(item => item.status === filterStatus);
  }

  if (filterRole) {
    allItems = allItems.filter(item => item.role === filterRole);
  }

  allItems.sort((a, b) => {
    const dateA = new Date(a.created_at || a.createdAt || 0).getTime();
    const dateB = new Date(b.created_at || b.createdAt || 0).getTime();
    return order === "asc" ? dateA - dateB : dateB - dateA;
  });

  if (!paginated) return allItems;

  const total = allItems.length;
  const totalPages = Math.ceil(total / perPage);
  const start = (page - 1) * perPage;
  const items = allItems.slice(start, start + perPage);

  return {
    items,
    total,
    page,
    perPage,
    totalPages,
  };
}


export async function getCachedItemById(storeName, id) {
  const store = await getStore(storeName);
  return (await store.get(id)) || null;
}

export async function addCachedItem(storeName, item) {
  const store = await getStore(storeName, "readwrite");
  if (await store.get(item.id)) throw new Error(`Item ${item.id} já existe`);
  await store.put(item);
}

export async function updateCachedItemById(storeName, id, updates) {
  const store = await getStore(storeName, "readwrite");
  const item = await store.get(id);
  if (!item) throw new Error(`Item ${id} não encontrado`);
  const updated = { ...item, ...updates };
  await store.put(updated);
  return updated;
}

export async function deleteCachedItemById(storeName, id) {
  const store = await getStore(storeName, "readwrite");
  if (!(await store.get(id))) throw new Error(`Item ${id} não encontrado`);
  await store.delete(id);
}

// ======================
// SYNC MARKERS
// ======================

export const markItemForCreate = async (store, item) => {
  const mainStore = await getStore(store, "readonly");
  const mainItems = await mainStore.getAll();
  const duplicateInMain = mainItems.find(i => i.email === item.email);

  let duplicateInPending = false;
  try {
    const pendingStore = await getStore("itemTobeCreated", "readonly");
    const pendingItems = await pendingStore.getAll();
    duplicateInPending = pendingItems.some(i => i._originStore === store && i.email === item.email);
  } catch (err) {
    // Se não conseguir verificar duplicidade, segue sem bloquear.
  }

  if (duplicateInMain || duplicateInPending) {
    throw new Error(`Registro com email ${item.email} já existe.`);
  }

  const tempId = `temp-${uuidv4()}`;
  const newItem = {
    ...item,
    id: tempId,
    _syncStatus: "pendingCreate",
    _originStore: store,
  };

  const pendingStoreWrite = await getStore("itemTobeCreated", "readwrite");
  await pendingStoreWrite.put(newItem);
  return newItem;
};

export const markItemForUpdate = (store, id, updates) =>
  updateCachedItemById(store, id, { ...updates, _syncStatus: "pendingUpdate" });

export async function markItemForDelete(store, id) {
  const item = await getCachedItemById(store, id);
  if (item) {
    await updateCachedItemById(store, id, { ...item, _syncStatus: "pendingDelete" });
  }
}

// ======================
// SANITIZE
// ======================

export const sanitizeData = (data, fields = ["_syncStatus"]) =>
  Object.fromEntries(Object.entries(data || {}).filter(([key]) => !fields.includes(key)));

export const sanitizeDataArray = (arr, fields) =>
  arr.map(item => sanitizeData(item, fields));

// ======================
// SYNC FUNCTIONS
// ======================

export async function syncCachedData(store) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  try {
    const res = await fetch(config.endpoint);
    if (!res.ok) throw new Error(`Erro ao sync ${store}`);
    const items = config.extract(await res.json());
    const storeRef = await getStore(store, "readwrite");
    await storeRef.clear();
    for (const item of items) {
      await storeRef.put({ ...item, _syncStatus: "synced" });
    }
    return { success: true, updated: items.length };
  } catch (err) {
    throw err;
  }
}

export async function syncCachedDataById(store, id) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  try {
    const res = await fetch(`${config.endpoint}/${id}`);
    if (!res.ok) throw new Error(`Erro ao sync ${store}/${id}`);
    const item = config.single(await res.json());
    if (!item) throw new Error(`Item ${id} não encontrado`);
    const storeRef = await getStore(store, "readwrite");
    await storeRef.put({ ...item, _syncStatus: "synced" });
    return { success: true, updated: item };
  } catch (err) {
    throw err;
  }
}

export async function syncLocalToServer(store) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  if (!navigator.onLine) return { success: false, message: "Offline" };

  const db = await initCachedDB();

  // Sincroniza pendingCreate
  const mainItems = await db.getAll(store);
  const pendingItems = await db.getAll("itemTobeCreated");
  const toBeCreated = pendingItems.filter(item => item._originStore === store);

  await Promise.all(
    toBeCreated.map(async (item) => {
      try {
        const payload = sanitizeData(item, ["_syncStatus", "_originStore", "id"]);
        const endpointForCreation = config.createEndpoint || config.endpoint;
        const res = await fetch(endpointForCreation, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify(payload),
        });
        if (res.ok) {
          const resData = await res.json();
          const serverItem = config.single(resData);
          if (serverItem) {
            await db.put(store, { ...serverItem, _syncStatus: "synced" });
            await db.delete("itemTobeCreated", item.id);
          }
        }
      } catch (err) {
        // Erro na criação é logado internamente se necessário
      }
    })
  );

  // Sincroniza update e delete
  await Promise.all(
    mainItems.map(async (item) => {
      const status = item._syncStatus;
      if (!status?.startsWith("pending")) return;
      const action = status.replace("pending", "").toLowerCase();
      const endpointForAction = action === "delete" ? config.deleteEndpoint : config.updateEndpoint;
      const method = action === "delete" ? "DELETE" : "PUT";
      const body = JSON.stringify(sanitizeData(item));
      try {
        const res = await fetch(endpointForAction, {
          method,
          headers: { "Content-Type": "application/json" },
          body,
        });
        if (res.ok) {
          if (action === "delete") {
            await db.delete(store, item.id);
          } else {
            let updatedItem = item;
            try {
              const resData = await res.json();
              const serverItem = config.single(resData);
              if (serverItem) updatedItem = serverItem;
            } catch (_) {}
            await db.put(store, { ...updatedItem, _syncStatus: "synced" });
          }
        }
      } catch (err) {
        // Erro na sincronização de update/delete
      }
    })
  );

  return { success: true };
}

export async function syncServerToCache(store) {
  const config = configMap[store];
  if (!config) throw new Error(`Sem config para ${store}`);
  try {
    const res = await fetch(config.endpoint);
    if (!res.ok) throw new Error(`Erro ao sync servidor->cache de ${store}`);
    const serverItems = config.extract(await res.json());
    const storeRef = await getStore(store, "readwrite");
    const localItems = await storeRef.getAll();
    const localMap = new Map(localItems.map(item => [item.id, item]));
    for (const serverItem of serverItems) {
      const local = localMap.get(serverItem.id);
      if (
        !local ||
        local._syncStatus === "synced" ||
        local._syncStatus === "pendingUpdate" ||
        local._syncStatus === "pendingCreate"
      ) {
        await storeRef.put({ ...serverItem, _syncStatus: "synced" });
      }
    }
    return { success: true, updated: serverItems.length };
  } catch (err) {
    throw err;
  }
}


============================================================


📄 Arquivo : registerServiceWorker.js
📂 Pasta   : services
🧭 Caminho : services/registerServiceWorker.js
--------------------------------------
📜 Conteúdo:

// /services/registerServiceWorker.js
export function registerServiceWorker() {
    if ('serviceWorker' in navigator) {
      navigator.serviceWorker.register('/workers/sw.js')
        .then(reg => console.log('✅ Service Worker registrado!', reg))
        .catch(err => console.error('❌ Erro ao registrar o Service Worker:', err));
    }
  }
  

============================================================


📄 Arquivo : syncWorker.ts
📂 Pasta   : services
🧭 Caminho : services/syncWorker.ts
--------------------------------------
📜 Conteúdo:

// src/services/syncWorker.ts
import { StoreTypes } from '@/lib/types/indexeddb';
import { getAllItems, updateItem } from '@/repositories/indexeddb/indexedDBService';
import {
  createActivityAnswer,
  createSurveyAnswer,
  createUser,
  createField,
  createResearch,
  createSurveyRegion,
  createSurveyGroup,
  createSurveyTimeRange,
  createSurveyContributor,
  createStaticSurvey,
  createFormSurvey,
  createDynamicSurvey,
  createResearchContributor,
  createFieldOption
} from '@/repositories/server';

const SYNCABLE_ENTITIES: (keyof StoreTypes)[] = [
  'activity_answers',
  'survey_answers',
  'users',
  'fields',
  'researches',
  'survey_regions',
  'survey_group',
  'survey_time_ranges',
  'survey_contributors',
  'static_surveys',
  'form_surveys',
  'dynamic_surveys',
  'research_contributors',
  'field_options'
];

const syncFunctionMap = {
  activity_answers: createActivityAnswer,
  survey_answers: createSurveyAnswer,
  users: createUser,
  fields: createField,
  researches: createResearch,
  survey_regions: createSurveyRegion,
  survey_group: createSurveyGroup,
  survey_time_ranges: createSurveyTimeRange,
  survey_contributors: createSurveyContributor,
  static_surveys: createStaticSurvey,
  form_surveys: createFormSurvey,
  dynamic_surveys: createDynamicSurvey,
  research_contributors: createResearchContributor,
  field_options: createFieldOption
};

export async function trySyncAllPending() {
  for (const entity of SYNCABLE_ENTITIES) {
    const items = await getAllItems(entity);
    const pendingItems = items.filter((item: any) => item._syncStatus === 'pending' || item._syncStatus === 'error');

    for (const item of pendingItems) {
      try {
        const creator = syncFunctionMap[entity];
        if (creator) await creator(item);
        await updateItem(entity, item.id, { _syncStatus: 'synced' });
      } catch (err) {
        console.error(`Falha ao sincronizar ${entity}:`, err);
        await updateItem(entity, item.id, { _syncStatus: 'error' });
      }
    }
  }
}

if (typeof window !== 'undefined') {
  window.addEventListener('online', () => {
    console.log('[SYNC] Conectado! Tentando sincronizar...');
    trySyncAllPending();
  });
}


============================================================


📄 Arquivo : globals.css
📂 Pasta   : styles
🧭 Caminho : styles/globals.css
--------------------------------------
📜 Conteúdo:

@tailwind base;
@tailwind components;
@tailwind utilities;



body {
  color: black;
  background: white;
  font-family: Inter, sans-serif;
}



/* global.css */
.react-calendar {
  @apply rounded-lg p-3 bg-white text-sm;
}
.react-calendar__tile--active {
  @apply bg-black text-white rounded-md;
}
.react-calendar__tile--now {
  @apply bg-blue-100;
}

@keyframes slideInRight {
  from {
    transform: translateX(100%);
  }
  to {
    transform: translateX(0%);
  }
}

@keyframes slideInLeft {
  from {
    transform: translateX(-100%);
  }
  to {
    transform: translateX(0%);
  }
}

.animate-slide-in-right {
  animation: slideInRight 0.3s ease-out;
}

.animate-slide-in-left {
  animation: slideInLeft 0.3s ease-out;
}


.react-select__control {
  @apply border-zinc-300 dark:border-zinc-700 bg-white dark:bg-zinc-900 text-sm rounded-lg shadow-sm;
}
.react-select__menu {
  @apply bg-white dark:bg-zinc-800 text-sm shadow-lg rounded-md;
}
.react-select__option--is-focused {
  @apply bg-zinc-100 dark:bg-zinc-700;
}
.react-select__multi-value {
  @apply bg-zinc-200 dark:bg-zinc-700 text-zinc-800 dark:text-zinc-200 px-1 rounded;
}



============================================================


📄 Arquivo : formatDate.js
📂 Pasta   : utils
🧭 Caminho : utils/formatDate.js
--------------------------------------
📜 Conteúdo:

export function formatDateToDDMMYY(dateString) {
  if (!dateString) return "";
  const date = new Date(dateString);
  const day = String(date.getDate()).padStart(2, "0");
  const month = String(date.getMonth() + 1).padStart(2, "0");
  const year = String(date.getFullYear());
  return `${day}/${month}/${year}`;
}

export function formatDateToLocalYYYYMMDD(date) {
  const year = date.getFullYear();
  const month = `${date.getMonth() + 1}`.padStart(2, "0");
  const day = `${date.getDate()}`.padStart(2, "0");
  return `${year}-${month}-${day}`;
}


============================================================


